{"ast":null,"code":"/*\n Highstock JS v7.2.0 (2019-09-03)\n\n (c) 2009-2018 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (Q, K) {\n  \"object\" === typeof module && module.exports ? (K[\"default\"] = K, module.exports = Q.document ? K(Q) : K) : \"function\" === typeof define && define.amd ? define(\"highcharts/highstock\", function () {\n    return K(Q);\n  }) : (Q.Highcharts && Q.Highcharts.error(16, !0), Q.Highcharts = K(Q));\n})(\"undefined\" !== typeof window ? window : this, function (Q) {\n  function K(d, k, w, D) {\n    d.hasOwnProperty(k) || (d[k] = D.apply(null, w));\n  }\n\n  var I = {};\n  K(I, \"parts/Globals.js\", [], function () {\n    var d = \"undefined\" !== typeof Q ? Q : \"undefined\" !== typeof window ? window : {},\n        k = d.document,\n        w = d.navigator && d.navigator.userAgent || \"\",\n        D = k && k.createElementNS && !!k.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        H = /(edge|msie|trident)/i.test(w) && !d.opera,\n        E = -1 !== w.indexOf(\"Firefox\"),\n        y = -1 !== w.indexOf(\"Chrome\"),\n        C = E && 4 > parseInt(w.split(\"Firefox/\")[1], 10);\n    return {\n      product: \"Highcharts\",\n      version: \"7.2.0\",\n      deg2rad: 2 * Math.PI / 360,\n      doc: k,\n      hasBidiBug: C,\n      hasTouch: !!d.TouchEvent,\n      isMS: H,\n      isWebKit: -1 !== w.indexOf(\"AppleWebKit\"),\n      isFirefox: E,\n      isChrome: y,\n      isSafari: !y && -1 !== w.indexOf(\"Safari\"),\n      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(w),\n      SVG_NS: \"http://www.w3.org/2000/svg\",\n      chartCount: 0,\n      seriesTypes: {},\n      symbolSizes: {},\n      svg: D,\n      win: d,\n      marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n      noop: function () {},\n      charts: [],\n      dateFormats: {}\n    };\n  });\n  K(I, \"parts/Utilities.js\", [I[\"parts/Globals.js\"]], function (d) {\n    function k(c, a) {\n      return parseInt(c, a || 10);\n    }\n\n    function w(c) {\n      return \"string\" === typeof c;\n    }\n\n    function D(c) {\n      c = Object.prototype.toString.call(c);\n      return \"[object Array]\" === c || \"[object Array Iterator]\" === c;\n    }\n\n    function H(c, a) {\n      return !!c && \"object\" === typeof c && (!a || !D(c));\n    }\n\n    function E(c) {\n      return H(c) && \"number\" === typeof c.nodeType;\n    }\n\n    function y(c) {\n      var a = c && c.constructor;\n      return !(!H(c, !0) || E(c) || !a || !a.name || \"Object\" === a.name);\n    }\n\n    function C(c) {\n      return \"number\" === typeof c && !isNaN(c) && Infinity > c && -Infinity < c;\n    }\n\n    function t(c) {\n      return \"undefined\" !== typeof c && null !== c;\n    }\n\n    function G(c, a, b) {\n      var f;\n      w(a) ? t(b) ? c.setAttribute(a, b) : c && c.getAttribute && ((f = c.getAttribute(a)) || \"class\" !== a || (f = c.getAttribute(a + \"Name\"))) : u(a, function (a, b) {\n        c.setAttribute(b, a);\n      });\n      return f;\n    }\n\n    function u(c, a, b) {\n      for (var f in c) Object.hasOwnProperty.call(c, f) && a.call(b || c[f], c[f], f, c);\n    }\n\n    d.timers = [];\n    var l = d.charts,\n        p = d.doc,\n        q = d.win;\n\n    d.error = function (c, a, b) {\n      var f = C(c) ? \"Highcharts error #\" + c + \": www.highcharts.com/errors/\" + c : c,\n          m = function () {\n        if (a) throw Error(f);\n        q.console && console.log(f);\n      };\n\n      b ? d.fireEvent(b, \"displayError\", {\n        code: c,\n        message: f\n      }, m) : m();\n    };\n\n    d.Fx = function (c, a, b) {\n      this.options = a;\n      this.elem = c;\n      this.prop = b;\n    };\n\n    d.Fx.prototype = {\n      dSetter: function () {\n        var c = this.paths[0],\n            a = this.paths[1],\n            b = [],\n            f = this.now,\n            m = c.length;\n        if (1 === f) b = this.toD;else if (m === a.length && 1 > f) for (; m--;) {\n          var h = parseFloat(c[m]);\n          b[m] = isNaN(h) ? a[m] : f * parseFloat(\"\" + (a[m] - h)) + h;\n        } else b = a;\n        this.elem.attr(\"d\", b, null, !0);\n      },\n      update: function () {\n        var c = this.elem,\n            a = this.prop,\n            b = this.now,\n            f = this.options.step;\n        if (this[a + \"Setter\"]) this[a + \"Setter\"]();else c.attr ? c.element && c.attr(a, b, null, !0) : c.style[a] = b + this.unit;\n        f && f.call(c, b, this);\n      },\n      run: function (c, a, b) {\n        var f = this,\n            m = f.options,\n            h = function (a) {\n          return h.stopped ? !1 : f.step(a);\n        },\n            r = q.requestAnimationFrame || function (a) {\n          setTimeout(a, 13);\n        },\n            x = function () {\n          for (var a = 0; a < d.timers.length; a++) d.timers[a]() || d.timers.splice(a--, 1);\n\n          d.timers.length && r(x);\n        };\n\n        c !== a || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = c, this.end = a, this.unit = b, this.now = this.start, this.pos = 0, h.elem = this.elem, h.prop = this.prop, h() && 1 === d.timers.push(h) && r(x)) : (delete m.curAnim[this.prop], m.complete && 0 === Object.keys(m.curAnim).length && m.complete.call(this.elem));\n      },\n      step: function (c) {\n        var a = +new Date(),\n            b = this.options,\n            f = this.elem,\n            m = b.complete,\n            h = b.duration,\n            d = b.curAnim;\n        if (f.attr && !f.element) c = !1;else if (c || a >= h + this.startTime) {\n          this.now = this.end;\n          this.pos = 1;\n          this.update();\n          var x = d[this.prop] = !0;\n          u(d, function (a) {\n            !0 !== a && (x = !1);\n          });\n          x && m && m.call(f);\n          c = !1;\n        } else this.pos = b.easing((a - this.startTime) / h), this.now = this.start + (this.end - this.start) * this.pos, this.update(), c = !0;\n        return c;\n      },\n      initPath: function (c, a, b) {\n        function f(a) {\n          for (g = a.length; g--;) {\n            var e = \"M\" === a[g] || \"L\" === a[g];\n            var b = /[a-zA-Z]/.test(a[g + 3]);\n            e && b && a.splice(g + 1, 0, a[g + 1], a[g + 2], a[g + 1], a[g + 2]);\n          }\n        }\n\n        function m(a, e) {\n          for (; a.length < J;) {\n            a[0] = e[J - a.length];\n            var b = a.slice(0, n);\n            [].splice.apply(a, [0, 0].concat(b));\n            F && (b = a.slice(a.length - n), [].splice.apply(a, [a.length, 0].concat(b)), g--);\n          }\n\n          a[0] = \"M\";\n        }\n\n        function h(a, b) {\n          for (var g = (J - a.length) / n; 0 < g && g--;) e = a.slice().splice(a.length / A - n, n * A), e[0] = b[J - n - g * n], v && (e[n - 6] = e[n - 2], e[n - 5] = e[n - 1]), [].splice.apply(a, [a.length / A, 0].concat(e)), F && g--;\n        }\n\n        a = a || \"\";\n        var d = c.startX,\n            x = c.endX,\n            v = -1 < a.indexOf(\"C\"),\n            n = v ? 7 : 3,\n            e,\n            g;\n        a = a.split(\" \");\n        b = b.slice();\n        var F = c.isArea,\n            A = F ? 2 : 1;\n        v && (f(a), f(b));\n\n        if (d && x) {\n          for (g = 0; g < d.length; g++) if (d[g] === x[0]) {\n            var z = g;\n            break;\n          } else if (d[0] === x[x.length - d.length + g]) {\n            z = g;\n            var B = !0;\n            break;\n          } else if (d[d.length - 1] === x[x.length - d.length + g]) {\n            z = d.length - g;\n            break;\n          }\n\n          \"undefined\" === typeof z && (a = []);\n        }\n\n        if (a.length && C(z)) {\n          var J = b.length + z * A * n;\n          B ? (m(a, b), h(b, a)) : (m(b, a), h(a, b));\n        }\n\n        return [a, b];\n      },\n      fillSetter: function () {\n        d.Fx.prototype.strokeSetter.apply(this, arguments);\n      },\n      strokeSetter: function () {\n        this.elem.attr(this.prop, d.color(this.start).tweenTo(d.color(this.end), this.pos), null, !0);\n      }\n    };\n\n    d.merge = function () {\n      var c,\n          a = arguments,\n          b = {},\n          f = function (a, b) {\n        \"object\" !== typeof a && (a = {});\n        u(b, function (c, h) {\n          !H(c, !0) || y(c) || E(c) ? a[h] = b[h] : a[h] = f(a[h] || {}, c);\n        });\n        return a;\n      };\n\n      !0 === a[0] && (b = a[1], a = Array.prototype.slice.call(a, 2));\n      var m = a.length;\n\n      for (c = 0; c < m; c++) b = f(b, a[c]);\n\n      return b;\n    };\n\n    d.syncTimeout = function (c, a, b) {\n      if (a) return setTimeout(c, a, b);\n      c.call(0, b);\n    };\n\n    d.clearTimeout = function (c) {\n      t(c) && clearTimeout(c);\n    };\n\n    d.extend = function (c, a) {\n      var b;\n      c || (c = {});\n\n      for (b in a) c[b] = a[b];\n\n      return c;\n    };\n\n    d.pick = function () {\n      var c = arguments,\n          a,\n          b = c.length;\n\n      for (a = 0; a < b; a++) {\n        var f = c[a];\n        if (\"undefined\" !== typeof f && null !== f) return f;\n      }\n    };\n\n    d.css = function (c, a) {\n      d.isMS && !d.svg && a && \"undefined\" !== typeof a.opacity && (a.filter = \"alpha(opacity=\" + 100 * a.opacity + \")\");\n      d.extend(c.style, a);\n    };\n\n    d.createElement = function (c, a, b, f, m) {\n      c = p.createElement(c);\n      var h = d.css;\n      a && d.extend(c, a);\n      m && h(c, {\n        padding: \"0\",\n        border: \"none\",\n        margin: \"0\"\n      });\n      b && h(c, b);\n      f && f.appendChild(c);\n      return c;\n    };\n\n    d.extendClass = function (c, a) {\n      var b = function () {};\n\n      b.prototype = new c();\n      d.extend(b.prototype, a);\n      return b;\n    };\n\n    d.pad = function (c, a, b) {\n      return Array((a || 2) + 1 - String(c).replace(\"-\", \"\").length).join(b || \"0\") + c;\n    };\n\n    d.relativeLength = function (c, a, b) {\n      return /%$/.test(c) ? a * parseFloat(c) / 100 + (b || 0) : parseFloat(c);\n    };\n\n    d.wrap = function (c, a, b) {\n      var f = c[a];\n\n      c[a] = function () {\n        var a = Array.prototype.slice.call(arguments),\n            c = arguments,\n            d = this;\n\n        d.proceed = function () {\n          f.apply(d, arguments.length ? arguments : c);\n        };\n\n        a.unshift(f);\n        a = b.apply(this, a);\n        d.proceed = null;\n        return a;\n      };\n    };\n\n    d.datePropsToTimestamps = function (c) {\n      u(c, function (a, b) {\n        H(a) && \"function\" === typeof a.getTime ? c[b] = a.getTime() : (H(a) || D(a)) && d.datePropsToTimestamps(a);\n      });\n    };\n\n    d.formatSingle = function (c, a, b) {\n      var f = /\\.([0-9])/,\n          m = d.defaultOptions.lang;\n      /f$/.test(c) ? (b = (b = c.match(f)) ? b[1] : -1, null !== a && (a = d.numberFormat(a, b, m.decimalPoint, -1 < c.indexOf(\",\") ? m.thousandsSep : \"\"))) : a = (b || d.time).dateFormat(c, a);\n      return a;\n    };\n\n    d.format = function (c, a, b) {\n      for (var f = \"{\", m = !1, h, r, x, v, n = [], e; c;) {\n        f = c.indexOf(f);\n        if (-1 === f) break;\n        h = c.slice(0, f);\n\n        if (m) {\n          h = h.split(\":\");\n          r = h.shift().split(\".\");\n          v = r.length;\n          e = a;\n\n          for (x = 0; x < v; x++) e && (e = e[r[x]]);\n\n          h.length && (e = d.formatSingle(h.join(\":\"), e, b));\n          n.push(e);\n        } else n.push(h);\n\n        c = c.slice(f + 1);\n        f = (m = !m) ? \"}\" : \"{\";\n      }\n\n      n.push(c);\n      return n.join(\"\");\n    };\n\n    d.getMagnitude = function (c) {\n      return Math.pow(10, Math.floor(Math.log(c) / Math.LN10));\n    };\n\n    d.normalizeTickInterval = function (c, a, b, f, m) {\n      var h = c;\n      b = d.pick(b, 1);\n      var r = c / b;\n      a || (a = m ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === f && (1 === b ? a = a.filter(function (a) {\n        return 0 === a % 1;\n      }) : .1 >= b && (a = [1 / b])));\n\n      for (f = 0; f < a.length && !(h = a[f], m && h * b >= c || !m && r <= (a[f] + (a[f + 1] || a[f])) / 2); f++);\n\n      return h = d.correctFloat(h * b, -Math.round(Math.log(.001) / Math.LN10));\n    };\n\n    d.stableSort = function (c, a) {\n      var b = c.length,\n          f,\n          m;\n\n      for (m = 0; m < b; m++) c[m].safeI = m;\n\n      c.sort(function (b, c) {\n        f = a(b, c);\n        return 0 === f ? b.safeI - c.safeI : f;\n      });\n\n      for (m = 0; m < b; m++) delete c[m].safeI;\n    };\n\n    d.arrayMin = function (c) {\n      for (var a = c.length, b = c[0]; a--;) c[a] < b && (b = c[a]);\n\n      return b;\n    };\n\n    d.arrayMax = function (c) {\n      for (var a = c.length, b = c[0]; a--;) c[a] > b && (b = c[a]);\n\n      return b;\n    };\n\n    d.destroyObjectProperties = function (c, a) {\n      u(c, function (b, f) {\n        b && b !== a && b.destroy && b.destroy();\n        delete c[f];\n      });\n    };\n\n    d.discardElement = function (c) {\n      var a = d.garbageBin;\n      a || (a = d.createElement(\"div\"));\n      c && a.appendChild(c);\n      a.innerHTML = \"\";\n    };\n\n    d.correctFloat = function (c, a) {\n      return parseFloat(c.toPrecision(a || 14));\n    };\n\n    d.setAnimation = function (c, a) {\n      a.renderer.globalAnimation = d.pick(c, a.options.chart.animation, !0);\n    };\n\n    d.animObject = function (c) {\n      return H(c) ? d.merge(c) : {\n        duration: c ? 500 : 0\n      };\n    };\n\n    d.timeUnits = {\n      millisecond: 1,\n      second: 1E3,\n      minute: 6E4,\n      hour: 36E5,\n      day: 864E5,\n      week: 6048E5,\n      month: 24192E5,\n      year: 314496E5\n    };\n\n    d.numberFormat = function (c, a, b, f) {\n      c = +c || 0;\n      a = +a;\n      var m = d.defaultOptions.lang,\n          h = (c.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          r = c.toString().split(\"e\");\n      if (-1 === a) a = Math.min(h, 20);else if (!C(a)) a = 2;else if (a && r[1] && 0 > r[1]) {\n        var x = a + +r[1];\n        0 <= x ? (r[0] = (+r[0]).toExponential(x).split(\"e\")[0], a = x) : (r[0] = r[0].split(\".\")[0] || 0, c = 20 > a ? (r[0] * Math.pow(10, r[1])).toFixed(a) : 0, r[1] = 0);\n      }\n      var v = (Math.abs(r[1] ? r[0] : c) + Math.pow(10, -Math.max(a, h) - 1)).toFixed(a);\n      h = String(k(v));\n      x = 3 < h.length ? h.length % 3 : 0;\n      b = d.pick(b, m.decimalPoint);\n      f = d.pick(f, m.thousandsSep);\n      c = (0 > c ? \"-\" : \"\") + (x ? h.substr(0, x) + f : \"\");\n      c += h.substr(x).replace(/(\\d{3})(?=\\d)/g, \"$1\" + f);\n      a && (c += b + v.slice(-a));\n      r[1] && 0 !== +c && (c += \"e\" + r[1]);\n      return c;\n    };\n\n    Math.easeInOutSine = function (c) {\n      return -.5 * (Math.cos(Math.PI * c) - 1);\n    };\n\n    d.getStyle = function (c, a, b) {\n      if (\"width\" === a) return a = Math.min(c.offsetWidth, c.scrollWidth), b = c.getBoundingClientRect && c.getBoundingClientRect().width, b < a && b >= a - 1 && (a = Math.floor(b)), Math.max(0, a - d.getStyle(c, \"padding-left\") - d.getStyle(c, \"padding-right\"));\n      if (\"height\" === a) return Math.max(0, Math.min(c.offsetHeight, c.scrollHeight) - d.getStyle(c, \"padding-top\") - d.getStyle(c, \"padding-bottom\"));\n      q.getComputedStyle || d.error(27, !0);\n      if (c = q.getComputedStyle(c, void 0)) c = c.getPropertyValue(a), d.pick(b, \"opacity\" !== a) && (c = k(c));\n      return c;\n    };\n\n    d.inArray = function (c, a, b) {\n      return a.indexOf(c, b);\n    };\n\n    d.find = Array.prototype.find ? function (c, a) {\n      return c.find(a);\n    } : function (c, a) {\n      var b,\n          f = c.length;\n\n      for (b = 0; b < f; b++) if (a(c[b], b)) return c[b];\n    };\n    d.keys = Object.keys;\n\n    d.offset = function (c) {\n      var a = p.documentElement;\n      c = c.parentElement || c.parentNode ? c.getBoundingClientRect() : {\n        top: 0,\n        left: 0\n      };\n      return {\n        top: c.top + (q.pageYOffset || a.scrollTop) - (a.clientTop || 0),\n        left: c.left + (q.pageXOffset || a.scrollLeft) - (a.clientLeft || 0)\n      };\n    };\n\n    d.stop = function (c, a) {\n      for (var b = d.timers.length; b--;) d.timers[b].elem !== c || a && a !== d.timers[b].prop || (d.timers[b].stopped = !0);\n    };\n\n    u({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (c, a) {\n      d[a] = function (a) {\n        return Array.prototype[c].apply(a, [].slice.call(arguments, 1));\n      };\n    });\n\n    d.addEvent = function (c, a, b, f) {\n      void 0 === f && (f = {});\n      var m = c.addEventListener || d.addEventListenerPolyfill;\n      var h = \"function\" === typeof c && c.prototype ? c.prototype.protoEvents = c.prototype.protoEvents || {} : c.hcEvents = c.hcEvents || {};\n      d.Point && c instanceof d.Point && c.series && c.series.chart && (c.series.chart.runTrackerClick = !0);\n      m && m.call(c, a, b, !1);\n      h[a] || (h[a] = []);\n      h[a].push({\n        fn: b,\n        order: \"number\" === typeof f.order ? f.order : Infinity\n      });\n      h[a].sort(function (a, b) {\n        return a.order - b.order;\n      });\n      return function () {\n        d.removeEvent(c, a, b);\n      };\n    };\n\n    d.removeEvent = function (c, a, b) {\n      function f(a, b) {\n        var f = c.removeEventListener || d.removeEventListenerPolyfill;\n        f && f.call(c, a, b, !1);\n      }\n\n      function m(b) {\n        var h;\n\n        if (c.nodeName) {\n          if (a) {\n            var m = {};\n            m[a] = !0;\n          } else m = b;\n\n          u(m, function (a, e) {\n            if (b[e]) for (h = b[e].length; h--;) f(e, b[e][h].fn);\n          });\n        }\n      }\n\n      var h;\n      [\"protoEvents\", \"hcEvents\"].forEach(function (d) {\n        var r = c[d];\n        r && (a ? (h = r[a] || [], b ? (r[a] = h.filter(function (a) {\n          return b !== a.fn;\n        }), f(a, b)) : (m(r), r[a] = [])) : (m(r), c[d] = {}));\n      });\n    };\n\n    d.fireEvent = function (c, a, b, f) {\n      var m;\n      b = b || {};\n\n      if (p.createEvent && (c.dispatchEvent || c.fireEvent)) {\n        var h = p.createEvent(\"Events\");\n        h.initEvent(a, !0, !0);\n        d.extend(h, b);\n        c.dispatchEvent ? c.dispatchEvent(h) : c.fireEvent(a, h);\n      } else b.target || d.extend(b, {\n        preventDefault: function () {\n          b.defaultPrevented = !0;\n        },\n        target: c,\n        type: a\n      }), function (a, f) {\n        void 0 === a && (a = []);\n        void 0 === f && (f = []);\n        var h = 0,\n            n = 0,\n            e = a.length + f.length;\n\n        for (m = 0; m < e; m++) !1 === (a[h] ? f[n] ? a[h].order <= f[n].order ? a[h++] : f[n++] : a[h++] : f[n++]).fn.call(c, b) && b.preventDefault();\n      }(c.protoEvents && c.protoEvents[a], c.hcEvents && c.hcEvents[a]);\n\n      f && !b.defaultPrevented && f.call(c, b);\n    };\n\n    d.animate = function (c, a, b) {\n      var f,\n          m = \"\",\n          h,\n          r;\n\n      if (!H(b)) {\n        var x = arguments;\n        b = {\n          duration: x[2],\n          easing: x[3],\n          complete: x[4]\n        };\n      }\n\n      C(b.duration) || (b.duration = 400);\n      b.easing = \"function\" === typeof b.easing ? b.easing : Math[b.easing] || Math.easeInOutSine;\n      b.curAnim = d.merge(a);\n      u(a, function (v, n) {\n        d.stop(c, n);\n        r = new d.Fx(c, b, n);\n        h = null;\n        \"d\" === n ? (r.paths = r.initPath(c, c.d, a.d), r.toD = a.d, f = 0, h = 1) : c.attr ? f = c.attr(n) : (f = parseFloat(d.getStyle(c, n)) || 0, \"opacity\" !== n && (m = \"px\"));\n        h || (h = v);\n        h && h.match && h.match(\"px\") && (h = h.replace(/px/g, \"\"));\n        r.run(f, h, m);\n      });\n    };\n\n    d.seriesType = function (c, a, b, f, m) {\n      var h = d.getOptions(),\n          r = d.seriesTypes;\n      h.plotOptions[c] = d.merge(h.plotOptions[a], b);\n      r[c] = d.extendClass(r[a] || function () {}, f);\n      r[c].prototype.type = c;\n      m && (r[c].prototype.pointClass = d.extendClass(d.Point, m));\n      return r[c];\n    };\n\n    d.uniqueKey = function () {\n      var c = Math.random().toString(36).substring(2, 9),\n          a = 0;\n      return function () {\n        return \"highcharts-\" + c + \"-\" + a++;\n      };\n    }();\n\n    d.isFunction = function (c) {\n      return \"function\" === typeof c;\n    };\n\n    q.jQuery && (q.jQuery.fn.highcharts = function () {\n      var c = [].slice.call(arguments);\n      if (this[0]) return c[0] ? (new d[w(c[0]) ? c.shift() : \"Chart\"](this[0], c[0], c[1]), this) : l[G(this[0], \"data-highcharts-chart\")];\n    });\n    return {\n      attr: G,\n      defined: t,\n      erase: function (c, a) {\n        for (var b = c.length; b--;) if (c[b] === a) {\n          c.splice(b, 1);\n          break;\n        }\n      },\n      isArray: D,\n      isClass: y,\n      isDOMElement: E,\n      isNumber: C,\n      isObject: H,\n      isString: w,\n      objectEach: u,\n      pInt: k,\n      splat: function (c) {\n        return D(c) ? c : [c];\n      }\n    };\n  });\n  K(I, \"parts/Color.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.isNumber,\n        D = k.pInt,\n        H = d.merge;\n\n    d.Color = function (E) {\n      if (!(this instanceof d.Color)) return new d.Color(E);\n      this.init(E);\n    };\n\n    d.Color.prototype = {\n      parsers: [{\n        regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n        parse: function (d) {\n          return [D(d[1]), D(d[2]), D(d[3]), parseFloat(d[4], 10)];\n        }\n      }, {\n        regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function (d) {\n          return [D(d[1]), D(d[2]), D(d[3]), 1];\n        }\n      }],\n      names: {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      },\n      init: function (k) {\n        var y, C;\n        if ((this.input = k = this.names[k && k.toLowerCase ? k.toLowerCase() : \"\"] || k) && k.stops) this.stops = k.stops.map(function (u) {\n          return new d.Color(u[1]);\n        });else {\n          if (k && k.charAt && \"#\" === k.charAt()) {\n            var t = k.length;\n            k = parseInt(k.substr(1), 16);\n            7 === t ? y = [(k & 16711680) >> 16, (k & 65280) >> 8, k & 255, 1] : 4 === t && (y = [(k & 3840) >> 4 | (k & 3840) >> 8, (k & 240) >> 4 | k & 240, (k & 15) << 4 | k & 15, 1]);\n          }\n\n          if (!y) for (C = this.parsers.length; C-- && !y;) {\n            var E = this.parsers[C];\n            (t = E.regex.exec(k)) && (y = E.parse(t));\n          }\n        }\n        this.rgba = y || [];\n      },\n      get: function (d) {\n        var y = this.input,\n            k = this.rgba;\n\n        if (this.stops) {\n          var t = H(y);\n          t.stops = [].concat(t.stops);\n          this.stops.forEach(function (k, u) {\n            t.stops[u] = [t.stops[u][0], k.get(d)];\n          });\n        } else t = k && w(k[0]) ? \"rgb\" === d || !d && 1 === k[3] ? \"rgb(\" + k[0] + \",\" + k[1] + \",\" + k[2] + \")\" : \"a\" === d ? k[3] : \"rgba(\" + k.join(\",\") + \")\" : y;\n\n        return t;\n      },\n      brighten: function (d) {\n        var k,\n            C = this.rgba;\n        if (this.stops) this.stops.forEach(function (k) {\n          k.brighten(d);\n        });else if (w(d) && 0 !== d) for (k = 0; 3 > k; k++) C[k] += D(255 * d), 0 > C[k] && (C[k] = 0), 255 < C[k] && (C[k] = 255);\n        return this;\n      },\n      setOpacity: function (d) {\n        this.rgba[3] = d;\n        return this;\n      },\n      tweenTo: function (d, k) {\n        var y = this.rgba,\n            t = d.rgba;\n        t.length && y && y.length ? (d = 1 !== t[3] || 1 !== y[3], k = (d ? \"rgba(\" : \"rgb(\") + Math.round(t[0] + (y[0] - t[0]) * (1 - k)) + \",\" + Math.round(t[1] + (y[1] - t[1]) * (1 - k)) + \",\" + Math.round(t[2] + (y[2] - t[2]) * (1 - k)) + (d ? \",\" + (t[3] + (y[3] - t[3]) * (1 - k)) : \"\") + \")\") : k = d.input || \"none\";\n        return k;\n      }\n    };\n\n    d.color = function (k) {\n      return new d.Color(k);\n    };\n  });\n  K(I, \"parts/SvgRenderer.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.attr,\n        D = k.defined,\n        H = k.erase,\n        E = k.isArray,\n        y = k.isNumber,\n        C = k.isObject,\n        t = k.isString,\n        G = k.objectEach,\n        u = k.pInt,\n        l = k.splat,\n        p = d.addEvent,\n        q = d.animate,\n        c = d.charts,\n        a = d.color,\n        b = d.css,\n        f = d.createElement,\n        m = d.deg2rad,\n        h = d.destroyObjectProperties,\n        r = d.doc,\n        x = d.extend,\n        v = d.hasTouch,\n        n = d.isFirefox,\n        e = d.isMS,\n        g = d.isWebKit,\n        F = d.merge,\n        A = d.noop,\n        z = d.pick,\n        B = d.removeEvent,\n        J = d.stop,\n        M = d.svg,\n        T = d.SVG_NS,\n        N = d.symbolSizes,\n        R = d.win;\n\n    var L = d.SVGElement = function () {\n      return this;\n    };\n\n    x(L.prototype, {\n      opacity: 1,\n      SVG_NS: T,\n      textProps: \"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor\".split(\" \"),\n      init: function (a, b) {\n        this.element = \"span\" === b ? f(b) : r.createElementNS(this.SVG_NS, b);\n        this.renderer = a;\n        d.fireEvent(this, \"afterInit\");\n      },\n      animate: function (a, b, e) {\n        var g = d.animObject(z(b, this.renderer.globalAnimation, !0));\n        z(r.hidden, r.msHidden, r.webkitHidden, !1) && (g.duration = 0);\n        0 !== g.duration ? (e && (g.complete = e), q(this, a, g)) : (this.attr(a, void 0, e), G(a, function (a, b) {\n          g.step && g.step.call(this, a, {\n            prop: b,\n            pos: 1\n          });\n        }, this));\n        return this;\n      },\n      complexColor: function (a, b, e) {\n        var g = this.renderer,\n            c,\n            z,\n            B,\n            f,\n            h,\n            P,\n            n,\n            m,\n            A,\n            O,\n            J,\n            r = [],\n            v;\n        d.fireEvent(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          a.radialGradient ? z = \"radialGradient\" : a.linearGradient && (z = \"linearGradient\");\n          z && (B = a[z], h = g.gradients, n = a.stops, O = e.radialReference, E(B) && (a[z] = B = {\n            x1: B[0],\n            y1: B[1],\n            x2: B[2],\n            y2: B[3],\n            gradientUnits: \"userSpaceOnUse\"\n          }), \"radialGradient\" === z && O && !D(B.gradientUnits) && (f = B, B = F(B, g.getRadialAttr(O, f), {\n            gradientUnits: \"userSpaceOnUse\"\n          })), G(B, function (a, b) {\n            \"id\" !== b && r.push(b, a);\n          }), G(n, function (a) {\n            r.push(a);\n          }), r = r.join(\",\"), h[r] ? J = h[r].attr(\"id\") : (B.id = J = d.uniqueKey(), h[r] = P = g.createElement(z).attr(B).add(g.defs), P.radAttr = f, P.stops = [], n.forEach(function (a) {\n            0 === a[1].indexOf(\"rgba\") ? (c = d.color(a[1]), m = c.get(\"rgb\"), A = c.get(\"a\")) : (m = a[1], A = 1);\n            a = g.createElement(\"stop\").attr({\n              offset: a[0],\n              \"stop-color\": m,\n              \"stop-opacity\": A\n            }).add(P);\n            P.stops.push(a);\n          })), v = \"url(\" + g.url + \"#\" + J + \")\", e.setAttribute(b, v), e.gradient = r, a.toString = function () {\n            return v;\n          });\n        });\n      },\n      applyTextOutline: function (a) {\n        var b = this.element,\n            e;\n        -1 !== a.indexOf(\"contrast\") && (a = a.replace(/contrast/g, this.renderer.getContrast(b.style.fill)));\n        a = a.split(\" \");\n        var g = a[a.length - 1];\n\n        if ((e = a[0]) && \"none\" !== e && d.svg) {\n          this.fakeTS = !0;\n          a = [].slice.call(b.getElementsByTagName(\"tspan\"));\n          this.ySetter = this.xSetter;\n          e = e.replace(/(^[\\d\\.]+)(.*?)$/g, function (a, b, e) {\n            return 2 * b + e;\n          });\n          this.removeTextOutline(a);\n          var z = b.firstChild;\n          a.forEach(function (a, c) {\n            0 === c && (a.setAttribute(\"x\", b.getAttribute(\"x\")), c = b.getAttribute(\"y\"), a.setAttribute(\"y\", c || 0), null === c && b.setAttribute(\"y\", 0));\n            a = a.cloneNode(1);\n            w(a, {\n              \"class\": \"highcharts-text-outline\",\n              fill: g,\n              stroke: g,\n              \"stroke-width\": e,\n              \"stroke-linejoin\": \"round\"\n            });\n            b.insertBefore(a, z);\n          });\n        }\n      },\n      removeTextOutline: function (a) {\n        for (var b = a.length, e; b--;) e = a[b], \"highcharts-text-outline\" === e.getAttribute(\"class\") && H(a, this.element.removeChild(e));\n      },\n      symbolCustomAttribs: \"x y width height r start end innerR anchorX anchorY rounded\".split(\" \"),\n      attr: function (a, b, e, g) {\n        var c = this.element,\n            z,\n            B = this,\n            f,\n            h,\n            n = this.symbolCustomAttribs;\n\n        if (\"string\" === typeof a && void 0 !== b) {\n          var m = a;\n          a = {};\n          a[m] = b;\n        }\n\n        \"string\" === typeof a ? B = (this[a + \"Getter\"] || this._defaultGetter).call(this, a, c) : (G(a, function (b, e) {\n          f = !1;\n          g || J(this, e);\n          this.symbolName && -1 !== d.inArray(e, n) && (z || (this.symbolAttr(a), z = !0), f = !0);\n          !this.rotation || \"x\" !== e && \"y\" !== e || (this.doTransform = !0);\n          f || (h = this[e + \"Setter\"] || this._defaultSetter, h.call(this, b, e, c), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(e) && this.updateShadows(e, b, h));\n        }, this), this.afterSetters());\n        e && e.call(this);\n        return B;\n      },\n      afterSetters: function () {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      },\n      updateShadows: function (a, b, e) {\n        for (var g = this.shadows, c = g.length; c--;) e.call(g[c], \"height\" === a ? Math.max(b - (g[c].cutHeight || 0), 0) : \"d\" === a ? this.d : b, a, g[c]);\n      },\n      addClass: function (a, b) {\n        var e = this.attr(\"class\") || \"\";\n        b || (a = (a || \"\").split(/ /g).reduce(function (a, b) {\n          -1 === e.indexOf(b) && a.push(b);\n          return a;\n        }, e ? [e] : []).join(\" \"));\n        a !== e && this.attr(\"class\", a);\n        return this;\n      },\n      hasClass: function (a) {\n        return -1 !== (this.attr(\"class\") || \"\").split(\" \").indexOf(a);\n      },\n      removeClass: function (a) {\n        return this.attr(\"class\", (this.attr(\"class\") || \"\").replace(a, \"\"));\n      },\n      symbolAttr: function (a) {\n        var b = this;\n        \"x y r start end width height innerR anchorX anchorY clockwise\".split(\" \").forEach(function (e) {\n          b[e] = z(a[e], b[e]);\n        });\n        b.attr({\n          d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)\n        });\n      },\n      clip: function (a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      },\n      crisp: function (a, b) {\n        b = b || a.strokeWidth || 0;\n        var e = Math.round(b) % 2 / 2;\n        a.x = Math.floor(a.x || this.x || 0) + e;\n        a.y = Math.floor(a.y || this.y || 0) + e;\n        a.width = Math.floor((a.width || this.width || 0) - 2 * e);\n        a.height = Math.floor((a.height || this.height || 0) - 2 * e);\n        D(a.strokeWidth) && (a.strokeWidth = b);\n        return a;\n      },\n      css: function (a) {\n        var e = this.styles,\n            g = {},\n            c = this.element,\n            z = \"\",\n            B = !e,\n            f = [\"textOutline\", \"textOverflow\", \"width\"];\n        a && a.color && (a.fill = a.color);\n        e && G(a, function (a, b) {\n          a !== e[b] && (g[b] = a, B = !0);\n        });\n\n        if (B) {\n          e && (a = x(e, g));\n          if (a) if (null === a.width || \"auto\" === a.width) delete this.textWidth;else if (\"text\" === c.nodeName.toLowerCase() && a.width) var h = this.textWidth = u(a.width);\n          this.styles = a;\n          h && !M && this.renderer.forExport && delete a.width;\n\n          if (c.namespaceURI === this.SVG_NS) {\n            var n = function (a, b) {\n              return \"-\" + b.toLowerCase();\n            };\n\n            G(a, function (a, b) {\n              -1 === f.indexOf(b) && (z += b.replace(/([A-Z])/g, n) + \":\" + a + \";\");\n            });\n            z && w(c, \"style\", z);\n          } else b(c, a);\n\n          this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline));\n        }\n\n        return this;\n      },\n      getStyle: function (a) {\n        return R.getComputedStyle(this.element || this, \"\").getPropertyValue(a);\n      },\n      strokeWidth: function () {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        var a = this.getStyle(\"stroke-width\");\n        if (a.indexOf(\"px\") === a.length - 2) a = u(a);else {\n          var b = r.createElementNS(T, \"rect\");\n          w(b, {\n            width: a,\n            \"stroke-width\": 0\n          });\n          this.element.parentNode.appendChild(b);\n          a = b.getBBox().width;\n          b.parentNode.removeChild(b);\n        }\n        return a;\n      },\n      on: function (a, b) {\n        var e = this,\n            g = e.element;\n        v && \"click\" === a ? (g.ontouchstart = function (a) {\n          e.touchEventFired = Date.now();\n          a.preventDefault();\n          b.call(g, a);\n        }, g.onclick = function (a) {\n          (-1 === R.navigator.userAgent.indexOf(\"Android\") || 1100 < Date.now() - (e.touchEventFired || 0)) && b.call(g, a);\n        }) : g[\"on\" + a] = b;\n        return this;\n      },\n      setRadialReference: function (a) {\n        var b = this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = a;\n        b && b.radAttr && b.animate(this.renderer.getRadialAttr(a, b.radAttr));\n        return this;\n      },\n      translate: function (a, b) {\n        return this.attr({\n          translateX: a,\n          translateY: b\n        });\n      },\n      invert: function (a) {\n        this.inverted = a;\n        this.updateTransform();\n        return this;\n      },\n      updateTransform: function () {\n        var a = this.translateX || 0,\n            b = this.translateY || 0,\n            e = this.scaleX,\n            g = this.scaleY,\n            c = this.inverted,\n            B = this.rotation,\n            f = this.matrix,\n            h = this.element;\n        c && (a += this.width, b += this.height);\n        a = [\"translate(\" + a + \",\" + b + \")\"];\n        D(f) && a.push(\"matrix(\" + f.join(\",\") + \")\");\n        c ? a.push(\"rotate(90) scale(-1,1)\") : B && a.push(\"rotate(\" + B + \" \" + z(this.rotationOriginX, h.getAttribute(\"x\"), 0) + \" \" + z(this.rotationOriginY, h.getAttribute(\"y\") || 0) + \")\");\n        (D(e) || D(g)) && a.push(\"scale(\" + z(e, 1) + \" \" + z(g, 1) + \")\");\n        a.length && h.setAttribute(\"transform\", a.join(\" \"));\n      },\n      toFront: function () {\n        var a = this.element;\n        a.parentNode.appendChild(a);\n        return this;\n      },\n      align: function (a, b, e) {\n        var g,\n            c = {};\n        var B = this.renderer;\n        var f = B.alignedObjects;\n        var h, n;\n\n        if (a) {\n          if (this.alignOptions = a, this.alignByTranslate = b, !e || t(e)) this.alignTo = g = e || \"renderer\", H(f, this), f.push(this), e = null;\n        } else a = this.alignOptions, b = this.alignByTranslate, g = this.alignTo;\n\n        e = z(e, B[g], B);\n        g = a.align;\n        B = a.verticalAlign;\n        f = (e.x || 0) + (a.x || 0);\n        var m = (e.y || 0) + (a.y || 0);\n        \"right\" === g ? h = 1 : \"center\" === g && (h = 2);\n        h && (f += (e.width - (a.width || 0)) / h);\n        c[b ? \"translateX\" : \"x\"] = Math.round(f);\n        \"bottom\" === B ? n = 1 : \"middle\" === B && (n = 2);\n        n && (m += (e.height - (a.height || 0)) / n);\n        c[b ? \"translateY\" : \"y\"] = Math.round(m);\n        this[this.placed ? \"animate\" : \"attr\"](c);\n        this.placed = !0;\n        this.alignAttr = c;\n        return this;\n      },\n      getBBox: function (a, b) {\n        var e,\n            g = this.renderer,\n            c = this.element,\n            B = this.styles,\n            f = this.textStr,\n            h,\n            n = g.cache,\n            d = g.cacheKeys,\n            F = c.namespaceURI === this.SVG_NS;\n        b = z(b, this.rotation);\n        var P = b * m;\n        var A = g.styledMode ? c && L.prototype.getStyle.call(c, \"font-size\") : B && B.fontSize;\n\n        if (D(f)) {\n          var r = f.toString();\n          -1 === r.indexOf(\"<\") && (r = r.replace(/[0-9]/g, \"0\"));\n          r += [\"\", b || 0, A, this.textWidth, B && B.textOverflow].join();\n        }\n\n        r && !a && (e = n[r]);\n\n        if (!e) {\n          if (F || g.forExport) {\n            try {\n              (h = this.fakeTS && function (a) {\n                [].forEach.call(c.querySelectorAll(\".highcharts-text-outline\"), function (b) {\n                  b.style.display = a;\n                });\n              }) && h(\"none\"), e = c.getBBox ? x({}, c.getBBox()) : {\n                width: c.offsetWidth,\n                height: c.offsetHeight\n              }, h && h(\"\");\n            } catch (ea) {\n              \"\";\n            }\n\n            if (!e || 0 > e.width) e = {\n              width: 0,\n              height: 0\n            };\n          } else e = this.htmlGetBBox();\n\n          g.isSVG && (a = e.width, g = e.height, F && (e.height = g = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[B && B.fontSize + \",\" + Math.round(g)] || g), b && (e.width = Math.abs(g * Math.sin(P)) + Math.abs(a * Math.cos(P)), e.height = Math.abs(g * Math.cos(P)) + Math.abs(a * Math.sin(P))));\n\n          if (r && 0 < e.height) {\n            for (; 250 < d.length;) delete n[d.shift()];\n\n            n[r] || d.push(r);\n            n[r] = e;\n          }\n        }\n\n        return e;\n      },\n      show: function (a) {\n        return this.attr({\n          visibility: a ? \"inherit\" : \"visible\"\n        });\n      },\n      hide: function (a) {\n        a ? this.attr({\n          y: -9999\n        }) : this.attr({\n          visibility: \"hidden\"\n        });\n        return this;\n      },\n      fadeOut: function (a) {\n        var b = this;\n        b.animate({\n          opacity: 0\n        }, {\n          duration: a || 150,\n          complete: function () {\n            b.attr({\n              y: -9999\n            });\n          }\n        });\n      },\n      add: function (a) {\n        var b = this.renderer,\n            e = this.element;\n        a && (this.parentGroup = a);\n        this.parentInverted = a && a.inverted;\n        void 0 !== this.textStr && b.buildText(this);\n        this.added = !0;\n        if (!a || a.handleZ || this.zIndex) var g = this.zIndexSetter();\n        g || (a ? a.element : b.box).appendChild(e);\n        if (this.onAdd) this.onAdd();\n        return this;\n      },\n      safeRemoveChild: function (a) {\n        var b = a.parentNode;\n        b && b.removeChild(a);\n      },\n      destroy: function () {\n        var a = this,\n            b = a.element || {},\n            e = a.renderer,\n            g = e.isSVG && \"SPAN\" === b.nodeName && a.parentGroup,\n            c = b.ownerSVGElement,\n            z = a.clipPath;\n        b.onclick = b.onmouseout = b.onmouseover = b.onmousemove = b.point = null;\n        J(a);\n        z && c && ([].forEach.call(c.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (a) {\n          -1 < a.getAttribute(\"clip-path\").indexOf(z.element.id) && a.removeAttribute(\"clip-path\");\n        }), a.clipPath = z.destroy());\n\n        if (a.stops) {\n          for (c = 0; c < a.stops.length; c++) a.stops[c] = a.stops[c].destroy();\n\n          a.stops = null;\n        }\n\n        a.safeRemoveChild(b);\n\n        for (e.styledMode || a.destroyShadows(); g && g.div && 0 === g.div.childNodes.length;) b = g.parentGroup, a.safeRemoveChild(g.div), delete g.div, g = b;\n\n        a.alignTo && H(e.alignedObjects, a);\n        G(a, function (b, e) {\n          a[e] && a[e].parentGroup === a && a[e].destroy && a[e].destroy();\n          delete a[e];\n        });\n      },\n      shadow: function (a, b, e) {\n        var g = [],\n            c,\n            B = this.element;\n        if (!a) this.destroyShadows();else if (!this.shadows) {\n          var f = z(a.width, 3);\n          var h = (a.opacity || .15) / f;\n          var n = this.parentInverted ? \"(-1,-1)\" : \"(\" + z(a.offsetX, 1) + \", \" + z(a.offsetY, 1) + \")\";\n\n          for (c = 1; c <= f; c++) {\n            var m = B.cloneNode(0);\n            var d = 2 * f + 1 - 2 * c;\n            w(m, {\n              stroke: a.color || \"#000000\",\n              \"stroke-opacity\": h * c,\n              \"stroke-width\": d,\n              transform: \"translate\" + n,\n              fill: \"none\"\n            });\n            m.setAttribute(\"class\", (m.getAttribute(\"class\") || \"\") + \" highcharts-shadow\");\n            e && (w(m, \"height\", Math.max(w(m, \"height\") - d, 0)), m.cutHeight = d);\n            b ? b.element.appendChild(m) : B.parentNode && B.parentNode.insertBefore(m, B);\n            g.push(m);\n          }\n\n          this.shadows = g;\n        }\n        return this;\n      },\n      destroyShadows: function () {\n        (this.shadows || []).forEach(function (a) {\n          this.safeRemoveChild(a);\n        }, this);\n        this.shadows = void 0;\n      },\n      xGetter: function (a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));\n        return this._defaultGetter(a);\n      },\n      _defaultGetter: function (a) {\n        a = z(this[a + \"Value\"], this[a], this.element ? this.element.getAttribute(a) : null, 0);\n        /^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n        return a;\n      },\n      dSetter: function (a, b, e) {\n        a && a.join && (a = a.join(\" \"));\n        /(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");\n        this[b] !== a && (e.setAttribute(b, a), this[b] = a);\n      },\n      dashstyleSetter: function (a) {\n        var b,\n            e = this[\"stroke-width\"];\n        \"inherit\" === e && (e = 1);\n\n        if (a = a && a.toLowerCase()) {\n          a = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (b = a.length; b--;) a[b] = u(a[b]) * e;\n\n          a = a.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      },\n      alignSetter: function (a) {\n        var b = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        b[a] && (this.alignValue = a, this.element.setAttribute(\"text-anchor\", b[a]));\n      },\n      opacitySetter: function (a, b, e) {\n        this[b] = a;\n        e.setAttribute(b, a);\n      },\n      titleSetter: function (a) {\n        var b = this.element.getElementsByTagName(\"title\")[0];\n        b || (b = r.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(b));\n        b.firstChild && b.removeChild(b.firstChild);\n        b.appendChild(r.createTextNode(String(z(a, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\")));\n      },\n      textSetter: function (a) {\n        a !== this.textStr && (delete this.bBox, delete this.textPxLength, this.textStr = a, this.added && this.renderer.buildText(this));\n      },\n      setTextPath: function (a, b) {\n        var e = this.element,\n            g = {\n          textAnchor: \"text-anchor\"\n        },\n            c = !1,\n            z = this.textPathWrapper,\n            B = !z;\n        b = F(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, b);\n        var f = b.attributes;\n\n        if (a && b && b.enabled) {\n          this.options && this.options.padding && (f.dx = -this.options.padding);\n          z || (this.textPathWrapper = z = this.renderer.createElement(\"textPath\"), c = !0);\n          var h = z.element;\n          (b = a.element.getAttribute(\"id\")) || a.element.setAttribute(\"id\", b = d.uniqueKey());\n          if (B) for (a = e.getElementsByTagName(\"tspan\"); a.length;) a[0].setAttribute(\"y\", 0), h.appendChild(a[0]);\n          c && z.add({\n            element: this.text ? this.text.element : e\n          });\n          h.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", this.renderer.url + \"#\" + b);\n          D(f.dy) && (h.parentNode.setAttribute(\"dy\", f.dy), delete f.dy);\n          D(f.dx) && (h.parentNode.setAttribute(\"dx\", f.dx), delete f.dx);\n          G(f, function (a, b) {\n            h.setAttribute(g[b] || b, a);\n          });\n          e.removeAttribute(\"transform\");\n          this.removeTextOutline.call(z, [].slice.call(e.getElementsByTagName(\"tspan\")));\n          this.text && !this.renderer.styledMode && this.attr({\n            fill: \"none\",\n            \"stroke-width\": 0\n          });\n          this.applyTextOutline = this.updateTransform = A;\n        } else z && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(e, a));\n\n        return this;\n      },\n      destroyTextPath: function (a, b) {\n        var e;\n        b.element.setAttribute(\"id\", \"\");\n\n        for (e = this.textPathWrapper.element.childNodes; e.length;) a.firstChild.appendChild(e[0]);\n\n        a.firstChild.removeChild(this.textPathWrapper.element);\n        delete b.textPathWrapper;\n      },\n      fillSetter: function (a, b, e) {\n        \"string\" === typeof a ? e.setAttribute(b, a) : a && this.complexColor(a, b, e);\n      },\n      visibilitySetter: function (a, b, e) {\n        \"inherit\" === a ? e.removeAttribute(b) : this[b] !== a && e.setAttribute(b, a);\n        this[b] = a;\n      },\n      zIndexSetter: function (a, b) {\n        var e = this.renderer,\n            g = this.parentGroup,\n            c = (g || e).element || e.box,\n            z = this.element,\n            B = !1;\n        e = c === e.box;\n        var f = this.added;\n        var h;\n        D(a) ? (z.setAttribute(\"data-z-index\", a), a = +a, this[b] === a && (f = !1)) : D(this[b]) && z.removeAttribute(\"data-z-index\");\n        this[b] = a;\n\n        if (f) {\n          (a = this.zIndex) && g && (g.handleZ = !0);\n          b = c.childNodes;\n\n          for (h = b.length - 1; 0 <= h && !B; h--) {\n            g = b[h];\n            f = g.getAttribute(\"data-z-index\");\n            var n = !D(f);\n            if (g !== z) if (0 > a && n && !e && !h) c.insertBefore(z, b[h]), B = !0;else if (u(f) <= a || n && (!D(a) || 0 <= a)) c.insertBefore(z, b[h + 1] || null), B = !0;\n          }\n\n          B || (c.insertBefore(z, b[e ? 3 : 0] || null), B = !0);\n        }\n\n        return B;\n      },\n      _defaultSetter: function (a, b, e) {\n        e.setAttribute(b, a);\n      }\n    });\n    L.prototype.yGetter = L.prototype.xGetter;\n\n    L.prototype.translateXSetter = L.prototype.translateYSetter = L.prototype.rotationSetter = L.prototype.verticalAlignSetter = L.prototype.rotationOriginXSetter = L.prototype.rotationOriginYSetter = L.prototype.scaleXSetter = L.prototype.scaleYSetter = L.prototype.matrixSetter = function (a, b) {\n      this[b] = a;\n      this.doTransform = !0;\n    };\n\n    L.prototype[\"stroke-widthSetter\"] = L.prototype.strokeSetter = function (a, b, e) {\n      this[b] = a;\n      this.stroke && this[\"stroke-width\"] ? (L.prototype.fillSetter.call(this, this.stroke, \"stroke\", e), e.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === b && 0 === a && this.hasStroke ? (e.removeAttribute(\"stroke\"), this.hasStroke = !1) : this.renderer.styledMode && this[\"stroke-width\"] && (e.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0);\n    };\n\n    k = d.SVGRenderer = function () {\n      this.init.apply(this, arguments);\n    };\n\n    x(k.prototype, {\n      Element: L,\n      SVG_NS: T,\n      init: function (a, e, c, z, B, f, h) {\n        var m = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        });\n        h || m.css(this.getStyle(z));\n        z = m.element;\n        a.appendChild(z);\n        w(a, \"dir\", \"ltr\");\n        -1 === a.innerHTML.indexOf(\"xmlns\") && w(z, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = z;\n        this.boxWrapper = m;\n        this.alignedObjects = [];\n        this.url = (n || g) && r.getElementsByTagName(\"base\").length ? R.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";\n        this.createElement(\"desc\").add().element.appendChild(r.createTextNode(\"Created with Highcharts 7.2.0\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = f;\n        this.forExport = B;\n        this.styledMode = h;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(e, c, !1);\n        var d;\n        n && a.getBoundingClientRect && (e = function () {\n          b(a, {\n            left: 0,\n            top: 0\n          });\n          d = a.getBoundingClientRect();\n          b(a, {\n            left: Math.ceil(d.left) - d.left + \"px\",\n            top: Math.ceil(d.top) - d.top + \"px\"\n          });\n        }, e(), this.unSubPixelFix = p(R, \"resize\", e));\n      },\n      definition: function (a) {\n        function b(a, g) {\n          var c;\n          l(a).forEach(function (a) {\n            var z = e.createElement(a.tagName),\n                B = {};\n            G(a, function (a, b) {\n              \"tagName\" !== b && \"children\" !== b && \"textContent\" !== b && (B[b] = a);\n            });\n            z.attr(B);\n            z.add(g || e.defs);\n            a.textContent && z.element.appendChild(r.createTextNode(a.textContent));\n            b(a.children || [], z);\n            c = z;\n          });\n          return c;\n        }\n\n        var e = this;\n        return b(a);\n      },\n      getStyle: function (a) {\n        return this.style = x({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, a);\n      },\n      setStyle: function (a) {\n        this.boxWrapper.css(this.getStyle(a));\n      },\n      isHidden: function () {\n        return !this.boxWrapper.getBBox().width;\n      },\n      destroy: function () {\n        var a = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        h(this.gradients || {});\n        this.gradients = null;\n        a && (this.defs = a.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      },\n      createElement: function (a) {\n        var b = new this.Element();\n        b.init(this, a);\n        return b;\n      },\n      draw: A,\n      getRadialAttr: function (a, b) {\n        return {\n          cx: a[0] - a[2] / 2 + b.cx * a[2],\n          cy: a[1] - a[2] / 2 + b.cy * a[2],\n          r: b.r * a[2]\n        };\n      },\n      truncate: function (a, b, e, g, c, z, B) {\n        var f = this,\n            h = a.rotation,\n            n,\n            m = g ? 1 : 0,\n            d = (e || g).length,\n            F = d,\n            A = [],\n            J = function (a) {\n          b.firstChild && b.removeChild(b.firstChild);\n          a && b.appendChild(r.createTextNode(a));\n        },\n            v = function (z, h) {\n          h = h || z;\n          if (void 0 === A[h]) if (b.getSubStringLength) try {\n            A[h] = c + b.getSubStringLength(0, g ? h + 1 : h);\n          } catch (fa) {\n            \"\";\n          } else f.getSpanWidth && (J(B(e || g, z)), A[h] = c + f.getSpanWidth(a, b));\n          return A[h];\n        },\n            M;\n\n        a.rotation = 0;\n        var x = v(b.textContent.length);\n\n        if (M = c + x > z) {\n          for (; m <= d;) F = Math.ceil((m + d) / 2), g && (n = B(g, F)), x = v(F, n && n.length - 1), m === d ? m = d + 1 : x > z ? d = F - 1 : m = F;\n\n          0 === d ? J(\"\") : e && d === e.length - 1 || J(n || B(e || g, F));\n        }\n\n        g && g.splice(0, F);\n        a.actualWidth = x;\n        a.rotation = h;\n        return M;\n      },\n      escapes: {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        \"'\": \"&#39;\",\n        '\"': \"&quot;\"\n      },\n      buildText: function (a) {\n        var e = a.element,\n            g = this,\n            c = g.forExport,\n            B = z(a.textStr, \"\").toString(),\n            f = -1 !== B.indexOf(\"<\"),\n            h = e.childNodes,\n            n,\n            m = w(e, \"x\"),\n            d = a.styles,\n            F = a.textWidth,\n            A = d && d.lineHeight,\n            J = d && d.textOutline,\n            v = d && \"ellipsis\" === d.textOverflow,\n            x = d && \"nowrap\" === d.whiteSpace,\n            P = d && d.fontSize,\n            l,\n            L = h.length;\n        d = F && !a.added && this.box;\n\n        var q = function (a) {\n          var b;\n          g.styledMode || (b = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : P || g.style.fontSize || 12);\n          return A ? u(A) : g.fontMetrics(b, a.getAttribute(\"style\") ? a : e).h;\n        },\n            p = function (a, b) {\n          G(g.escapes, function (e, g) {\n            b && -1 !== b.indexOf(e) || (a = a.toString().replace(new RegExp(e, \"g\"), g));\n          });\n          return a;\n        },\n            N = function (a, b) {\n          var e = a.indexOf(\"<\");\n          a = a.substring(e, a.indexOf(\">\") - e);\n          e = a.indexOf(b + \"=\");\n          if (-1 !== e && (e = e + b.length + 1, b = a.charAt(e), '\"' === b || \"'\" === b)) return a = a.substring(e + 1), a.substring(0, a.indexOf(b));\n        },\n            R = /<br.*?>/g;\n\n        var k = [B, v, x, A, J, P, F].join();\n\n        if (k !== a.textCache) {\n          for (a.textCache = k; L--;) e.removeChild(h[L]);\n\n          f || J || v || F || -1 !== B.indexOf(\" \") && (!x || R.test(B)) ? (d && d.appendChild(e), f ? (B = g.styledMode ? B.replace(/<(b|strong)>/g, '<span class=\"highcharts-strong\">').replace(/<(i|em)>/g, '<span class=\"highcharts-emphasized\">') : B.replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">').replace(/<(i|em)>/g, '<span style=\"font-style:italic\">'), B = B.replace(/<a/g, \"<span\").replace(/<\\/(b|strong|i|em|a)>/g, \"</span>\").split(R)) : B = [B], B = B.filter(function (a) {\n            return \"\" !== a;\n          }), B.forEach(function (z, B) {\n            var f = 0,\n                h = 0;\n            z = z.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||<span\").replace(/<\\/span>/g, \"</span>|||\");\n            var d = z.split(\"|||\");\n            d.forEach(function (z) {\n              if (\"\" !== z || 1 === d.length) {\n                var A = {},\n                    J = r.createElementNS(g.SVG_NS, \"tspan\"),\n                    L,\n                    O;\n                (L = N(z, \"class\")) && w(J, \"class\", L);\n                if (L = N(z, \"style\")) L = L.replace(/(;| |^)color([ :])/, \"$1fill$2\"), w(J, \"style\", L);\n                (O = N(z, \"href\")) && !c && (w(J, \"onclick\", 'location.href=\"' + O + '\"'), w(J, \"class\", \"highcharts-anchor\"), g.styledMode || b(J, {\n                  cursor: \"pointer\"\n                }));\n                z = p(z.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, \"\") || \" \");\n\n                if (\" \" !== z) {\n                  J.appendChild(r.createTextNode(z));\n                  f ? A.dx = 0 : B && null !== m && (A.x = m);\n                  w(J, A);\n                  e.appendChild(J);\n                  !f && l && (!M && c && b(J, {\n                    display: \"block\"\n                  }), w(J, \"dy\", q(J)));\n\n                  if (F) {\n                    var u = z.replace(/([^\\^])-/g, \"$1- \").split(\" \");\n                    A = !x && (1 < d.length || B || 1 < u.length);\n                    O = 0;\n                    var ca = q(J);\n                    if (v) n = g.truncate(a, J, z, void 0, 0, Math.max(0, F - parseInt(P || 12, 10)), function (a, b) {\n                      return a.substring(0, b) + \"\\u2026\";\n                    });else if (A) for (; u.length;) u.length && !x && 0 < O && (J = r.createElementNS(T, \"tspan\"), w(J, {\n                      dy: ca,\n                      x: m\n                    }), L && w(J, \"style\", L), J.appendChild(r.createTextNode(u.join(\" \").replace(/- /g, \"-\"))), e.appendChild(J)), g.truncate(a, J, null, u, 0 === O ? h : 0, F, function (a, b) {\n                      return u.slice(0, b).join(\" \").replace(/- /g, \"-\");\n                    }), h = a.actualWidth, O++;\n                  }\n\n                  f++;\n                }\n              }\n            });\n            l = l || e.childNodes.length;\n          }), v && n && a.attr(\"title\", p(a.textStr, [\"&lt;\", \"&gt;\"])), d && d.removeChild(e), J && a.applyTextOutline && a.applyTextOutline(J)) : e.appendChild(r.createTextNode(p(B)));\n        }\n      },\n      getContrast: function (b) {\n        b = a(b).rgba;\n        b[0] *= 1;\n        b[1] *= 1.2;\n        b[2] *= .5;\n        return 459 < b[0] + b[1] + b[2] ? \"#000000\" : \"#FFFFFF\";\n      },\n      button: function (a, b, g, c, z, B, f, h, n, m) {\n        var d = this.label(a, b, g, n, null, null, m, null, \"button\"),\n            A = 0,\n            J = this.styledMode;\n        d.attr(F({\n          padding: 8,\n          r: 2\n        }, z));\n\n        if (!J) {\n          z = F({\n            fill: \"#f7f7f7\",\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1,\n            style: {\n              color: \"#333333\",\n              cursor: \"pointer\",\n              fontWeight: \"normal\"\n            }\n          }, z);\n          var r = z.style;\n          delete z.style;\n          B = F(z, {\n            fill: \"#e6e6e6\"\n          }, B);\n          var v = B.style;\n          delete B.style;\n          f = F(z, {\n            fill: \"#e6ebf5\",\n            style: {\n              color: \"#000000\",\n              fontWeight: \"bold\"\n            }\n          }, f);\n          var M = f.style;\n          delete f.style;\n          h = F(z, {\n            style: {\n              color: \"#cccccc\"\n            }\n          }, h);\n          var L = h.style;\n          delete h.style;\n        }\n\n        p(d.element, e ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== A && d.setState(1);\n        });\n        p(d.element, e ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== A && d.setState(A);\n        });\n\n        d.setState = function (a) {\n          1 !== a && (d.state = A = a);\n          d.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][a || 0]);\n          J || d.attr([z, B, f, h][a || 0]).css([r, v, M, L][a || 0]);\n        };\n\n        J || d.attr(z).css(x({\n          cursor: \"default\"\n        }, r));\n        return d.on(\"click\", function (a) {\n          3 !== A && c.call(d, a);\n        });\n      },\n      crispLine: function (a, b) {\n        a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - b % 2 / 2);\n        a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + b % 2 / 2);\n        return a;\n      },\n      path: function (a) {\n        var b = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        E(a) ? b.d = a : C(a) && x(b, a);\n        return this.createElement(\"path\").attr(b);\n      },\n      circle: function (a, b, e) {\n        a = C(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: b,\n          r: e\n        };\n        b = this.createElement(\"circle\");\n\n        b.xSetter = b.ySetter = function (a, b, e) {\n          e.setAttribute(\"c\" + b, a);\n        };\n\n        return b.attr(a);\n      },\n      arc: function (a, b, e, g, z, c) {\n        C(a) ? (g = a, b = g.y, e = g.r, a = g.x) : g = {\n          innerR: g,\n          start: z,\n          end: c\n        };\n        a = this.symbol(\"arc\", a, b, e, e, g);\n        a.r = e;\n        return a;\n      },\n      rect: function (a, b, e, g, z, c) {\n        z = C(a) ? a.r : z;\n        var B = this.createElement(\"rect\");\n        a = C(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: b,\n          width: Math.max(e, 0),\n          height: Math.max(g, 0)\n        };\n        this.styledMode || (void 0 !== c && (a.strokeWidth = c, a = B.crisp(a)), a.fill = \"none\");\n        z && (a.r = z);\n\n        B.rSetter = function (a, b, e) {\n          B.r = a;\n          w(e, {\n            rx: a,\n            ry: a\n          });\n        };\n\n        B.rGetter = function () {\n          return B.r;\n        };\n\n        return B.attr(a);\n      },\n      setSize: function (a, b, e) {\n        var g = this.alignedObjects,\n            c = g.length;\n        this.width = a;\n        this.height = b;\n\n        for (this.boxWrapper.animate({\n          width: a,\n          height: b\n        }, {\n          step: function () {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: z(e, !0) ? void 0 : 0\n        }); c--;) g[c].align();\n      },\n      g: function (a) {\n        var b = this.createElement(\"g\");\n        return a ? b.attr({\n          \"class\": \"highcharts-\" + a\n        }) : b;\n      },\n      image: function (a, b, e, g, c, z) {\n        var B = {\n          preserveAspectRatio: \"none\"\n        },\n            f = function (a, b) {\n          a.setAttributeNS ? a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", b) : a.setAttribute(\"hc-svg-href\", b);\n        },\n            h = function (b) {\n          f(n.element, a);\n          z.call(n, b);\n        };\n\n        1 < arguments.length && x(B, {\n          x: b,\n          y: e,\n          width: g,\n          height: c\n        });\n        var n = this.createElement(\"image\").attr(B);\n        z ? (f(n.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"), B = new R.Image(), p(B, \"load\", h), B.src = a, B.complete && h({})) : f(n.element, a);\n        return n;\n      },\n      symbol: function (a, e, g, B, h, n) {\n        var m = this,\n            d = /^url\\((.*?)\\)$/,\n            F = d.test(a),\n            A = !F && (this.symbols[a] ? a : \"circle\"),\n            J = A && this.symbols[A],\n            v = D(e) && J && J.call(this.symbols, Math.round(e), Math.round(g), B, h, n);\n\n        if (J) {\n          var M = this.path(v);\n          m.styledMode || M.attr(\"fill\", \"none\");\n          x(M, {\n            symbolName: A,\n            x: e,\n            y: g,\n            width: B,\n            height: h\n          });\n          n && x(M, n);\n        } else if (F) {\n          var L = a.match(d)[1];\n          M = this.image(L);\n          M.imgwidth = z(N[L] && N[L].width, n && n.width);\n          M.imgheight = z(N[L] && N[L].height, n && n.height);\n\n          var l = function () {\n            M.attr({\n              width: M.width,\n              height: M.height\n            });\n          };\n\n          [\"width\", \"height\"].forEach(function (a) {\n            M[a + \"Setter\"] = function (a, b) {\n              var e = {},\n                  g = this[\"img\" + b],\n                  z = \"width\" === b ? \"translateX\" : \"translateY\";\n              this[b] = a;\n              D(g) && (n && \"within\" === n.backgroundSize && this.width && this.height && (g = Math.round(g * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(b, g), this.alignByTranslate || (e[z] = ((this[b] || 0) - g) / 2, this.attr(e)));\n            };\n          });\n          D(e) && M.attr({\n            x: e,\n            y: g\n          });\n          M.isImg = !0;\n          D(M.imgwidth) && D(M.imgheight) ? l() : (M.attr({\n            width: 0,\n            height: 0\n          }), f(\"img\", {\n            onload: function () {\n              var a = c[m.chartIndex];\n              0 === this.width && (b(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), r.body.appendChild(this));\n              N[L] = {\n                width: this.width,\n                height: this.height\n              };\n              M.imgwidth = this.width;\n              M.imgheight = this.height;\n              M.element && l();\n              this.parentNode && this.parentNode.removeChild(this);\n              m.imgCount--;\n              if (!m.imgCount && a && a.onload) a.onload();\n            },\n            src: L\n          }), this.imgCount++);\n        }\n\n        return M;\n      },\n      symbols: {\n        circle: function (a, b, e, g) {\n          return this.arc(a + e / 2, b + g / 2, e / 2, g / 2, {\n            start: .5 * Math.PI,\n            end: 2.5 * Math.PI,\n            open: !1\n          });\n        },\n        square: function (a, b, e, g) {\n          return [\"M\", a, b, \"L\", a + e, b, a + e, b + g, a, b + g, \"Z\"];\n        },\n        triangle: function (a, b, e, g) {\n          return [\"M\", a + e / 2, b, \"L\", a + e, b + g, a, b + g, \"Z\"];\n        },\n        \"triangle-down\": function (a, b, e, g) {\n          return [\"M\", a, b, \"L\", a + e, b, a + e / 2, b + g, \"Z\"];\n        },\n        diamond: function (a, b, e, g) {\n          return [\"M\", a + e / 2, b, \"L\", a + e, b + g / 2, a + e / 2, b + g, a, b + g / 2, \"Z\"];\n        },\n        arc: function (a, b, e, g, c) {\n          var B = c.start,\n              f = c.r || e,\n              h = c.r || g || e,\n              n = c.end - .001;\n          e = c.innerR;\n          g = z(c.open, .001 > Math.abs(c.end - c.start - 2 * Math.PI));\n          var m = Math.cos(B),\n              d = Math.sin(B),\n              F = Math.cos(n);\n          n = Math.sin(n);\n          B = .001 > c.end - B - Math.PI ? 0 : 1;\n          c = [\"M\", a + f * m, b + h * d, \"A\", f, h, 0, B, z(c.clockwise, 1), a + f * F, b + h * n];\n          D(e) && c.push(g ? \"M\" : \"L\", a + e * F, b + e * n, \"A\", e, e, 0, B, 0, a + e * m, b + e * d);\n          c.push(g ? \"\" : \"Z\");\n          return c;\n        },\n        callout: function (a, b, e, g, c) {\n          var z = Math.min(c && c.r || 0, e, g),\n              B = z + 6,\n              f = c && c.anchorX;\n          c = c && c.anchorY;\n          var h = [\"M\", a + z, b, \"L\", a + e - z, b, \"C\", a + e, b, a + e, b, a + e, b + z, \"L\", a + e, b + g - z, \"C\", a + e, b + g, a + e, b + g, a + e - z, b + g, \"L\", a + z, b + g, \"C\", a, b + g, a, b + g, a, b + g - z, \"L\", a, b + z, \"C\", a, b, a, b, a + z, b];\n          f && f > e ? c > b + B && c < b + g - B ? h.splice(13, 3, \"L\", a + e, c - 6, a + e + 6, c, a + e, c + 6, a + e, b + g - z) : h.splice(13, 3, \"L\", a + e, g / 2, f, c, a + e, g / 2, a + e, b + g - z) : f && 0 > f ? c > b + B && c < b + g - B ? h.splice(33, 3, \"L\", a, c + 6, a - 6, c, a, c - 6, a, b + z) : h.splice(33, 3, \"L\", a, g / 2, f, c, a, g / 2, a, b + z) : c && c > g && f > a + B && f < a + e - B ? h.splice(23, 3, \"L\", f + 6, b + g, f, b + g + 6, f - 6, b + g, a + z, b + g) : c && 0 > c && f > a + B && f < a + e - B && h.splice(3, 3, \"L\", f - 6, b, f, b - 6, f + 6, b, e - z, b);\n          return h;\n        }\n      },\n      clipRect: function (a, b, e, g) {\n        var c = d.uniqueKey() + \"-\",\n            z = this.createElement(\"clipPath\").attr({\n          id: c\n        }).add(this.defs);\n        a = this.rect(a, b, e, g, 0).add(z);\n        a.id = c;\n        a.clipPath = z;\n        a.count = 0;\n        return a;\n      },\n      text: function (a, b, e, g) {\n        var c = {};\n        if (g && (this.allowHTML || !this.forExport)) return this.html(a, b, e);\n        c.x = Math.round(b || 0);\n        e && (c.y = Math.round(e));\n        D(a) && (c.text = a);\n        a = this.createElement(\"text\").attr(c);\n        g || (a.xSetter = function (a, b, e) {\n          var g = e.getElementsByTagName(\"tspan\"),\n              c = e.getAttribute(b),\n              z;\n\n          for (z = 0; z < g.length; z++) {\n            var B = g[z];\n            B.getAttribute(b) === c && B.setAttribute(b, a);\n          }\n\n          e.setAttribute(b, a);\n        });\n        return a;\n      },\n      fontMetrics: function (a, b) {\n        a = !this.styledMode && /px/.test(a) || !R.getComputedStyle ? a || b && b.style && b.style.fontSize || this.style && this.style.fontSize : b && L.prototype.getStyle.call(b, \"font-size\");\n        a = /px/.test(a) ? u(a) : 12;\n        b = 24 > a ? a + 3 : Math.round(1.2 * a);\n        return {\n          h: b,\n          b: Math.round(.8 * b),\n          f: a\n        };\n      },\n      rotCorr: function (a, b, e) {\n        var g = a;\n        b && e && (g = Math.max(g * Math.cos(b * m), 4));\n        return {\n          x: -a / 3 * Math.sin(b * m),\n          y: g\n        };\n      },\n      label: function (a, b, e, g, c, z, f, h, n) {\n        var m = this,\n            d = m.styledMode,\n            A = m.g(\"button\" !== n && \"label\"),\n            J = A.text = m.text(\"\", 0, 0, f).attr({\n          zIndex: 1\n        }),\n            r,\n            v,\n            M = 0,\n            l = 3,\n            q = 0,\n            p,\n            u,\n            T,\n            P,\n            N,\n            O = {},\n            R,\n            k,\n            t = /^url\\((.*?)\\)$/.test(g),\n            ca = d || t,\n            C = function () {\n          return d ? r.strokeWidth() % 2 / 2 : (R ? parseInt(R, 10) : 0) % 2 / 2;\n        };\n\n        n && A.addClass(\"highcharts-\" + n);\n\n        var E = function () {\n          var a = J.element.style,\n              b = {};\n          v = (void 0 === p || void 0 === u || N) && D(J.textStr) && J.getBBox();\n          A.width = (p || v.width || 0) + 2 * l + q;\n          A.height = (u || v.height || 0) + 2 * l;\n          k = l + Math.min(m.fontMetrics(a && a.fontSize, J).b, v ? v.height : Infinity);\n          ca && (r || (A.box = r = m.symbols[g] || t ? m.symbol(g) : m.rect(), r.addClass((\"button\" === n ? \"\" : \"highcharts-label-box\") + (n ? \" highcharts-\" + n + \"-box\" : \"\")), r.add(A), a = C(), b.x = a, b.y = (h ? -k : 0) + a), b.width = Math.round(A.width), b.height = Math.round(A.height), r.attr(x(b, O)), O = {});\n        };\n\n        var G = function () {\n          var a = q + l;\n          var b = h ? 0 : k;\n          D(p) && v && (\"center\" === N || \"right\" === N) && (a += {\n            center: .5,\n            right: 1\n          }[N] * (p - v.width));\n          if (a !== J.x || b !== J.y) J.attr(\"x\", a), J.hasBoxWidthChanged && (v = J.getBBox(!0), E()), void 0 !== b && J.attr(\"y\", b);\n          J.x = a;\n          J.y = b;\n        };\n\n        var w = function (a, b) {\n          r ? r.attr(a, b) : O[a] = b;\n        };\n\n        A.onAdd = function () {\n          J.add(A);\n          A.attr({\n            text: a || 0 === a ? a : \"\",\n            x: b,\n            y: e\n          });\n          r && D(c) && A.attr({\n            anchorX: c,\n            anchorY: z\n          });\n        };\n\n        A.widthSetter = function (a) {\n          p = y(a) ? a : null;\n        };\n\n        A.heightSetter = function (a) {\n          u = a;\n        };\n\n        A[\"text-alignSetter\"] = function (a) {\n          N = a;\n        };\n\n        A.paddingSetter = function (a) {\n          D(a) && a !== l && (l = A.padding = a, G());\n        };\n\n        A.paddingLeftSetter = function (a) {\n          D(a) && a !== q && (q = a, G());\n        };\n\n        A.alignSetter = function (a) {\n          a = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[a];\n          a !== M && (M = a, v && A.attr({\n            x: T\n          }));\n        };\n\n        A.textSetter = function (a) {\n          void 0 !== a && J.attr({\n            text: a\n          });\n          E();\n          G();\n        };\n\n        A[\"stroke-widthSetter\"] = function (a, b) {\n          a && (ca = !0);\n          R = this[\"stroke-width\"] = a;\n          w(b, a);\n        };\n\n        d ? A.rSetter = function (a, b) {\n          w(b, a);\n        } : A.strokeSetter = A.fillSetter = A.rSetter = function (a, b) {\n          \"r\" !== b && (\"fill\" === b && a && (ca = !0), A[b] = a);\n          w(b, a);\n        };\n\n        A.anchorXSetter = function (a, b) {\n          c = A.anchorX = a;\n          w(b, Math.round(a) - C() - T);\n        };\n\n        A.anchorYSetter = function (a, b) {\n          z = A.anchorY = a;\n          w(b, a - P);\n        };\n\n        A.xSetter = function (a) {\n          A.x = a;\n          M && (a -= M * ((p || v.width) + 2 * l), A[\"forceAnimate:x\"] = !0);\n          T = Math.round(a);\n          A.attr(\"translateX\", T);\n        };\n\n        A.ySetter = function (a) {\n          P = A.y = Math.round(a);\n          A.attr(\"translateY\", P);\n        };\n\n        var H = A.css;\n        f = {\n          css: function (a) {\n            if (a) {\n              var b = {};\n              a = F(a);\n              A.textProps.forEach(function (e) {\n                void 0 !== a[e] && (b[e] = a[e], delete a[e]);\n              });\n              J.css(b);\n              \"width\" in b && E();\n              \"fontSize\" in b && (E(), G());\n            }\n\n            return H.call(A, a);\n          },\n          getBBox: function () {\n            return {\n              width: v.width + 2 * l,\n              height: v.height + 2 * l,\n              x: v.x - l,\n              y: v.y - l\n            };\n          },\n          destroy: function () {\n            B(A.element, \"mouseenter\");\n            B(A.element, \"mouseleave\");\n            J && (J = J.destroy());\n            r && (r = r.destroy());\n            L.prototype.destroy.call(A);\n            A = m = E = G = w = null;\n          }\n        };\n        d || (f.shadow = function (a) {\n          a && (E(), r && r.shadow(a));\n          return A;\n        });\n        return x(A, f);\n      }\n    });\n    d.Renderer = k;\n  });\n  K(I, \"parts/Html.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.attr,\n        D = k.defined,\n        H = k.pInt,\n        E = d.createElement,\n        y = d.css,\n        C = d.extend,\n        t = d.isFirefox,\n        G = d.isMS,\n        u = d.isWebKit,\n        l = d.pick,\n        p = d.SVGElement;\n    k = d.SVGRenderer;\n    var q = d.win;\n    C(p.prototype, {\n      htmlCss: function (c) {\n        var a = \"SPAN\" === this.element.tagName && c && \"width\" in c,\n            b = l(a && c.width, void 0);\n\n        if (a) {\n          delete c.width;\n          this.textWidth = b;\n          var f = !0;\n        }\n\n        c && \"ellipsis\" === c.textOverflow && (c.whiteSpace = \"nowrap\", c.overflow = \"hidden\");\n        this.styles = C(this.styles, c);\n        y(this.element, c);\n        f && this.htmlUpdateTransform();\n        return this;\n      },\n      htmlGetBBox: function () {\n        var c = this.element;\n        return {\n          x: c.offsetLeft,\n          y: c.offsetTop,\n          width: c.offsetWidth,\n          height: c.offsetHeight\n        };\n      },\n      htmlUpdateTransform: function () {\n        if (this.added) {\n          var c = this.renderer,\n              a = this.element,\n              b = this.translateX || 0,\n              f = this.translateY || 0,\n              m = this.x || 0,\n              h = this.y || 0,\n              d = this.textAlign || \"left\",\n              x = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[d],\n              v = this.styles,\n              n = v && v.whiteSpace;\n          y(a, {\n            marginLeft: b,\n            marginTop: f\n          });\n          !c.styledMode && this.shadows && this.shadows.forEach(function (a) {\n            y(a, {\n              marginLeft: b + 1,\n              marginTop: f + 1\n            });\n          });\n          this.inverted && [].forEach.call(a.childNodes, function (b) {\n            c.invertChild(b, a);\n          });\n\n          if (\"SPAN\" === a.tagName) {\n            v = this.rotation;\n            var e = this.textWidth && H(this.textWidth),\n                g = [v, d, a.innerHTML, this.textWidth, this.textAlign].join(),\n                F;\n            (F = e !== this.oldTextWidth) && !(F = e > this.oldTextWidth) && ((F = this.textPxLength) || (y(a, {\n              width: \"\",\n              whiteSpace: n || \"nowrap\"\n            }), F = a.offsetWidth), F = F > e);\n            F && (/[ \\-]/.test(a.textContent || a.innerText) || \"ellipsis\" === a.style.textOverflow) ? (y(a, {\n              width: e + \"px\",\n              display: \"block\",\n              whiteSpace: n || \"normal\"\n            }), this.oldTextWidth = e, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;\n            g !== this.cTT && (n = c.fontMetrics(a.style.fontSize, a).b, !D(v) || v === (this.oldRotation || 0) && d === this.oldAlign || this.setSpanRotation(v, x, n), this.getSpanCorrection(!D(v) && this.textPxLength || a.offsetWidth, n, x, v, d));\n            y(a, {\n              left: m + (this.xCorr || 0) + \"px\",\n              top: h + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = g;\n            this.oldRotation = v;\n            this.oldAlign = d;\n          }\n        } else this.alignOnAdd = !0;\n      },\n      setSpanRotation: function (c, a, b) {\n        var f = {},\n            m = this.renderer.getTransformKey();\n        f[m] = f.transform = \"rotate(\" + c + \"deg)\";\n        f[m + (t ? \"Origin\" : \"-origin\")] = f.transformOrigin = 100 * a + \"% \" + b + \"px\";\n        y(this.element, f);\n      },\n      getSpanCorrection: function (c, a, b) {\n        this.xCorr = -c * b;\n        this.yCorr = -a;\n      }\n    });\n    C(k.prototype, {\n      getTransformKey: function () {\n        return G && !/Edge/.test(q.navigator.userAgent) ? \"-ms-transform\" : u ? \"-webkit-transform\" : t ? \"MozTransform\" : q.opera ? \"-o-transform\" : \"\";\n      },\n      html: function (c, a, b) {\n        var f = this.createElement(\"span\"),\n            m = f.element,\n            h = f.renderer,\n            d = h.isSVG,\n            x = function (a, b) {\n          [\"opacity\", \"visibility\"].forEach(function (e) {\n            a[e + \"Setter\"] = function (g, c, f) {\n              var z = a.div ? a.div.style : b;\n              p.prototype[e + \"Setter\"].call(this, g, c, f);\n              z && (z[c] = g);\n            };\n          });\n          a.addedSetters = !0;\n        };\n\n        f.textSetter = function (a) {\n          a !== m.innerHTML && (delete this.bBox, delete this.oldTextWidth);\n          this.textStr = a;\n          m.innerHTML = l(a, \"\");\n          f.doTransform = !0;\n        };\n\n        d && x(f, f.element.style);\n\n        f.xSetter = f.ySetter = f.alignSetter = f.rotationSetter = function (a, b) {\n          \"align\" === b && (b = \"textAlign\");\n          f[b] = a;\n          f.doTransform = !0;\n        };\n\n        f.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        f.attr({\n          text: c,\n          x: Math.round(a),\n          y: Math.round(b)\n        }).css({\n          position: \"absolute\"\n        });\n        h.styledMode || f.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        m.style.whiteSpace = \"nowrap\";\n        f.css = f.htmlCss;\n        d && (f.add = function (a) {\n          var b = h.box.parentNode,\n              e = [];\n\n          if (this.parentGroup = a) {\n            var g = a.div;\n\n            if (!g) {\n              for (; a;) e.push(a), a = a.parentGroup;\n\n              e.reverse().forEach(function (a) {\n                function c(b, e) {\n                  a[e] = b;\n                  \"translateX\" === e ? B.left = b + \"px\" : B.top = b + \"px\";\n                  a.doTransform = !0;\n                }\n\n                var z = w(a.element, \"class\");\n                g = a.div = a.div || E(\"div\", z ? {\n                  className: z\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  pointerEvents: a.styles && a.styles.pointerEvents\n                }, g || b);\n                var B = g.style;\n                C(a, {\n                  classSetter: function (a) {\n                    return function (b) {\n                      this.element.setAttribute(\"class\", b);\n                      a.className = b;\n                    };\n                  }(g),\n                  on: function () {\n                    e[0].div && f.on.apply({\n                      element: e[0].div\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: c,\n                  translateYSetter: c\n                });\n                a.addedSetters || x(a);\n              });\n            }\n          } else g = b;\n\n          g.appendChild(m);\n          f.added = !0;\n          f.alignOnAdd && f.htmlUpdateTransform();\n          return f;\n        });\n        return f;\n      }\n    });\n  });\n  K(I, \"parts/Time.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.isObject,\n        H = k.objectEach,\n        E = k.splat,\n        y = d.extend,\n        C = d.merge,\n        t = d.pick,\n        G = d.timeUnits,\n        u = d.win;\n\n    d.Time = function (d) {\n      this.update(d, !1);\n    };\n\n    d.Time.prototype = {\n      defaultOptions: {},\n      update: function (d) {\n        var l = t(d && d.useUTC, !0),\n            q = this;\n        this.options = d = C(!0, this.options || {}, d);\n        this.Date = d.Date || u.Date || Date;\n        this.timezoneOffset = (this.useUTC = l) && d.timezoneOffset;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        (this.variableTimezone = !(l && !d.getTimezoneOffset && !d.timezone)) || this.timezoneOffset ? (this.get = function (c, a) {\n          var b = a.getTime(),\n              f = b - q.getTimezoneOffset(a);\n          a.setTime(f);\n          c = a[\"getUTC\" + c]();\n          a.setTime(b);\n          return c;\n        }, this.set = function (c, a, b) {\n          if (\"Milliseconds\" === c || \"Seconds\" === c || \"Minutes\" === c && 0 === a.getTimezoneOffset() % 60) a[\"set\" + c](b);else {\n            var f = q.getTimezoneOffset(a);\n            f = a.getTime() - f;\n            a.setTime(f);\n            a[\"setUTC\" + c](b);\n            c = q.getTimezoneOffset(a);\n            f = a.getTime() + c;\n            a.setTime(f);\n          }\n        }) : l ? (this.get = function (c, a) {\n          return a[\"getUTC\" + c]();\n        }, this.set = function (c, a, b) {\n          return a[\"setUTC\" + c](b);\n        }) : (this.get = function (c, a) {\n          return a[\"get\" + c]();\n        }, this.set = function (c, a, b) {\n          return a[\"set\" + c](b);\n        });\n      },\n      makeTime: function (l, p, q, c, a, b) {\n        if (this.useUTC) {\n          var f = this.Date.UTC.apply(0, arguments);\n          var m = this.getTimezoneOffset(f);\n          f += m;\n          var h = this.getTimezoneOffset(f);\n          m !== h ? f += h - m : m - 36E5 !== this.getTimezoneOffset(f - 36E5) || d.isSafari || (f -= 36E5);\n        } else f = new this.Date(l, p, t(q, 1), t(c, 0), t(a, 0), t(b, 0)).getTime();\n\n        return f;\n      },\n      timezoneOffsetFunction: function () {\n        var l = this,\n            p = this.options,\n            q = u.moment;\n        if (!this.useUTC) return function (c) {\n          return 6E4 * new Date(c).getTimezoneOffset();\n        };\n\n        if (p.timezone) {\n          if (q) return function (c) {\n            return 6E4 * -q.tz(c, p.timezone).utcOffset();\n          };\n          d.error(25);\n        }\n\n        return this.useUTC && p.getTimezoneOffset ? function (c) {\n          return 6E4 * p.getTimezoneOffset(c);\n        } : function () {\n          return 6E4 * (l.timezoneOffset || 0);\n        };\n      },\n      dateFormat: function (l, p, q) {\n        if (!w(p) || isNaN(p)) return d.defaultOptions.lang.invalidDate || \"\";\n        l = d.pick(l, \"%Y-%m-%d %H:%M:%S\");\n        var c = this,\n            a = new this.Date(p),\n            b = this.get(\"Hours\", a),\n            f = this.get(\"Day\", a),\n            m = this.get(\"Date\", a),\n            h = this.get(\"Month\", a),\n            r = this.get(\"FullYear\", a),\n            x = d.defaultOptions.lang,\n            v = x.weekdays,\n            n = x.shortWeekdays,\n            e = d.pad;\n        a = d.extend({\n          a: n ? n[f] : v[f].substr(0, 3),\n          A: v[f],\n          d: e(m),\n          e: e(m, 2, \" \"),\n          w: f,\n          b: x.shortMonths[h],\n          B: x.months[h],\n          m: e(h + 1),\n          o: h + 1,\n          y: r.toString().substr(2, 2),\n          Y: r,\n          H: e(b),\n          k: b,\n          I: e(b % 12 || 12),\n          l: b % 12 || 12,\n          M: e(c.get(\"Minutes\", a)),\n          p: 12 > b ? \"AM\" : \"PM\",\n          P: 12 > b ? \"am\" : \"pm\",\n          S: e(a.getSeconds()),\n          L: e(Math.floor(p % 1E3), 3)\n        }, d.dateFormats);\n        H(a, function (a, b) {\n          for (; -1 !== l.indexOf(\"%\" + b);) l = l.replace(\"%\" + b, \"function\" === typeof a ? a.call(c, p) : a);\n        });\n        return q ? l.substr(0, 1).toUpperCase() + l.substr(1) : l;\n      },\n      resolveDTLFormat: function (d) {\n        return D(d, !0) ? d : (d = E(d), {\n          main: d[0],\n          from: d[1],\n          to: d[2]\n        });\n      },\n      getTimeTicks: function (d, p, q, c) {\n        var a = this,\n            b = [],\n            f = {};\n        var m = new a.Date(p);\n        var h = d.unitRange,\n            r = d.count || 1,\n            x;\n        c = t(c, 1);\n\n        if (w(p)) {\n          a.set(\"Milliseconds\", m, h >= G.second ? 0 : r * Math.floor(a.get(\"Milliseconds\", m) / r));\n          h >= G.second && a.set(\"Seconds\", m, h >= G.minute ? 0 : r * Math.floor(a.get(\"Seconds\", m) / r));\n          h >= G.minute && a.set(\"Minutes\", m, h >= G.hour ? 0 : r * Math.floor(a.get(\"Minutes\", m) / r));\n          h >= G.hour && a.set(\"Hours\", m, h >= G.day ? 0 : r * Math.floor(a.get(\"Hours\", m) / r));\n          h >= G.day && a.set(\"Date\", m, h >= G.month ? 1 : Math.max(1, r * Math.floor(a.get(\"Date\", m) / r)));\n\n          if (h >= G.month) {\n            a.set(\"Month\", m, h >= G.year ? 0 : r * Math.floor(a.get(\"Month\", m) / r));\n            var v = a.get(\"FullYear\", m);\n          }\n\n          h >= G.year && a.set(\"FullYear\", m, v - v % r);\n          h === G.week && (v = a.get(\"Day\", m), a.set(\"Date\", m, a.get(\"Date\", m) - v + c + (v < c ? -7 : 0)));\n          v = a.get(\"FullYear\", m);\n          c = a.get(\"Month\", m);\n          var n = a.get(\"Date\", m),\n              e = a.get(\"Hours\", m);\n          p = m.getTime();\n          a.variableTimezone && (x = q - p > 4 * G.month || a.getTimezoneOffset(p) !== a.getTimezoneOffset(q));\n          p = m.getTime();\n\n          for (m = 1; p < q;) b.push(p), p = h === G.year ? a.makeTime(v + m * r, 0) : h === G.month ? a.makeTime(v, c + m * r) : !x || h !== G.day && h !== G.week ? x && h === G.hour && 1 < r ? a.makeTime(v, c, n, e + m * r) : p + h * r : a.makeTime(v, c, n + m * r * (h === G.day ? 1 : 7)), m++;\n\n          b.push(p);\n          h <= G.hour && 1E4 > b.length && b.forEach(function (b) {\n            0 === b % 18E5 && \"000000000\" === a.dateFormat(\"%H%M%S%L\", b) && (f[b] = \"day\");\n          });\n        }\n\n        b.info = y(d, {\n          higherRanks: f,\n          totalRange: h * r\n        });\n        return b;\n      }\n    };\n  });\n  K(I, \"parts/Options.js\", [I[\"parts/Globals.js\"]], function (d) {\n    var k = d.color,\n        w = d.merge;\n    d.defaultOptions = {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: d.Time.prototype.defaultOptions,\n      chart: {\n        styledMode: !1,\n        borderRadius: 0,\n        colorCount: 10,\n        defaultSeriesType: \"line\",\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        width: null,\n        height: null,\n        borderColor: \"#335cad\",\n        backgroundColor: \"#ffffff\",\n        plotBorderColor: \"#cccccc\"\n      },\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      caption: {\n        margin: 15,\n        text: \"\",\n        align: \"left\",\n        verticalAlign: \"bottom\"\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        layout: \"horizontal\",\n        labelFormatter: function () {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: d.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        padding: 8,\n        snap: d.isTouchDevice ? 25 : 10,\n        headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>',\n        backgroundColor: k(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        shadow: !0,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          pointerEvents: \"none\",\n          whiteSpace: \"nowrap\"\n        }\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n\n    d.setOptions = function (k) {\n      d.defaultOptions = w(!0, d.defaultOptions, k);\n      d.time.update(w(d.defaultOptions.global, d.defaultOptions.time), !1);\n      return d.defaultOptions;\n    };\n\n    d.getOptions = function () {\n      return d.defaultOptions;\n    };\n\n    d.defaultPlotOptions = d.defaultOptions.plotOptions;\n    d.time = new d.Time(w(d.defaultOptions.global, d.defaultOptions.time));\n\n    d.dateFormat = function (k, w, E) {\n      return d.time.dateFormat(k, w, E);\n    };\n\n    \"\";\n  });\n  K(I, \"parts/Tick.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.isNumber,\n        H = d.correctFloat,\n        E = d.destroyObjectProperties,\n        y = d.fireEvent,\n        C = d.merge,\n        t = d.pick,\n        G = d.deg2rad;\n\n    d.Tick = function (d, l, p, q, c) {\n      this.axis = d;\n      this.pos = l;\n      this.type = p || \"\";\n      this.isNewLabel = this.isNew = !0;\n      this.parameters = c || {};\n      this.tickmarkOffset = this.parameters.tickmarkOffset;\n      this.options = this.parameters.options;\n      p || q || this.addLabel();\n    };\n\n    d.Tick.prototype = {\n      addLabel: function () {\n        var u = this,\n            l = u.axis,\n            p = l.options,\n            q = l.chart,\n            c = l.categories,\n            a = l.names,\n            b = u.pos,\n            f = t(u.options && u.options.labels, p.labels),\n            m = l.tickPositions,\n            h = b === m[0],\n            r = b === m[m.length - 1];\n        c = this.parameters.category || (c ? t(c[b], a[b], b) : b);\n        var x = u.label;\n        m = m.info;\n        var v, n;\n\n        if (l.isDatetimeAxis && m) {\n          var e = q.time.resolveDTLFormat(p.dateTimeLabelFormats[!p.grid && m.higherRanks[b] || m.unitName]);\n          var g = e.main;\n        }\n\n        u.isFirst = h;\n        u.isLast = r;\n        u.formatCtx = {\n          axis: l,\n          chart: q,\n          isFirst: h,\n          isLast: r,\n          dateTimeLabelFormat: g,\n          tickPositionInfo: m,\n          value: l.isLog ? H(l.lin2log(c)) : c,\n          pos: b\n        };\n        p = l.labelFormatter.call(u.formatCtx, this.formatCtx);\n        if (n = e && e.list) u.shortenLabel = function () {\n          for (v = 0; v < n.length; v++) if (x.attr({\n            text: l.labelFormatter.call(d.extend(u.formatCtx, {\n              dateTimeLabelFormat: n[v]\n            }))\n          }), x.getBBox().width < l.getSlotWidth(u) - 2 * t(f.padding, 5)) return;\n\n          x.attr({\n            text: \"\"\n          });\n        };\n        if (w(x)) x && x.textStr !== p && (!x.textWidth || f.style && f.style.width || x.styles.width || x.css({\n          width: null\n        }), x.attr({\n          text: p\n        }), x.textPxLength = x.getBBox().width);else {\n          if (u.label = x = w(p) && f.enabled ? q.renderer.text(p, 0, 0, f.useHTML).add(l.labelGroup) : null) q.styledMode || x.css(C(f.style)), x.textPxLength = x.getBBox().width;\n          u.rotation = 0;\n        }\n      },\n      getLabelSize: function () {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      },\n      handleOverflow: function (d) {\n        var l = this.axis,\n            p = l.options.labels,\n            q = d.x,\n            c = l.chart.chartWidth,\n            a = l.chart.spacing,\n            b = t(l.labelLeft, Math.min(l.pos, a[3]));\n        a = t(l.labelRight, Math.max(l.isRadial ? 0 : l.pos + l.len, c - a[1]));\n        var f = this.label,\n            m = this.rotation,\n            h = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[l.labelAlign || f.attr(\"align\")],\n            r = f.getBBox().width,\n            x = l.getSlotWidth(this),\n            v = x,\n            n = 1,\n            e,\n            g = {};\n        if (m || \"justify\" !== t(p.overflow, \"justify\")) 0 > m && q - h * r < b ? e = Math.round(q / Math.cos(m * G) - b) : 0 < m && q + h * r > a && (e = Math.round((c - q) / Math.cos(m * G)));else if (c = q + (1 - h) * r, q - h * r < b ? v = d.x + v * (1 - h) - b : c > a && (v = a - d.x + v * h, n = -1), v = Math.min(x, v), v < x && \"center\" === l.labelAlign && (d.x += n * (x - v - h * (x - Math.min(r, v)))), r > v || l.autoRotation && (f.styles || {}).width) e = v;\n        e && (this.shortenLabel ? this.shortenLabel() : (g.width = Math.floor(e), (p.style || {}).textOverflow || (g.textOverflow = \"ellipsis\"), f.css(g)));\n      },\n      getPosition: function (u, l, p, q) {\n        var c = this.axis,\n            a = c.chart,\n            b = q && a.oldChartHeight || a.chartHeight;\n        u = {\n          x: u ? d.correctFloat(c.translate(l + p, null, null, q) + c.transB) : c.left + c.offset + (c.opposite ? (q && a.oldChartWidth || a.chartWidth) - c.right - c.left : 0),\n          y: u ? b - c.bottom + c.offset - (c.opposite ? c.height : 0) : d.correctFloat(b - c.translate(l + p, null, null, q) - c.transB)\n        };\n        u.y = Math.max(Math.min(u.y, 1E5), -1E5);\n        y(this, \"afterGetPosition\", {\n          pos: u\n        });\n        return u;\n      },\n      getLabelPosition: function (d, l, p, q, c, a, b, f) {\n        var m = this.axis,\n            h = m.transA,\n            r = m.isLinked && m.linkedParent ? m.linkedParent.reversed : m.reversed,\n            x = m.staggerLines,\n            v = m.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            n = c.y,\n            e = q || m.reserveSpaceDefault ? 0 : -m.labelOffset * (\"center\" === m.labelAlign ? .5 : 1),\n            g = {};\n        w(n) || (n = 0 === m.side ? p.rotation ? -8 : -p.getBBox().height : 2 === m.side ? v.y + 8 : Math.cos(p.rotation * G) * (v.y - p.getBBox(!1, 0).height / 2));\n        d = d + c.x + e + v.x - (a && q ? a * h * (r ? -1 : 1) : 0);\n        l = l + n - (a && !q ? a * h * (r ? 1 : -1) : 0);\n        x && (p = b / (f || 1) % x, m.opposite && (p = x - p - 1), l += m.labelOffset / x * p);\n        g.x = d;\n        g.y = Math.round(l);\n        y(this, \"afterGetLabelPosition\", {\n          pos: g,\n          tickmarkOffset: a,\n          index: b\n        });\n        return g;\n      },\n      getMarkPath: function (d, l, p, q, c, a) {\n        return a.crispLine([\"M\", d, l, \"L\", d + (c ? 0 : -p), l + (c ? p : 0)], q);\n      },\n      renderGridLine: function (d, l, p) {\n        var q = this.axis,\n            c = q.options,\n            a = this.gridLine,\n            b = {},\n            f = this.pos,\n            m = this.type,\n            h = t(this.tickmarkOffset, q.tickmarkOffset),\n            r = q.chart.renderer,\n            x = m ? m + \"Grid\" : \"grid\",\n            v = c[x + \"LineWidth\"],\n            n = c[x + \"LineColor\"];\n        c = c[x + \"LineDashStyle\"];\n        a || (q.chart.styledMode || (b.stroke = n, b[\"stroke-width\"] = v, c && (b.dashstyle = c)), m || (b.zIndex = 1), d && (l = 0), this.gridLine = a = r.path().attr(b).addClass(\"highcharts-\" + (m ? m + \"-\" : \"\") + \"grid-line\").add(q.gridGroup));\n        if (a && (p = q.getPlotLinePath({\n          value: f + h,\n          lineWidth: a.strokeWidth() * p,\n          force: \"pass\",\n          old: d\n        }))) a[d || this.isNew ? \"attr\" : \"animate\"]({\n          d: p,\n          opacity: l\n        });\n      },\n      renderMark: function (d, l, p) {\n        var q = this.axis,\n            c = q.options,\n            a = q.chart.renderer,\n            b = this.type,\n            f = b ? b + \"Tick\" : \"tick\",\n            m = q.tickSize(f),\n            h = this.mark,\n            r = !h,\n            x = d.x;\n        d = d.y;\n        var v = t(c[f + \"Width\"], !b && q.isXAxis ? 1 : 0);\n        c = c[f + \"Color\"];\n        m && (q.opposite && (m[0] = -m[0]), r && (this.mark = h = a.path().addClass(\"highcharts-\" + (b ? b + \"-\" : \"\") + \"tick\").add(q.axisGroup), q.chart.styledMode || h.attr({\n          stroke: c,\n          \"stroke-width\": v\n        })), h[r ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(x, d, m[0], h.strokeWidth() * p, q.horiz, a),\n          opacity: l\n        }));\n      },\n      renderLabel: function (d, l, p, q) {\n        var c = this.axis,\n            a = c.horiz,\n            b = c.options,\n            f = this.label,\n            m = b.labels,\n            h = m.step;\n        c = t(this.tickmarkOffset, c.tickmarkOffset);\n        var r = !0,\n            x = d.x;\n        d = d.y;\n        f && D(x) && (f.xy = d = this.getLabelPosition(x, d, f, a, m, c, q, h), this.isFirst && !this.isLast && !t(b.showFirstLabel, 1) || this.isLast && !this.isFirst && !t(b.showLastLabel, 1) ? r = !1 : !a || m.step || m.rotation || l || 0 === p || this.handleOverflow(d), h && q % h && (r = !1), r && D(d.y) ? (d.opacity = p, f[this.isNewLabel ? \"attr\" : \"animate\"](d), this.isNewLabel = !1) : (f.attr(\"y\", -9999), this.isNewLabel = !0));\n      },\n      render: function (u, l, p) {\n        var q = this.axis,\n            c = q.horiz,\n            a = this.pos,\n            b = t(this.tickmarkOffset, q.tickmarkOffset);\n        a = this.getPosition(c, a, b, l);\n        b = a.x;\n        var f = a.y;\n        q = c && b === q.pos + q.len || !c && f === q.pos ? -1 : 1;\n        p = t(p, 1);\n        this.isActive = !0;\n        this.renderGridLine(l, p, q);\n        this.renderMark(a, p, q);\n        this.renderLabel(a, l, p, u);\n        this.isNew = !1;\n        d.fireEvent(this, \"afterRender\");\n      },\n      destroy: function () {\n        E(this, this.axis);\n      }\n    };\n  });\n  K(I, \"parts/Axis.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.isArray,\n        H = k.isNumber,\n        E = k.isString,\n        y = k.objectEach,\n        C = k.splat,\n        t = d.addEvent,\n        G = d.animObject,\n        u = d.arrayMax,\n        l = d.arrayMin,\n        p = d.color,\n        q = d.correctFloat,\n        c = d.defaultOptions,\n        a = d.deg2rad,\n        b = d.destroyObjectProperties,\n        f = d.extend,\n        m = d.fireEvent,\n        h = d.format,\n        r = d.getMagnitude,\n        x = d.merge,\n        v = d.normalizeTickInterval,\n        n = d.pick,\n        e = d.removeEvent,\n        g = d.seriesTypes,\n        F = d.syncTimeout,\n        A = d.Tick;\n\n    k = function () {\n      this.init.apply(this, arguments);\n    };\n\n    d.extend(k.prototype, {\n      defaultOptions: {\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e. %b\"\n          },\n          week: {\n            main: \"%e. %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        labels: {\n          enabled: !0,\n          indentation: 10,\n          x: 0,\n          style: {\n            color: \"#666666\",\n            cursor: \"default\",\n            fontSize: \"11px\"\n          }\n        },\n        maxPadding: .01,\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minPadding: .01,\n        showEmpty: !0,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          style: {\n            color: \"#666666\"\n          }\n        },\n        type: \"linear\",\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#ccd6eb\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        tickColor: \"#ccd6eb\"\n      },\n      defaultYAxisOptions: {\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: -8\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          allowOverlap: !1,\n          enabled: !1,\n          crop: !0,\n          overflow: \"justify\",\n          formatter: function () {\n            return d.numberFormat(this.total, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      },\n      defaultLeftAxisOptions: {\n        labels: {\n          x: -15\n        },\n        title: {\n          rotation: 270\n        }\n      },\n      defaultRightAxisOptions: {\n        labels: {\n          x: 15\n        },\n        title: {\n          rotation: 90\n        }\n      },\n      defaultBottomAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      },\n      defaultTopAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      },\n      init: function (a, b) {\n        var e = b.isX,\n            g = this;\n        g.chart = a;\n        g.horiz = a.inverted && !g.isZAxis ? !e : e;\n        g.isXAxis = e;\n        g.coll = g.coll || (e ? \"xAxis\" : \"yAxis\");\n        m(this, \"init\", {\n          userOptions: b\n        });\n        g.opposite = b.opposite;\n        g.side = b.side || (g.horiz ? g.opposite ? 0 : 2 : g.opposite ? 1 : 3);\n        g.setOptions(b);\n        var c = this.options,\n            z = c.type;\n        g.labelFormatter = c.labels.formatter || g.defaultLabelFormatter;\n        g.userOptions = b;\n        g.minPixelPadding = 0;\n        g.reversed = c.reversed;\n        g.visible = !1 !== c.visible;\n        g.zoomEnabled = !1 !== c.zoomEnabled;\n        g.hasNames = \"category\" === z || !0 === c.categories;\n        g.categories = c.categories || g.hasNames;\n        g.names || (g.names = [], g.names.keys = {});\n        g.plotLinesAndBandsGroups = {};\n        g.isLog = \"logarithmic\" === z;\n        g.isDatetimeAxis = \"datetime\" === z;\n        g.positiveValuesOnly = g.isLog && !g.allowNegativeLog;\n        g.isLinked = w(c.linkedTo);\n        g.ticks = {};\n        g.labelEdge = [];\n        g.minorTicks = {};\n        g.plotLinesAndBands = [];\n        g.alternateBands = {};\n        g.len = 0;\n        g.minRange = g.userMinRange = c.minRange || c.maxZoom;\n        g.range = c.range;\n        g.offset = c.offset || 0;\n        g.stacks = {};\n        g.oldStacks = {};\n        g.stacksTouched = 0;\n        g.max = null;\n        g.min = null;\n        g.crosshair = n(c.crosshair, C(a.options.tooltip.crosshairs)[e ? 0 : 1], !1);\n        b = g.options.events;\n        -1 === a.axes.indexOf(g) && (e ? a.axes.splice(a.xAxis.length, 0, g) : a.axes.push(g), a[g.coll].push(g));\n        g.series = g.series || [];\n        a.inverted && !g.isZAxis && e && void 0 === g.reversed && (g.reversed = !0);\n        y(b, function (a, b) {\n          d.isFunction(a) && t(g, b, a);\n        });\n        g.lin2log = c.linearToLogConverter || g.lin2log;\n        g.isLog && (g.val2lin = g.log2lin, g.lin2val = g.lin2log);\n        m(this, \"afterInit\");\n      },\n      setOptions: function (a) {\n        this.options = x(this.defaultOptions, \"yAxis\" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], x(c[this.coll], a));\n        m(this, \"afterSetOptions\", {\n          userOptions: a\n        });\n      },\n      defaultLabelFormatter: function () {\n        var a = this.axis,\n            b = this.value,\n            e = a.chart.time,\n            g = a.categories,\n            f = this.dateTimeLabelFormat,\n            n = c.lang,\n            m = n.numericSymbols;\n        n = n.numericSymbolMagnitude || 1E3;\n        var A = m && m.length,\n            F = a.options.labels.format;\n        a = a.isLog ? Math.abs(b) : a.tickInterval;\n        if (F) var r = h(F, this, e);else if (g) r = b;else if (f) r = e.dateFormat(f, b);else if (A && 1E3 <= a) for (; A-- && void 0 === r;) e = Math.pow(n, A + 1), a >= e && 0 === 10 * b % e && null !== m[A] && 0 !== b && (r = d.numberFormat(b / e, -1) + m[A]);\n        void 0 === r && (r = 1E4 <= Math.abs(b) ? d.numberFormat(b, -1) : d.numberFormat(b, -1, void 0, \"\"));\n        return r;\n      },\n      getSeriesExtremes: function () {\n        var a = this,\n            b = a.chart,\n            e;\n        m(this, \"getSeriesExtremes\", null, function () {\n          a.hasVisibleSeries = !1;\n          a.dataMin = a.dataMax = a.threshold = null;\n          a.softThreshold = !a.isXAxis;\n          a.buildStacks && a.buildStacks();\n          a.series.forEach(function (g) {\n            if (g.visible || !b.options.chart.ignoreHiddenSeries) {\n              var c = g.options,\n                  z = c.threshold;\n              a.hasVisibleSeries = !0;\n              a.positiveValuesOnly && 0 >= z && (z = null);\n\n              if (a.isXAxis) {\n                if (c = g.xData, c.length) {\n                  e = g.getXExtremes(c);\n                  var B = e.min;\n                  var f = e.max;\n                  H(B) || B instanceof Date || (c = c.filter(H), e = g.getXExtremes(c), B = e.min, f = e.max);\n                  c.length && (a.dataMin = Math.min(n(a.dataMin, B), B), a.dataMax = Math.max(n(a.dataMax, f), f));\n                }\n              } else if (g.getExtremes(), f = g.dataMax, B = g.dataMin, w(B) && w(f) && (a.dataMin = Math.min(n(a.dataMin, B), B), a.dataMax = Math.max(n(a.dataMax, f), f)), w(z) && (a.threshold = z), !c.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;\n            }\n          });\n        });\n        m(this, \"afterGetSeriesExtremes\");\n      },\n      translate: function (a, b, e, g, c, f) {\n        var B = this.linkedParent || this,\n            z = 1,\n            h = 0,\n            d = g ? B.oldTransA : B.transA;\n        g = g ? B.oldMin : B.min;\n        var n = B.minPixelPadding;\n        c = (B.isOrdinal || B.isBroken || B.isLog && c) && B.lin2val;\n        d || (d = B.transA);\n        e && (z *= -1, h = B.len);\n        B.reversed && (z *= -1, h -= z * (B.sector || B.len));\n        b ? (a = (a * z + h - n) / d + g, c && (a = B.lin2val(a))) : (c && (a = B.val2lin(a)), a = H(g) ? z * (a - g) * d + h + z * n + (H(f) ? d * f : 0) : void 0);\n        return a;\n      },\n      toPixels: function (a, b) {\n        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);\n      },\n      toValue: function (a, b) {\n        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);\n      },\n      getPlotLinePath: function (a) {\n        var b = this,\n            e = b.chart,\n            g = b.left,\n            c = b.top,\n            z = a.old,\n            f = a.value,\n            h = a.translatedValue,\n            d = a.lineWidth,\n            A = a.force,\n            F,\n            r,\n            v,\n            x,\n            l = z && e.oldChartHeight || e.chartHeight,\n            q = z && e.oldChartWidth || e.chartWidth,\n            p,\n            u = b.transB,\n            k = function (a, b, e) {\n          if (\"pass\" !== A && a < b || a > e) A ? a = Math.min(Math.max(b, a), e) : p = !0;\n          return a;\n        };\n\n        a = {\n          value: f,\n          lineWidth: d,\n          old: z,\n          force: A,\n          acrossPanes: a.acrossPanes,\n          translatedValue: h\n        };\n        m(this, \"getPlotLinePath\", a, function (a) {\n          h = n(h, b.translate(f, null, null, z));\n          h = Math.min(Math.max(-1E5, h), 1E5);\n          F = v = Math.round(h + u);\n          r = x = Math.round(l - h - u);\n          H(h) ? b.horiz ? (r = c, x = l - b.bottom, F = v = k(F, g, g + b.width)) : (F = g, v = q - b.right, r = x = k(r, c, c + b.height)) : (p = !0, A = !1);\n          a.path = p && !A ? null : e.renderer.crispLine([\"M\", F, r, \"L\", v, x], d || 1);\n        });\n        return a.path;\n      },\n      getLinearTickPositions: function (a, b, e) {\n        var g = q(Math.floor(b / a) * a);\n        e = q(Math.ceil(e / a) * a);\n        var c = [],\n            B;\n        q(g + a) === g && (B = 20);\n        if (this.single) return [b];\n\n        for (b = g; b <= e;) {\n          c.push(b);\n          b = q(b + a, B);\n          if (b === z) break;\n          var z = b;\n        }\n\n        return c;\n      },\n      getMinorTickInterval: function () {\n        var a = this.options;\n        return !0 === a.minorTicks ? n(a.minorTickInterval, \"auto\") : !1 === a.minorTicks ? null : a.minorTickInterval;\n      },\n      getMinorTickPositions: function () {\n        var a = this,\n            b = a.options,\n            e = a.tickPositions,\n            g = a.minorTickInterval,\n            c = [],\n            f = a.pointRangePadding || 0,\n            h = a.min - f;\n        f = a.max + f;\n        var d = f - h;\n        if (d && d / g < a.len / 3) if (a.isLog) this.paddedTicks.forEach(function (b, e, B) {\n          e && c.push.apply(c, a.getLogTickPositions(g, B[e - 1], B[e], !0));\n        });else if (a.isDatetimeAxis && \"auto\" === this.getMinorTickInterval()) c = c.concat(a.getTimeTicks(a.normalizeTimeTickInterval(g), h, f, b.startOfWeek));else for (b = h + (e[0] - h) % g; b <= f && b !== c[0]; b += g) c.push(b);\n        0 !== c.length && a.trimTicks(c);\n        return c;\n      },\n      adjustForMinRange: function () {\n        var a = this.options,\n            b = this.min,\n            e = this.max,\n            g,\n            c,\n            f,\n            h,\n            d;\n        this.isXAxis && void 0 === this.minRange && !this.isLog && (w(a.min) || w(a.max) ? this.minRange = null : (this.series.forEach(function (a) {\n          h = a.xData;\n\n          for (c = d = a.xIncrement ? 1 : h.length - 1; 0 < c; c--) if (f = h[c] - h[c - 1], void 0 === g || f < g) g = f;\n        }), this.minRange = Math.min(5 * g, this.dataMax - this.dataMin)));\n\n        if (e - b < this.minRange) {\n          var m = this.dataMax - this.dataMin >= this.minRange;\n          var A = this.minRange;\n          var F = (A - e + b) / 2;\n          F = [b - F, n(a.min, b - F)];\n          m && (F[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin);\n          b = u(F);\n          e = [b + A, n(a.max, b + A)];\n          m && (e[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax);\n          e = l(e);\n          e - b < A && (F[0] = e - A, F[1] = n(a.min, e - A), b = u(F));\n        }\n\n        this.min = b;\n        this.max = e;\n      },\n      getClosest: function () {\n        var a;\n        this.categories ? a = 1 : this.series.forEach(function (b) {\n          var e = b.closestPointRange,\n              g = b.visible || !b.chart.options.chart.ignoreHiddenSeries;\n          !b.noSharedTooltip && w(e) && g && (a = w(a) ? Math.min(a, e) : e);\n        });\n        return a;\n      },\n      nameToX: function (a) {\n        var b = D(this.categories),\n            e = b ? this.categories : this.names,\n            g = a.options.x;\n        a.series.requireSorting = !1;\n        w(g) || (g = !1 === this.options.uniqueNames ? a.series.autoIncrement() : b ? e.indexOf(a.name) : n(e.keys[a.name], -1));\n\n        if (-1 === g) {\n          if (!b) var c = e.length;\n        } else c = g;\n\n        void 0 !== c && (this.names[c] = a.name, this.names.keys[a.name] = c);\n        return c;\n      },\n      updateNames: function () {\n        var a = this,\n            b = this.names;\n        0 < b.length && (Object.keys(b.keys).forEach(function (a) {\n          delete b.keys[a];\n        }), b.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (b) {\n          b.xIncrement = null;\n          if (!b.points || b.isDirtyData) a.max = Math.max(a.max, b.xData.length - 1), b.processData(), b.generatePoints();\n          b.data.forEach(function (e, g) {\n            if (e && e.options && void 0 !== e.name) {\n              var c = a.nameToX(e);\n              void 0 !== c && c !== e.x && (e.x = c, b.xData[g] = c);\n            }\n          });\n        }));\n      },\n      setAxisTranslation: function (a) {\n        var b = this,\n            e = b.max - b.min,\n            c = b.axisPointRange || 0,\n            f = 0,\n            h = 0,\n            z = b.linkedParent,\n            d = !!b.categories,\n            A = b.transA,\n            F = b.isXAxis;\n\n        if (F || d || c) {\n          var r = b.getClosest();\n          z ? (f = z.minPointOffset, h = z.pointRangePadding) : b.series.forEach(function (a) {\n            var e = d ? 1 : F ? n(a.options.pointRange, r, 0) : b.axisPointRange || 0,\n                z = a.options.pointPlacement;\n            c = Math.max(c, e);\n            if (!b.single || d) a = g.xrange && a instanceof g.xrange ? !F : F, f = Math.max(f, a && E(z) ? 0 : e / 2), h = Math.max(h, a && \"on\" === z ? 0 : e);\n          });\n          z = b.ordinalSlope && r ? b.ordinalSlope / r : 1;\n          b.minPointOffset = f *= z;\n          b.pointRangePadding = h *= z;\n          b.pointRange = Math.min(c, e);\n          F && (b.closestPointRange = r);\n        }\n\n        a && (b.oldTransA = A);\n        b.translationSlope = b.transA = A = b.staticScale || b.len / (e + h || 1);\n        b.transB = b.horiz ? b.left : b.bottom;\n        b.minPixelPadding = A * f;\n        m(this, \"afterSetAxisTranslation\");\n      },\n      minFromRange: function () {\n        return this.max - this.range;\n      },\n      setTickInterval: function (a) {\n        var b = this,\n            e = b.chart,\n            g = b.options,\n            c = b.isLog,\n            f = b.isDatetimeAxis,\n            h = b.isXAxis,\n            z = b.isLinked,\n            A = g.maxPadding,\n            F = g.minPadding,\n            x = g.tickInterval,\n            l = g.tickPixelInterval,\n            p = b.categories,\n            u = H(b.threshold) ? b.threshold : null,\n            k = b.softThreshold;\n        f || p || z || this.getTickAmount();\n        var t = n(b.userMin, g.min);\n        var y = n(b.userMax, g.max);\n\n        if (z) {\n          b.linkedParent = e[b.coll][g.linkedTo];\n          var E = b.linkedParent.getExtremes();\n          b.min = n(E.min, E.dataMin);\n          b.max = n(E.max, E.dataMax);\n          g.type !== b.linkedParent.options.type && d.error(11, 1, e);\n        } else {\n          if (!k && w(u)) if (b.dataMin >= u) E = u, F = 0;else if (b.dataMax <= u) {\n            var C = u;\n            A = 0;\n          }\n          b.min = n(t, E, b.dataMin);\n          b.max = n(y, C, b.dataMax);\n        }\n\n        c && (b.positiveValuesOnly && !a && 0 >= Math.min(b.min, n(b.dataMin, b.min)) && d.error(10, 1, e), b.min = q(b.log2lin(b.min), 15), b.max = q(b.log2lin(b.max), 15));\n        b.range && w(b.max) && (b.userMin = b.min = t = Math.max(b.dataMin, b.minFromRange()), b.userMax = y = b.max, b.range = null);\n        m(b, \"foundExtremes\");\n        b.beforePadding && b.beforePadding();\n        b.adjustForMinRange();\n        !(p || b.axisPointRange || b.usePercentage || z) && w(b.min) && w(b.max) && (e = b.max - b.min) && (!w(t) && F && (b.min -= e * F), !w(y) && A && (b.max += e * A));\n        H(g.softMin) && !H(b.userMin) && g.softMin < b.min && (b.min = t = g.softMin);\n        H(g.softMax) && !H(b.userMax) && g.softMax > b.max && (b.max = y = g.softMax);\n        H(g.floor) && (b.min = Math.min(Math.max(b.min, g.floor), Number.MAX_VALUE));\n        H(g.ceiling) && (b.max = Math.max(Math.min(b.max, g.ceiling), n(b.userMax, -Number.MAX_VALUE)));\n        k && w(b.dataMin) && (u = u || 0, !w(t) && b.min < u && b.dataMin >= u ? b.min = b.options.minRange ? Math.min(u, b.max - b.minRange) : u : !w(y) && b.max > u && b.dataMax <= u && (b.max = b.options.minRange ? Math.max(u, b.min + b.minRange) : u));\n        b.tickInterval = b.min === b.max || void 0 === b.min || void 0 === b.max ? 1 : z && !x && l === b.linkedParent.options.tickPixelInterval ? x = b.linkedParent.tickInterval : n(x, this.tickAmount ? (b.max - b.min) / Math.max(this.tickAmount - 1, 1) : void 0, p ? 1 : (b.max - b.min) * l / Math.max(b.len, l));\n        h && !a && b.series.forEach(function (a) {\n          a.processData(b.min !== b.oldMin || b.max !== b.oldMax);\n        });\n        b.setAxisTranslation(!0);\n        b.beforeSetTickPositions && b.beforeSetTickPositions();\n        b.postProcessTickInterval && (b.tickInterval = b.postProcessTickInterval(b.tickInterval));\n        b.pointRange && !x && (b.tickInterval = Math.max(b.pointRange, b.tickInterval));\n        a = n(g.minTickInterval, b.isDatetimeAxis && b.closestPointRange);\n        !x && b.tickInterval < a && (b.tickInterval = a);\n        f || c || x || (b.tickInterval = v(b.tickInterval, null, r(b.tickInterval), n(g.allowDecimals, !(.5 < b.tickInterval && 5 > b.tickInterval && 1E3 < b.max && 9999 > b.max)), !!this.tickAmount));\n        this.tickAmount || (b.tickInterval = b.unsquish());\n        this.setTickPositions();\n      },\n      setTickPositions: function () {\n        var a = this.options,\n            b = a.tickPositions;\n        var e = this.getMinorTickInterval();\n        var g = a.tickPositioner,\n            c = a.startOnTick,\n            f = a.endOnTick;\n        this.tickmarkOffset = this.categories && \"between\" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === e && this.tickInterval ? this.tickInterval / 5 : e;\n        this.single = this.min === this.max && w(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);\n        this.tickPositions = e = b && b.slice();\n        !e && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (e = [this.min, this.max], d.error(19, !1, this.chart)) : e = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), e.length > this.len && (e = [e[0], e.pop()], e[0] === e[1] && (e.length = 1)), this.tickPositions = e, g && (g = g.apply(this, [this.min, this.max]))) && (this.tickPositions = e = g);\n        this.paddedTicks = e.slice(0);\n        this.trimTicks(e, c, f);\n        this.isLinked || (this.single && 2 > e.length && !this.categories && (this.min -= .5, this.max += .5), b || g || this.adjustTickAmount());\n        m(this, \"afterSetTickPositions\");\n      },\n      trimTicks: function (a, b, e) {\n        var g = a[0],\n            c = a[a.length - 1],\n            f = this.minPointOffset || 0;\n        m(this, \"trimTicks\");\n\n        if (!this.isLinked) {\n          if (b && -Infinity !== g) this.min = g;else for (; this.min - f > a[0];) a.shift();\n          if (e) this.max = c;else for (; this.max + f < a[a.length - 1];) a.pop();\n          0 === a.length && w(g) && !this.options.tickPositions && a.push((c + g) / 2);\n        }\n      },\n      alignToOthers: function () {\n        var a = {},\n            b,\n            e = this.options;\n        !1 === this.chart.options.chart.alignTicks || !1 === e.alignTicks || !1 === e.startOnTick || !1 === e.endOnTick || this.isLog || this.chart[this.coll].forEach(function (e) {\n          var g = e.options;\n          g = [e.horiz ? g.left : g.top, g.width, g.height, g.pane].join();\n          e.series.length && (a[g] ? b = !0 : a[g] = 1);\n        });\n        return b;\n      },\n      getTickAmount: function () {\n        var a = this.options,\n            b = a.tickAmount,\n            e = a.tickPixelInterval;\n        !w(a.tickInterval) && this.len < e && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);\n        !b && this.alignToOthers() && (b = Math.ceil(this.len / e) + 1);\n        4 > b && (this.finalTickAmt = b, b = 5);\n        this.tickAmount = b;\n      },\n      adjustTickAmount: function () {\n        var a = this.options,\n            b = this.tickInterval,\n            e = this.tickPositions,\n            g = this.tickAmount,\n            c = this.finalTickAmt,\n            f = e && e.length,\n            h = n(this.threshold, this.softThreshold ? 0 : null),\n            d;\n\n        if (this.hasData()) {\n          if (f < g) {\n            for (d = this.min; e.length < g;) e.length % 2 || d === h ? e.push(q(e[e.length - 1] + b)) : e.unshift(q(e[0] - b));\n\n            this.transA *= (f - 1) / (g - 1);\n            this.min = a.startOnTick ? e[0] : Math.min(this.min, e[0]);\n            this.max = a.endOnTick ? e[e.length - 1] : Math.max(this.max, e[e.length - 1]);\n          } else f > g && (this.tickInterval *= 2, this.setTickPositions());\n\n          if (w(c)) {\n            for (b = a = e.length; b--;) (3 === c && 1 === b % 2 || 2 >= c && 0 < b && b < a - 1) && e.splice(b, 1);\n\n            this.finalTickAmt = void 0;\n          }\n        }\n      },\n      setScale: function () {\n        var a = this.series.some(function (a) {\n          return a.isDirtyData || a.isDirty || a.xAxis && a.xAxis.isDirty;\n        }),\n            b;\n        this.oldMin = this.min;\n        this.oldMax = this.max;\n        this.oldAxisLength = this.len;\n        this.setAxisSize();\n        (b = this.len !== this.oldAxisLength) || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();\n        m(this, \"afterSetScale\");\n      },\n      setExtremes: function (a, b, e, g, c) {\n        var h = this,\n            d = h.chart;\n        e = n(e, !0);\n        h.series.forEach(function (a) {\n          delete a.kdTree;\n        });\n        c = f(c, {\n          min: a,\n          max: b\n        });\n        m(h, \"setExtremes\", c, function () {\n          h.userMin = a;\n          h.userMax = b;\n          h.eventArgs = c;\n          e && d.redraw(g);\n        });\n      },\n      zoom: function (a, b) {\n        var e = this.dataMin,\n            g = this.dataMax,\n            c = this.options,\n            f = Math.min(e, n(c.min, e)),\n            h = Math.max(g, n(c.max, g));\n        a = {\n          newMin: a,\n          newMax: b\n        };\n        m(this, \"zoom\", a, function (a) {\n          var b = a.newMin,\n              c = a.newMax;\n          if (b !== this.min || c !== this.max) this.allowZoomOutside || (w(e) && (b < f && (b = f), b > h && (b = h)), w(g) && (c < f && (c = f), c > h && (c = h))), this.displayBtn = void 0 !== b || void 0 !== c, this.setExtremes(b, c, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          a.zoomed = !0;\n        });\n        return a.zoomed;\n      },\n      setAxisSize: function () {\n        var a = this.chart,\n            b = this.options,\n            e = b.offsets || [0, 0, 0, 0],\n            g = this.horiz,\n            c = this.width = Math.round(d.relativeLength(n(b.width, a.plotWidth - e[3] + e[1]), a.plotWidth)),\n            f = this.height = Math.round(d.relativeLength(n(b.height, a.plotHeight - e[0] + e[2]), a.plotHeight)),\n            h = this.top = Math.round(d.relativeLength(n(b.top, a.plotTop + e[0]), a.plotHeight, a.plotTop));\n        b = this.left = Math.round(d.relativeLength(n(b.left, a.plotLeft + e[3]), a.plotWidth, a.plotLeft));\n        this.bottom = a.chartHeight - f - h;\n        this.right = a.chartWidth - c - b;\n        this.len = Math.max(g ? c : f, 0);\n        this.pos = g ? b : h;\n      },\n      getExtremes: function () {\n        var a = this.isLog;\n        return {\n          min: a ? q(this.lin2log(this.min)) : this.min,\n          max: a ? q(this.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      },\n      getThreshold: function (a) {\n        var b = this.isLog,\n            e = b ? this.lin2log(this.min) : this.min;\n        b = b ? this.lin2log(this.max) : this.max;\n        null === a || -Infinity === a ? a = e : Infinity === a ? a = b : e > a ? a = e : b < a && (a = b);\n        return this.translate(a, 0, 1, 0, 1);\n      },\n      autoLabelAlign: function (a) {\n        var b = (n(a, 0) - 90 * this.side + 720) % 360;\n        a = {\n          align: \"center\"\n        };\n        m(this, \"autoLabelAlign\", a, function (a) {\n          15 < b && 165 > b ? a.align = \"right\" : 195 < b && 345 > b && (a.align = \"left\");\n        });\n        return a.align;\n      },\n      tickSize: function (a) {\n        var b = this.options,\n            e = b[a + \"Length\"],\n            g = n(b[a + \"Width\"], \"tick\" === a && this.isXAxis && !this.categories ? 1 : 0);\n\n        if (g && e) {\n          \"inside\" === b[a + \"Position\"] && (e = -e);\n          var c = [e, g];\n        }\n\n        a = {\n          tickSize: c\n        };\n        m(this, \"afterTickSize\", a);\n        return a.tickSize;\n      },\n      labelMetrics: function () {\n        var a = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);\n      },\n      unsquish: function () {\n        var b = this.options.labels,\n            e = this.horiz,\n            g = this.tickInterval,\n            c = g,\n            f = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / g),\n            h,\n            d = b.rotation,\n            m = this.labelMetrics(),\n            A,\n            F = Number.MAX_VALUE,\n            r,\n            v = this.max - this.min,\n            x = function (a) {\n          var b = a / (f || 1);\n          b = 1 < b ? Math.ceil(b) : 1;\n          b * g > v && Infinity !== a && Infinity !== f && v && (b = Math.ceil(v / g));\n          return q(b * g);\n        };\n\n        e ? (r = !b.staggerLines && !b.step && (w(d) ? [d] : f < n(b.autoRotationLimit, 80) && b.autoRotation)) && r.forEach(function (b) {\n          if (b === d || b && -90 <= b && 90 >= b) {\n            A = x(Math.abs(m.h / Math.sin(a * b)));\n            var e = A + Math.abs(b / 360);\n            e < F && (F = e, h = b, c = A);\n          }\n        }) : b.step || (c = x(m.h));\n        this.autoRotation = r;\n        this.labelRotation = n(h, d);\n        return c;\n      },\n      getSlotWidth: function (a) {\n        var b = this.chart,\n            e = this.horiz,\n            g = this.options.labels,\n            c = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            f = b.margin[3];\n        return a && a.slotWidth || e && 2 > (g.step || 0) && !g.rotation && (this.staggerLines || 1) * this.len / c || !e && (g.style && parseInt(g.style.width, 10) || f && f - b.spacing[3] || .33 * b.chartWidth);\n      },\n      renderUnsquish: function () {\n        var a = this.chart,\n            b = a.renderer,\n            e = this.tickPositions,\n            g = this.ticks,\n            c = this.options.labels,\n            f = c && c.style || {},\n            h = this.horiz,\n            d = this.getSlotWidth(),\n            n = Math.max(1, Math.round(d - 2 * (c.padding || 5))),\n            m = {},\n            A = this.labelMetrics(),\n            F = c.style && c.style.textOverflow,\n            r = 0;\n        E(c.rotation) || (m.rotation = c.rotation || 0);\n        e.forEach(function (a) {\n          (a = g[a]) && a.label && a.label.textPxLength > r && (r = a.label.textPxLength);\n        });\n        this.maxLabelLength = r;\n        if (this.autoRotation) r > n && r > A.h ? m.rotation = this.labelRotation : this.labelRotation = 0;else if (d) {\n          var v = n;\n\n          if (!F) {\n            var x = \"clip\";\n\n            for (n = e.length; !h && n--;) {\n              var l = e[n];\n              if (l = g[l].label) l.styles && \"ellipsis\" === l.styles.textOverflow ? l.css({\n                textOverflow: \"clip\"\n              }) : l.textPxLength > d && l.css({\n                width: d + \"px\"\n              }), l.getBBox().height > this.len / e.length - (A.h - A.f) && (l.specificTextOverflow = \"ellipsis\");\n            }\n          }\n        }\n        m.rotation && (v = r > .5 * a.chartHeight ? .33 * a.chartHeight : r, F || (x = \"ellipsis\"));\n        if (this.labelAlign = c.align || this.autoLabelAlign(this.labelRotation)) m.align = this.labelAlign;\n        e.forEach(function (a) {\n          var b = (a = g[a]) && a.label,\n              e = f.width,\n              c = {};\n          b && (b.attr(m), a.shortenLabel ? a.shortenLabel() : v && !e && \"nowrap\" !== f.whiteSpace && (v < b.textPxLength || \"SPAN\" === b.element.tagName) ? (c.width = v, F || (c.textOverflow = b.specificTextOverflow || x), b.css(c)) : b.styles && b.styles.width && !c.width && !e && b.css({\n            width: null\n          }), delete b.specificTextOverflow, a.rotation = m.rotation);\n        }, this);\n        this.tickRotCorr = b.rotCorr(A.b, this.labelRotation || 0, 0 !== this.side);\n      },\n      hasData: function () {\n        return this.series.some(function (a) {\n          return a.hasData();\n        }) || this.options.showEmpty && w(this.min) && w(this.max);\n      },\n      addTitle: function (a) {\n        var b = this.chart.renderer,\n            e = this.horiz,\n            g = this.opposite,\n            c = this.options.title,\n            f,\n            h = this.chart.styledMode;\n        this.axisTitle || ((f = c.textAlign) || (f = (e ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: g ? \"right\" : \"left\",\n          middle: \"center\",\n          high: g ? \"left\" : \"right\"\n        })[c.align]), this.axisTitle = b.text(c.text, 0, 0, c.useHTML).attr({\n          zIndex: 7,\n          rotation: c.rotation || 0,\n          align: f\n        }).addClass(\"highcharts-axis-title\"), h || this.axisTitle.css(x(c.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        h || c.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len\n        });\n        this.axisTitle[a ? \"show\" : \"hide\"](a);\n      },\n      generateTick: function (a) {\n        var b = this.ticks;\n        b[a] ? b[a].addLabel() : b[a] = new A(this, a);\n      },\n      getOffset: function () {\n        var a = this,\n            b = a.chart,\n            e = b.renderer,\n            g = a.options,\n            c = a.tickPositions,\n            f = a.ticks,\n            h = a.horiz,\n            d = a.side,\n            A = b.inverted && !a.isZAxis ? [1, 0, 3, 2][d] : d,\n            F,\n            r = 0,\n            v = 0,\n            x = g.title,\n            l = g.labels,\n            q = 0,\n            p = b.axisOffset;\n        b = b.clipOffset;\n        var u = [-1, 1, 1, -1][d],\n            k = g.className,\n            t = a.axisParent;\n        var E = a.hasData();\n        a.showAxis = F = E || n(g.showEmpty, !0);\n        a.staggerLines = a.horiz && l.staggerLines;\n        a.axisGroup || (a.gridGroup = e.g(\"grid\").attr({\n          zIndex: g.gridZIndex || 1\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (k || \"\")).add(t), a.axisGroup = e.g(\"axis\").attr({\n          zIndex: g.zIndex || 2\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (k || \"\")).add(t), a.labelGroup = e.g(\"axis-labels\").attr({\n          zIndex: l.zIndex || 7\n        }).addClass(\"highcharts-\" + a.coll.toLowerCase() + \"-labels \" + (k || \"\")).add(t));\n        E || a.isLinked ? (c.forEach(function (b, e) {\n          a.generateTick(b, e);\n        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === d || 2 === d || {\n          1: \"left\",\n          3: \"right\"\n        }[d] === a.labelAlign, n(l.reserveSpace, \"center\" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && c.forEach(function (a) {\n          q = Math.max(f[a].getLabelSize(), q);\n        }), a.staggerLines && (q *= a.staggerLines), a.labelOffset = q * (a.opposite ? -1 : 1)) : y(f, function (a, b) {\n          a.destroy();\n          delete f[b];\n        });\n\n        if (x && x.text && !1 !== x.enabled && (a.addTitle(F), F && !1 !== x.reserveSpace)) {\n          a.titleOffset = r = a.axisTitle.getBBox()[h ? \"height\" : \"width\"];\n          var C = x.offset;\n          v = w(C) ? 0 : n(x.margin, h ? 5 : 10);\n        }\n\n        a.renderLine();\n        a.offset = u * n(g.offset, p[d] ? p[d] + (g.margin || 0) : 0);\n        a.tickRotCorr = a.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        e = 0 === d ? -a.labelMetrics().h : 2 === d ? a.tickRotCorr.y : 0;\n        v = Math.abs(q) + v;\n        q && (v = v - e + u * (h ? n(l.y, a.tickRotCorr.y + 8 * u) : l.x));\n        a.axisTitleMargin = n(C, v);\n        a.getMaxLabelDimensions && (a.maxLabelDimensions = a.getMaxLabelDimensions(f, c));\n        h = this.tickSize(\"tick\");\n        p[d] = Math.max(p[d], a.axisTitleMargin + r + u * a.offset, v, c && c.length && h ? h[0] + u * a.offset : 0);\n        g = g.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);\n        b[A] = Math.max(b[A], g);\n        m(this, \"afterGetOffset\");\n      },\n      getLinePath: function (a) {\n        var b = this.chart,\n            e = this.opposite,\n            g = this.offset,\n            c = this.horiz,\n            f = this.left + (e ? this.width : 0) + g;\n        g = b.chartHeight - this.bottom - (e ? this.height : 0) + g;\n        e && (a *= -1);\n        return b.renderer.crispLine([\"M\", c ? this.left : f, c ? g : this.top, \"L\", c ? b.chartWidth - this.right : f, c ? g : b.chartHeight - this.bottom], a);\n      },\n      renderLine: function () {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      },\n      getTitlePosition: function () {\n        var a = this.horiz,\n            b = this.left,\n            e = this.top,\n            g = this.len,\n            c = this.options.title,\n            f = a ? b : e,\n            h = this.opposite,\n            d = this.offset,\n            n = c.x || 0,\n            A = c.y || 0,\n            F = this.axisTitle,\n            r = this.chart.renderer.fontMetrics(c.style && c.style.fontSize, F);\n        F = Math.max(F.getBBox(null, 0).height - r.h - 1, 0);\n        g = {\n          low: f + (a ? 0 : g),\n          middle: f + g / 2,\n          high: f + (a ? g : 0)\n        }[c.align];\n        b = (a ? e + this.height : b) + (a ? 1 : -1) * (h ? -1 : 1) * this.axisTitleMargin + [-F, F, r.f, -F][this.side];\n        a = {\n          x: a ? g + n : b + (h ? this.width : 0) + d + n,\n          y: a ? b + A - (h ? this.height : 0) + d : g + A\n        };\n        m(this, \"afterGetTitlePosition\", {\n          titlePosition: a\n        });\n        return a;\n      },\n      renderMinorTick: function (a) {\n        var b = this.chart.hasRendered && H(this.oldMin),\n            e = this.minorTicks;\n        e[a] || (e[a] = new A(this, a, \"minor\"));\n        b && e[a].isNew && e[a].render(null, !0);\n        e[a].render(null, !1, 1);\n      },\n      renderTick: function (a, b) {\n        var e = this.isLinked,\n            g = this.ticks,\n            c = this.chart.hasRendered && H(this.oldMin);\n        if (!e || a >= this.min && a <= this.max) g[a] || (g[a] = new A(this, a)), c && g[a].isNew && g[a].render(b, !0, -1), g[a].render(b);\n      },\n      render: function () {\n        var a = this,\n            b = a.chart,\n            e = a.options,\n            g = a.isLog,\n            c = a.isLinked,\n            f = a.tickPositions,\n            h = a.axisTitle,\n            n = a.ticks,\n            r = a.minorTicks,\n            v = a.alternateBands,\n            x = e.stackLabels,\n            l = e.alternateGridColor,\n            q = a.tickmarkOffset,\n            p = a.axisLine,\n            u = a.showAxis,\n            k = G(b.renderer.globalAnimation),\n            t,\n            E;\n        a.labelEdge.length = 0;\n        a.overlap = !1;\n        [n, r, v].forEach(function (a) {\n          y(a, function (a) {\n            a.isActive = !1;\n          });\n        });\n        if (a.hasData() || c) a.minorTickInterval && !a.categories && a.getMinorTickPositions().forEach(function (b) {\n          a.renderMinorTick(b);\n        }), f.length && (f.forEach(function (b, e) {\n          a.renderTick(b, e);\n        }), q && (0 === a.min || a.single) && (n[-1] || (n[-1] = new A(a, -1, null, !0)), n[-1].render(-1))), l && f.forEach(function (e, c) {\n          E = void 0 !== f[c + 1] ? f[c + 1] + q : a.max - q;\n          0 === c % 2 && e < a.max && E <= a.max + (b.polar ? -q : q) && (v[e] || (v[e] = new d.PlotLineOrBand(a)), t = e + q, v[e].options = {\n            from: g ? a.lin2log(t) : t,\n            to: g ? a.lin2log(E) : E,\n            color: l\n          }, v[e].render(), v[e].isActive = !0);\n        }), a._addedPlotLB || ((e.plotLines || []).concat(e.plotBands || []).forEach(function (b) {\n          a.addPlotBandOrLine(b);\n        }), a._addedPlotLB = !0);\n        [n, r, v].forEach(function (a) {\n          var e,\n              g = [],\n              c = k.duration;\n          y(a, function (a, b) {\n            a.isActive || (a.render(b, !1, 0), a.isActive = !1, g.push(b));\n          });\n          F(function () {\n            for (e = g.length; e--;) a[g[e]] && !a[g[e]].isActive && (a[g[e]].destroy(), delete a[g[e]]);\n          }, a !== v && b.hasRendered && c ? c : 0);\n        });\n        p && (p[p.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(p.strokeWidth())\n        }), p.isPlaced = !0, p[u ? \"show\" : \"hide\"](u));\n        h && u && (e = a.getTitlePosition(), H(e.y) ? (h[h.isNew ? \"attr\" : \"animate\"](e), h.isNew = !1) : (h.attr(\"y\", -9999), h.isNew = !0));\n        x && x.enabled && a.renderStackTotals();\n        a.isDirty = !1;\n        m(this, \"afterRender\");\n      },\n      redraw: function () {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {\n          a.render();\n        }));\n        this.series.forEach(function (a) {\n          a.isDirty = !0;\n        });\n      },\n      keepProps: \"extKey hcEvents names series userMax userMin\".split(\" \"),\n      destroy: function (a) {\n        var g = this,\n            c = g.stacks,\n            f = g.plotLinesAndBands,\n            h;\n        m(this, \"destroy\", {\n          keepEvents: a\n        });\n        a || e(g);\n        y(c, function (a, e) {\n          b(a);\n          c[e] = null;\n        });\n        [g.ticks, g.minorTicks, g.alternateBands].forEach(function (a) {\n          b(a);\n        });\n        if (f) for (a = f.length; a--;) f[a].destroy();\n        \"stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (a) {\n          g[a] && (g[a] = g[a].destroy());\n        });\n\n        for (h in g.plotLinesAndBandsGroups) g.plotLinesAndBandsGroups[h] = g.plotLinesAndBandsGroups[h].destroy();\n\n        y(g, function (a, b) {\n          -1 === g.keepProps.indexOf(b) && delete g[b];\n        });\n      },\n      drawCrosshair: function (a, b) {\n        var e,\n            g = this.crosshair,\n            c = n(g.snap, !0),\n            f,\n            h = this.cross;\n        m(this, \"drawCrosshair\", {\n          e: a,\n          point: b\n        });\n        a || (a = this.cross && this.cross.e);\n\n        if (this.crosshair && !1 !== (w(b) || !c)) {\n          c ? w(b) && (f = n(\"colorAxis\" !== this.coll ? b.crosshairPos : null, this.isXAxis ? b.plotX : this.len - b.plotY)) : f = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);\n          w(f) && (e = this.getPlotLinePath({\n            value: b && (this.isXAxis ? b.x : n(b.stackY, b.y)),\n            translatedValue: f\n          }) || null);\n\n          if (!w(e)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          c = this.categories && !this.isRadial;\n          h || (this.cross = h = this.chart.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (c ? \"category \" : \"thin \") + g.className).attr({\n            zIndex: n(g.zIndex, 2)\n          }).add(), this.chart.styledMode || (h.attr({\n            stroke: g.color || (c ? p(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": n(g.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), g.dashStyle && h.attr({\n            dashstyle: g.dashStyle\n          })));\n          h.show().attr({\n            d: e\n          });\n          c && !g.width && h.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = a;\n        } else this.hideCrosshair();\n\n        m(this, \"afterDrawCrosshair\", {\n          e: a,\n          point: b\n        });\n      },\n      hideCrosshair: function () {\n        this.cross && this.cross.hide();\n        m(this, \"afterHideCrosshair\");\n      }\n    });\n    return d.Axis = k;\n  });\n  K(I, \"parts/DateTimeAxis.js\", [I[\"parts/Globals.js\"]], function (d) {\n    var k = d.Axis,\n        w = d.getMagnitude,\n        D = d.normalizeTickInterval,\n        H = d.timeUnits;\n\n    k.prototype.getTimeTicks = function () {\n      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n    };\n\n    k.prototype.normalizeTimeTickInterval = function (d, k) {\n      var y = k || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n      k = y[y.length - 1];\n      var t = H[k[0]],\n          E = k[1],\n          u;\n\n      for (u = 0; u < y.length && !(k = y[u], t = H[k[0]], E = k[1], y[u + 1] && d <= (t * E[E.length - 1] + H[y[u + 1][0]]) / 2); u++);\n\n      t === H.year && d < 5 * t && (E = [1, 2, 5]);\n      d = D(d / t, E, \"year\" === k[0] ? Math.max(w(d / t), 1) : 1);\n      return {\n        unitRange: t,\n        count: d,\n        unitName: k[0]\n      };\n    };\n  });\n  K(I, \"parts/LogarithmicAxis.js\", [I[\"parts/Globals.js\"]], function (d) {\n    var k = d.Axis,\n        w = d.getMagnitude,\n        D = d.normalizeTickInterval,\n        H = d.pick;\n\n    k.prototype.getLogTickPositions = function (d, k, C, t) {\n      var y = this.options,\n          u = this.len,\n          l = [];\n      t || (this._minorAutoInterval = null);\n      if (.5 <= d) d = Math.round(d), l = this.getLinearTickPositions(d, k, C);else if (.08 <= d) {\n        u = Math.floor(k);\n        var p, q;\n\n        for (y = .3 < d ? [1, 2, 4] : .15 < d ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; u < C + 1 && !q; u++) {\n          var c = y.length;\n\n          for (p = 0; p < c && !q; p++) {\n            var a = this.log2lin(this.lin2log(u) * y[p]);\n            a > k && (!t || b <= C) && void 0 !== b && l.push(b);\n            b > C && (q = !0);\n            var b = a;\n          }\n        }\n      } else k = this.lin2log(k), C = this.lin2log(C), d = t ? this.getMinorTickInterval() : y.tickInterval, d = H(\"auto\" === d ? null : d, this._minorAutoInterval, y.tickPixelInterval / (t ? 5 : 1) * (C - k) / ((t ? u / this.tickPositions.length : u) || 1)), d = D(d, null, w(d)), l = this.getLinearTickPositions(d, k, C).map(this.log2lin), t || (this._minorAutoInterval = d / 5);\n      t || (this.tickInterval = d);\n      return l;\n    };\n\n    k.prototype.log2lin = function (d) {\n      return Math.log(d) / Math.LN10;\n    };\n\n    k.prototype.lin2log = function (d) {\n      return Math.pow(10, d);\n    };\n  });\n  K(I, \"parts/PlotLineOrBand.js\", [I[\"parts/Globals.js\"], I[\"parts/Axis.js\"], I[\"parts/Utilities.js\"]], function (d, k, w) {\n    var D = w.defined,\n        H = w.erase,\n        E = w.objectEach,\n        y = d.arrayMax,\n        C = d.arrayMin,\n        t = d.destroyObjectProperties,\n        G = d.merge,\n        u = d.pick;\n\n    d.PlotLineOrBand = function (d, p) {\n      this.axis = d;\n      p && (this.options = p, this.id = p.id);\n    };\n\n    d.PlotLineOrBand.prototype = {\n      render: function () {\n        d.fireEvent(this, \"render\");\n        var l = this,\n            p = l.axis,\n            q = p.horiz,\n            c = l.options,\n            a = c.label,\n            b = l.label,\n            f = c.to,\n            m = c.from,\n            h = c.value,\n            r = D(m) && D(f),\n            x = D(h),\n            v = l.svgElem,\n            n = !v,\n            e = [],\n            g = c.color,\n            F = u(c.zIndex, 0),\n            A = c.events;\n        e = {\n          \"class\": \"highcharts-plot-\" + (r ? \"band \" : \"line \") + (c.className || \"\")\n        };\n        var z = {},\n            B = p.chart.renderer,\n            J = r ? \"bands\" : \"lines\";\n        p.isLog && (m = p.log2lin(m), f = p.log2lin(f), h = p.log2lin(h));\n        p.chart.styledMode || (x ? (e.stroke = g || \"#999999\", e[\"stroke-width\"] = u(c.width, 1), c.dashStyle && (e.dashstyle = c.dashStyle)) : r && (e.fill = g || \"#e6ebf5\", c.borderWidth && (e.stroke = c.borderColor, e[\"stroke-width\"] = c.borderWidth)));\n        z.zIndex = F;\n        J += \"-\" + F;\n        (g = p.plotLinesAndBandsGroups[J]) || (p.plotLinesAndBandsGroups[J] = g = B.g(\"plot-\" + J).attr(z).add());\n        n && (l.svgElem = v = B.path().attr(e).add(g));\n        if (x) e = p.getPlotLinePath({\n          value: h,\n          lineWidth: v.strokeWidth(),\n          acrossPanes: c.acrossPanes\n        });else if (r) e = p.getPlotBandPath(m, f, c);else return;\n        (n || !v.d) && e && e.length ? (v.attr({\n          d: e\n        }), A && E(A, function (a, b) {\n          v.on(b, function (a) {\n            A[b].apply(l, [a]);\n          });\n        })) : v && (e ? (v.show(!0), v.animate({\n          d: e\n        })) : v.d && (v.hide(), b && (l.label = b = b.destroy())));\n        a && (D(a.text) || D(a.formatter)) && e && e.length && 0 < p.width && 0 < p.height && !e.isFlat ? (a = G({\n          align: q && r && \"center\",\n          x: q ? !r && 4 : 10,\n          verticalAlign: !q && r && \"middle\",\n          y: q ? r ? 16 : 10 : r ? 6 : -4,\n          rotation: q && !r && 90\n        }, a), this.renderLabel(a, e, r, F)) : b && b.hide();\n        return l;\n      },\n      renderLabel: function (d, p, q, c) {\n        var a = this.label,\n            b = this.axis.chart.renderer;\n        a || (a = {\n          align: d.textAlign || d.align,\n          rotation: d.rotation,\n          \"class\": \"highcharts-plot-\" + (q ? \"band\" : \"line\") + \"-label \" + (d.className || \"\")\n        }, a.zIndex = c, c = this.getLabelText(d), this.label = a = b.text(c, 0, 0, d.useHTML).attr(a).add(), this.axis.chart.styledMode || a.css(d.style));\n        b = p.xBounds || [p[1], p[4], q ? p[6] : p[1]];\n        p = p.yBounds || [p[2], p[5], q ? p[7] : p[2]];\n        q = C(b);\n        c = C(p);\n        a.align(d, !1, {\n          x: q,\n          y: c,\n          width: y(b) - q,\n          height: y(p) - c\n        });\n        a.show(!0);\n      },\n      getLabelText: function (d) {\n        return D(d.formatter) ? d.formatter.call(this) : d.text;\n      },\n      destroy: function () {\n        H(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        t(this);\n      }\n    };\n    d.extend(k.prototype, {\n      getPlotBandPath: function (d, p) {\n        var q = this.getPlotLinePath({\n          value: p,\n          force: !0,\n          acrossPanes: this.options.acrossPanes\n        }),\n            c = this.getPlotLinePath({\n          value: d,\n          force: !0,\n          acrossPanes: this.options.acrossPanes\n        }),\n            a = [],\n            b = this.horiz,\n            f = 1;\n        d = d < this.min && p < this.min || d > this.max && p > this.max;\n\n        if (c && q) {\n          if (d) {\n            var m = c.toString() === q.toString();\n            f = 0;\n          }\n\n          for (d = 0; d < c.length; d += 6) b && q[d + 1] === c[d + 1] ? (q[d + 1] += f, q[d + 4] += f) : b || q[d + 2] !== c[d + 2] || (q[d + 2] += f, q[d + 5] += f), a.push(\"M\", c[d + 1], c[d + 2], \"L\", c[d + 4], c[d + 5], q[d + 4], q[d + 5], q[d + 1], q[d + 2], \"z\"), a.isFlat = m;\n        }\n\n        return a;\n      },\n      addPlotBand: function (d) {\n        return this.addPlotBandOrLine(d, \"plotBands\");\n      },\n      addPlotLine: function (d) {\n        return this.addPlotBandOrLine(d, \"plotLines\");\n      },\n      addPlotBandOrLine: function (l, p) {\n        var q = new d.PlotLineOrBand(this, l).render(),\n            c = this.userOptions;\n\n        if (q) {\n          if (p) {\n            var a = c[p] || [];\n            a.push(l);\n            c[p] = a;\n          }\n\n          this.plotLinesAndBands.push(q);\n        }\n\n        return q;\n      },\n      removePlotBandOrLine: function (d) {\n        for (var l = this.plotLinesAndBands, q = this.options, c = this.userOptions, a = l.length; a--;) l[a].id === d && l[a].destroy();\n\n        [q.plotLines || [], c.plotLines || [], q.plotBands || [], c.plotBands || []].forEach(function (b) {\n          for (a = b.length; a--;) b[a].id === d && H(b, b[a]);\n        });\n      },\n      removePlotBand: function (d) {\n        this.removePlotBandOrLine(d);\n      },\n      removePlotLine: function (d) {\n        this.removePlotBandOrLine(d);\n      }\n    });\n  });\n  K(I, \"parts/Tooltip.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.isNumber,\n        H = k.isString,\n        E = k.splat;\n    \"\";\n    var y = d.doc,\n        C = d.extend,\n        t = d.format,\n        G = d.merge,\n        u = d.pick,\n        l = d.syncTimeout,\n        p = d.timeUnits;\n\n    d.Tooltip = function () {\n      this.init.apply(this, arguments);\n    };\n\n    d.Tooltip.prototype = {\n      init: function (d, c) {\n        this.chart = d;\n        this.options = c;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = c.split && !d.inverted;\n        this.shared = c.shared || this.split;\n        this.outside = u(c.outside, !(!d.scrollablePixelsX && !d.scrollablePixelsY)) && !this.split;\n      },\n      cleanSplit: function (d) {\n        this.chart.series.forEach(function (c) {\n          var a = c && c.tt;\n          a && (!a.isActive || d ? c.tt = a.destroy() : a.isActive = !1);\n        });\n      },\n      applyFilter: function () {\n        var d = this.chart;\n        d.renderer.definition({\n          tagName: \"filter\",\n          id: \"drop-shadow-\" + d.index,\n          opacity: .5,\n          children: [{\n            tagName: \"feGaussianBlur\",\n            \"in\": \"SourceAlpha\",\n            stdDeviation: 1\n          }, {\n            tagName: \"feOffset\",\n            dx: 1,\n            dy: 1\n          }, {\n            tagName: \"feComponentTransfer\",\n            children: [{\n              tagName: \"feFuncA\",\n              type: \"linear\",\n              slope: .3\n            }]\n          }, {\n            tagName: \"feMerge\",\n            children: [{\n              tagName: \"feMergeNode\"\n            }, {\n              tagName: \"feMergeNode\",\n              \"in\": \"SourceGraphic\"\n            }]\n          }]\n        });\n        d.renderer.definition({\n          tagName: \"style\",\n          textContent: \".highcharts-tooltip-\" + d.index + \"{filter:url(#drop-shadow-\" + d.index + \")}\"\n        });\n      },\n      getLabel: function () {\n        var q = this,\n            c = this.chart.renderer,\n            a = this.chart.styledMode,\n            b = this.options,\n            f = \"tooltip\" + (w(b.className) ? \" \" + b.className : \"\"),\n            m;\n\n        if (!this.label) {\n          this.outside && (this.container = m = d.doc.createElement(\"div\"), m.className = \"highcharts-tooltip-container\", d.css(m, {\n            position: \"absolute\",\n            top: \"1px\",\n            pointerEvents: b.style && b.style.pointerEvents,\n            zIndex: 3\n          }), d.doc.body.appendChild(m), this.renderer = c = new d.Renderer(m, 0, 0, {}, void 0, void 0, c.styledMode));\n          this.split ? this.label = c.g(f) : (this.label = c.label(\"\", 0, 0, b.shape || \"callout\", null, null, b.useHTML, null, f).attr({\n            padding: b.padding,\n            r: b.borderRadius\n          }), a || this.label.attr({\n            fill: b.backgroundColor,\n            \"stroke-width\": b.borderWidth\n          }).css(b.style).shadow(b.shadow));\n          a && (this.applyFilter(), this.label.addClass(\"highcharts-tooltip-\" + this.chart.index));\n\n          if (this.outside) {\n            var h = {\n              x: this.label.xSetter,\n              y: this.label.ySetter\n            };\n\n            this.label.xSetter = function (a, b) {\n              h[b].call(this.label, q.distance);\n              m.style.left = a + \"px\";\n            };\n\n            this.label.ySetter = function (a, b) {\n              h[b].call(this.label, q.distance);\n              m.style.top = a + \"px\";\n            };\n          }\n\n          this.label.attr({\n            zIndex: 8\n          }).add();\n        }\n\n        return this.label;\n      },\n      update: function (d) {\n        this.destroy();\n        G(!0, this.chart.options.tooltip.userOptions, d);\n        this.init(this.chart, G(!0, this.options, d));\n      },\n      destroy: function () {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), d.discardElement(this.container));\n        d.clearTimeout(this.hideTimer);\n        d.clearTimeout(this.tooltipTimeout);\n      },\n      move: function (l, c, a, b) {\n        var f = this,\n            m = f.now,\n            h = !1 !== f.options.animation && !f.isHidden && (1 < Math.abs(l - m.x) || 1 < Math.abs(c - m.y)),\n            r = f.followPointer || 1 < f.len;\n        C(m, {\n          x: h ? (2 * m.x + l) / 3 : l,\n          y: h ? (m.y + c) / 2 : c,\n          anchorX: r ? void 0 : h ? (2 * m.anchorX + a) / 3 : a,\n          anchorY: r ? void 0 : h ? (m.anchorY + b) / 2 : b\n        });\n        f.getLabel().attr(m);\n        h && (d.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          f && f.move(l, c, a, b);\n        }, 32));\n      },\n      hide: function (p) {\n        var c = this;\n        d.clearTimeout(this.hideTimer);\n        p = u(p, this.options.hideDelay, 500);\n        this.isHidden || (this.hideTimer = l(function () {\n          c.getLabel()[p ? \"fadeOut\" : \"hide\"]();\n          c.isHidden = !0;\n        }, p));\n      },\n      getAnchor: function (d, c) {\n        var a = this.chart,\n            b = a.pointer,\n            f = a.inverted,\n            m = a.plotTop,\n            h = a.plotLeft,\n            r = 0,\n            x = 0,\n            v,\n            n;\n        d = E(d);\n        this.followPointer && c ? (void 0 === c.chartX && (c = b.normalize(c)), d = [c.chartX - a.plotLeft, c.chartY - m]) : d[0].tooltipPos ? d = d[0].tooltipPos : (d.forEach(function (a) {\n          v = a.series.yAxis;\n          n = a.series.xAxis;\n          r += a.plotX + (!f && n ? n.left - h : 0);\n          x += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!f && v ? v.top - m : 0);\n        }), r /= d.length, x /= d.length, d = [f ? a.plotWidth - x : r, this.shared && !f && 1 < d.length && c ? c.chartY - m : f ? a.plotHeight - r : x]);\n        return d.map(Math.round);\n      },\n      getPosition: function (d, c, a) {\n        var b = this.chart,\n            f = this.distance,\n            m = {},\n            h = b.inverted && a.h || 0,\n            r,\n            x = this.outside,\n            v = x ? y.documentElement.clientWidth - 2 * f : b.chartWidth,\n            n = x ? Math.max(y.body.scrollHeight, y.documentElement.scrollHeight, y.body.offsetHeight, y.documentElement.offsetHeight, y.documentElement.clientHeight) : b.chartHeight,\n            e = b.pointer.chartPosition,\n            g = b.containerScaling,\n            F = function (a) {\n          return g ? a * g.scaleX : a;\n        },\n            A = function (a) {\n          return g ? a * g.scaleY : a;\n        },\n            z = function (g) {\n          var h = \"x\" === g;\n          return [g, h ? v : n, h ? d : c].concat(x ? [h ? F(d) : A(c), h ? e.left - f + F(a.plotX + b.plotLeft) : e.top - f + A(a.plotY + b.plotTop), 0, h ? v : n] : [h ? d : c, h ? a.plotX + b.plotLeft : a.plotY + b.plotTop, h ? b.plotLeft : b.plotTop, h ? b.plotLeft + b.plotWidth : b.plotTop + b.plotHeight]);\n        },\n            B = z(\"y\"),\n            l = z(\"x\"),\n            p = !this.followPointer && u(a.ttBelow, !b.inverted === !!a.negative),\n            q = function (a, b, e, g, c, d, n) {\n          var z = \"y\" === a ? A(f) : F(f),\n              r = (e - g) / 2,\n              B = g < c - f,\n              v = c + f + g < b,\n              x = c - z - e + r;\n          c = c + z - r;\n          if (p && v) m[a] = c;else if (!p && B) m[a] = x;else if (B) m[a] = Math.min(n - g, 0 > x - h ? x : x - h);else if (v) m[a] = Math.max(d, c + h + e > b ? c : c + h);else return !1;\n        },\n            k = function (a, b, e, g, c) {\n          var d;\n          c < f || c > b - f ? d = !1 : m[a] = c < e / 2 ? 1 : c > b - g / 2 ? b - g - 2 : c - e / 2;\n          return d;\n        },\n            t = function (a) {\n          var b = B;\n          B = l;\n          l = b;\n          r = a;\n        },\n            L = function () {\n          !1 !== q.apply(0, B) ? !1 !== k.apply(0, l) || r || (t(!0), L()) : r ? m.x = m.y = 0 : (t(!0), L());\n        };\n\n        (b.inverted || 1 < this.len) && t();\n        L();\n        return m;\n      },\n      defaultFormatter: function (d) {\n        var c = this.points || E(this);\n        var a = [d.tooltipFooterHeaderFormatter(c[0])];\n        a = a.concat(d.bodyFormatter(c));\n        a.push(d.tooltipFooterHeaderFormatter(c[0], !0));\n        return a;\n      },\n      refresh: function (l, c) {\n        var a = this.chart,\n            b = this.options,\n            f = l,\n            m = {},\n            h = [];\n        var r = b.formatter || this.defaultFormatter;\n        m = this.shared;\n        var x = a.styledMode;\n\n        if (b.enabled) {\n          d.clearTimeout(this.hideTimer);\n          this.followPointer = E(f)[0].series.tooltipOptions.followPointer;\n          var v = this.getAnchor(f, c);\n          c = v[0];\n          var n = v[1];\n          !m || f.series && f.series.noSharedTooltip ? m = f.getLabelConfig() : (a.pointer.applyInactiveState(f), f.forEach(function (a) {\n            a.setState(\"hover\");\n            h.push(a.getLabelConfig());\n          }), m = {\n            x: f[0].category,\n            y: f[0].y\n          }, m.points = h, f = f[0]);\n          this.len = h.length;\n          r = r.call(m, this);\n          m = f.series;\n          this.distance = u(m.tooltipOptions.distance, 16);\n          !1 === r ? this.hide() : (a = this.getLabel(), this.isHidden && a.attr({\n            opacity: 1\n          }).show(), this.split ? this.renderSplit(r, E(l)) : (b.style.width && !x || a.css({\n            width: this.chart.spacingBox.width\n          }), a.attr({\n            text: r && r.join ? r.join(\"\") : r\n          }), a.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + u(f.colorIndex, m.colorIndex)), x || a.attr({\n            stroke: b.borderColor || f.color || m.color || \"#666666\"\n          }), this.updatePosition({\n            plotX: c,\n            plotY: n,\n            negative: f.negative,\n            ttBelow: f.ttBelow,\n            h: v[2] || 0\n          })), this.isHidden = !1);\n          d.fireEvent(this, \"refresh\");\n        }\n      },\n      renderSplit: function (l, c) {\n        var a = this,\n            b = [],\n            f = this.chart,\n            m = f.renderer,\n            h = !0,\n            r = this.options,\n            x = 0,\n            v,\n            n = this.getLabel(),\n            e = f.plotTop;\n        H(l) && (l = [!1, l]);\n        l.slice(0, c.length + 1).forEach(function (g, d) {\n          if (!1 !== g && \"\" !== g) {\n            d = c[d - 1] || {\n              isHeader: !0,\n              plotX: c[0].plotX,\n              plotY: f.plotHeight\n            };\n            var A = d.series || a,\n                F = A.tt,\n                B = d.series || {},\n                l = \"highcharts-color-\" + u(d.colorIndex, B.colorIndex, \"none\");\n            F || (F = {\n              padding: r.padding,\n              r: r.borderRadius\n            }, f.styledMode || (F.fill = r.backgroundColor, F[\"stroke-width\"] = r.borderWidth), A.tt = F = m.label(null, null, null, (d.isHeader ? r.headerShape : r.shape) || \"callout\", null, null, r.useHTML).addClass(\"highcharts-tooltip-box \" + l).attr(F).add(n));\n            F.isActive = !0;\n            F.attr({\n              text: g\n            });\n            f.styledMode || F.css(r.style).shadow(r.shadow).attr({\n              stroke: r.borderColor || d.color || B.color || \"#333333\"\n            });\n            g = F.getBBox();\n            l = g.width + F.strokeWidth();\n            d.isHeader ? (x = g.height, f.xAxis[0].opposite && (v = !0, e -= x), g = Math.max(0, Math.min(d.plotX + f.plotLeft - l / 2, f.chartWidth + (f.scrollablePixelsX ? f.scrollablePixelsX - f.marginRight : 0) - l))) : g = d.plotX + f.plotLeft - u(r.distance, 16) - l;\n            0 > g && (h = !1);\n            d.isHeader ? B = v ? -x : f.plotHeight + x : (B = B.yAxis, B = B.pos - e + Math.max(0, Math.min(d.plotY || 0, B.len)));\n            b.push({\n              target: B,\n              rank: d.isHeader ? 1 : 0,\n              size: A.tt.getBBox().height + 1,\n              point: d,\n              x: g,\n              tt: F\n            });\n          }\n        });\n        this.cleanSplit();\n        r.positioner && b.forEach(function (b) {\n          var e = r.positioner.call(a, b.tt.getBBox().width, b.size, b.point);\n          b.x = e.x;\n          b.align = 0;\n          b.target = e.y;\n          b.rank = u(e.rank, b.rank);\n        });\n        d.distribute(b, f.plotHeight + x);\n        b.forEach(function (b) {\n          var g = b.point,\n              c = g.series,\n              d = c && c.yAxis;\n          b.tt.attr({\n            visibility: void 0 === b.pos ? \"hidden\" : \"inherit\",\n            x: h || g.isHeader || r.positioner ? b.x : g.plotX + f.plotLeft + a.distance,\n            y: b.pos + e,\n            anchorX: g.isHeader ? g.plotX + f.plotLeft : g.plotX + c.xAxis.pos,\n            anchorY: g.isHeader ? f.plotTop + f.plotHeight / 2 : d.pos + Math.max(0, Math.min(g.plotY, d.len))\n          });\n        });\n      },\n      updatePosition: function (l) {\n        var c = this.chart,\n            a = c.pointer,\n            b = this.getLabel(),\n            f = l.plotX + c.plotLeft,\n            m = l.plotY + c.plotTop;\n        a.chartPosition || (a.chartPosition = d.offset(c.container));\n        l = (this.options.positioner || this.getPosition).call(this, b.width, b.height, l);\n\n        if (this.outside) {\n          var h = (this.options.borderWidth || 0) + 2 * this.distance;\n          this.renderer.setSize(b.width + h, b.height + h, !1);\n          if (c = c.containerScaling) d.css(this.container, {\n            transform: \"scale(\" + c.scaleX + \", \" + c.scaleY + \")\"\n          }), f *= c.scaleX, m *= c.scaleY;\n          f += a.chartPosition.left - l.x;\n          m += a.chartPosition.top - l.y;\n        }\n\n        this.move(Math.round(l.x), Math.round(l.y || 0), f, m);\n      },\n      getDateFormat: function (d, c, a, b) {\n        var f = this.chart.time,\n            m = f.dateFormat(\"%m-%d %H:%M:%S.%L\", c),\n            h = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            r = \"millisecond\";\n\n        for (x in p) {\n          if (d === p.week && +f.dateFormat(\"%w\", c) === a && \"00:00:00.000\" === m.substr(6)) {\n            var x = \"week\";\n            break;\n          }\n\n          if (p[x] > d) {\n            x = r;\n            break;\n          }\n\n          if (h[x] && m.substr(h[x]) !== \"01-01 00:00:00.000\".substr(h[x])) break;\n          \"week\" !== x && (r = x);\n        }\n\n        if (x) var v = f.resolveDTLFormat(b[x]).main;\n        return v;\n      },\n      getXDateFormat: function (d, c, a) {\n        c = c.dateTimeLabelFormats;\n        var b = a && a.closestPointRange;\n        return (b ? this.getDateFormat(b, d.x, a.options.startOfWeek, c) : c.day) || c.year;\n      },\n      tooltipFooterHeaderFormatter: function (l, c) {\n        var a = c ? \"footer\" : \"header\",\n            b = l.series,\n            f = b.tooltipOptions,\n            m = f.xDateFormat,\n            h = b.xAxis,\n            r = h && \"datetime\" === h.options.type && D(l.key),\n            x = f[a + \"Format\"];\n        c = {\n          isFooter: c,\n          labelConfig: l\n        };\n        d.fireEvent(this, \"headerFormatter\", c, function (a) {\n          r && !m && (m = this.getXDateFormat(l, f, h));\n          r && m && (l.point && l.point.tooltipDateKeys || [\"key\"]).forEach(function (a) {\n            x = x.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + m + \"}\");\n          });\n          b.chart.styledMode && (x = this.styledModeFormat(x));\n          a.text = t(x, {\n            point: l,\n            series: b\n          }, this.chart.time);\n        });\n        return c.text;\n      },\n      bodyFormatter: function (d) {\n        return d.map(function (c) {\n          var a = c.series.tooltipOptions;\n          return (a[(c.point.formatPrefix || \"point\") + \"Formatter\"] || c.point.tooltipFormatter).call(c.point, a[(c.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      },\n      styledModeFormat: function (d) {\n        return d.replace('style=\"font-size: 10px\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex}\"');\n      }\n    };\n  });\n  K(I, \"parts/Pointer.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.attr,\n        D = k.defined,\n        H = k.isNumber,\n        E = k.isObject,\n        y = k.objectEach,\n        C = k.splat,\n        t = d.addEvent,\n        G = d.charts,\n        u = d.color,\n        l = d.css,\n        p = d.extend,\n        q = d.find,\n        c = d.fireEvent,\n        a = d.offset,\n        b = d.pick,\n        f = d.Tooltip;\n\n    d.Pointer = function (a, b) {\n      this.init(a, b);\n    };\n\n    d.Pointer.prototype = {\n      init: function (a, c) {\n        this.options = c;\n        this.chart = a;\n        this.runChartClick = c.chart.events && !!c.chart.events.click;\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        f && (a.tooltip = new f(a, c.tooltip), this.followTouchMove = b(c.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      },\n      zoomOption: function (a) {\n        var c = this.chart,\n            d = c.options.chart,\n            f = d.zoomType || \"\";\n        c = c.inverted;\n        /touch/.test(a.type) && (f = b(d.pinchType, f));\n        this.zoomX = a = /x/.test(f);\n        this.zoomY = f = /y/.test(f);\n        this.zoomHor = a && !c || f && c;\n        this.zoomVert = f && !c || a && c;\n        this.hasZoom = a || f;\n      },\n      normalize: function (b, c) {\n        var d = b.touches ? b.touches.length ? b.touches.item(0) : b.changedTouches[0] : b;\n        c || (this.chartPosition = c = a(this.chart.container));\n        var f = d.pageX - c.left;\n        c = d.pageY - c.top;\n        if (d = this.chart.containerScaling) f /= d.scaleX, c /= d.scaleY;\n        return p(b, {\n          chartX: Math.round(f),\n          chartY: Math.round(c)\n        });\n      },\n      getCoordinates: function (a) {\n        var b = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (c) {\n          b[c.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: c,\n            value: c.toValue(a[c.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return b;\n      },\n      findNearestKDPoint: function (a, b, c) {\n        var d;\n        a.forEach(function (a) {\n          var f = !(a.noSharedTooltip && b) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(c, f);\n\n          if ((f = E(a, !0)) && !(f = !E(d, !0))) {\n            f = d.distX - a.distX;\n            var e = d.dist - a.dist,\n                g = (a.series.group && a.series.group.zIndex) - (d.series.group && d.series.group.zIndex);\n            f = 0 < (0 !== f && b ? f : 0 !== e ? e : 0 !== g ? g : d.series.index > a.series.index ? -1 : 1);\n          }\n\n          f && (d = a);\n        });\n        return d;\n      },\n      getPointFromEvent: function (a) {\n        a = a.target;\n\n        for (var b; a && !b;) b = a.point, a = a.parentNode;\n\n        return b;\n      },\n      getChartCoordinatesFromPoint: function (a, c) {\n        var d = a.series,\n            f = d.xAxis;\n        d = d.yAxis;\n        var h = b(a.clientX, a.plotX),\n            n = a.shapeArgs;\n        if (f && d) return c ? {\n          chartX: f.len + f.pos - h,\n          chartY: d.len + d.pos - a.plotY\n        } : {\n          chartX: h + f.pos,\n          chartY: a.plotY + d.pos\n        };\n        if (n && n.x && n.y) return {\n          chartX: n.x,\n          chartY: n.y\n        };\n      },\n      getHoverData: function (a, c, d, f, v, n) {\n        var e,\n            g = [];\n        f = !(!f || !a);\n        var h = c && !c.stickyTracking ? [c] : d.filter(function (a) {\n          return a.visible && !(!v && a.directTouch) && b(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });\n        c = (e = f || !n ? a : this.findNearestKDPoint(h, v, n)) && e.series;\n        e && (v && !c.noSharedTooltip ? (h = d.filter(function (a) {\n          return a.visible && !(!v && a.directTouch) && b(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), h.forEach(function (a) {\n          var b = q(a.points, function (a) {\n            return a.x === e.x && !a.isNull;\n          });\n          E(b) && (a.chart.isBoosting && (b = a.getPoint(b)), g.push(b));\n        })) : g.push(e));\n        return {\n          hoverPoint: e,\n          hoverSeries: c,\n          hoverPoints: g\n        };\n      },\n      runPointActions: function (a, c) {\n        var f = this.chart,\n            h = f.tooltip && f.tooltip.options.enabled ? f.tooltip : void 0,\n            m = h ? h.shared : !1,\n            n = c || f.hoverPoint,\n            e = n && n.series || f.hoverSeries;\n        e = this.getHoverData(n, e, f.series, (!a || \"touchmove\" !== a.type) && (!!c || e && e.directTouch && this.isDirectTouch), m, a);\n        n = e.hoverPoint;\n        var g = e.hoverPoints;\n        c = (e = e.hoverSeries) && e.tooltipOptions.followPointer;\n        m = m && e && !e.noSharedTooltip;\n\n        if (n && (n !== f.hoverPoint || h && h.isHidden)) {\n          (f.hoverPoints || []).forEach(function (a) {\n            -1 === g.indexOf(a) && a.setState();\n          });\n          if (f.hoverSeries !== e) e.onMouseOver();\n          this.applyInactiveState(g);\n          (g || []).forEach(function (a) {\n            a.setState(\"hover\");\n          });\n          f.hoverPoint && f.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!n.series) return;\n          n.firePointEvent(\"mouseOver\");\n          f.hoverPoints = g;\n          f.hoverPoint = n;\n          h && h.refresh(m ? g : n, a);\n        } else c && h && !h.isHidden && (n = h.getAnchor([{}], a), h.updatePosition({\n          plotX: n[0],\n          plotY: n[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = t(f.container.ownerDocument, \"mousemove\", function (a) {\n          var b = G[d.hoverChartIndex];\n          if (b) b.pointer.onDocumentMouseMove(a);\n        }));\n        f.axes.forEach(function (e) {\n          var c = b(e.crosshair.snap, !0),\n              f = c ? d.find(g, function (a) {\n            return a.series[e.coll] === e;\n          }) : void 0;\n          f || !c ? e.drawCrosshair(a, f) : e.hideCrosshair();\n        });\n      },\n      applyInactiveState: function (a) {\n        var b = [],\n            c;\n        (a || []).forEach(function (a) {\n          c = a.series;\n          b.push(c);\n          c.linkedParent && b.push(c.linkedParent);\n          c.linkedSeries && (b = b.concat(c.linkedSeries));\n          c.navigatorSeries && b.push(c.navigatorSeries);\n        });\n        this.chart.series.forEach(function (a) {\n          -1 === b.indexOf(a) ? a.setState(\"inactive\", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState(\"inactive\");\n        });\n      },\n      reset: function (a, b) {\n        var c = this.chart,\n            d = c.hoverSeries,\n            f = c.hoverPoint,\n            h = c.hoverPoints,\n            e = c.tooltip,\n            g = e && e.shared ? h : f;\n        a && g && C(g).forEach(function (b) {\n          b.series.isCartesian && void 0 === b.plotX && (a = !1);\n        });\n        if (a) e && g && C(g).length && (e.refresh(g), e.shared && h ? h.forEach(function (a) {\n          a.setState(a.state, !0);\n          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));\n        }) : f && (f.setState(f.state, !0), c.axes.forEach(function (a) {\n          a.crosshair && a.drawCrosshair(null, f);\n        })));else {\n          if (f) f.onMouseOut();\n          h && h.forEach(function (a) {\n            a.setState();\n          });\n          if (d) d.onMouseOut();\n          e && e.hide(b);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          c.axes.forEach(function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = c.hoverPoints = c.hoverPoint = null;\n        }\n      },\n      scaleGroups: function (a, b) {\n        var c = this.chart,\n            d;\n        c.series.forEach(function (f) {\n          d = a || f.getPlotBox();\n          f.xAxis && f.xAxis.zoomEnabled && f.group && (f.group.attr(d), f.markerGroup && (f.markerGroup.attr(d), f.markerGroup.clip(b ? c.clipRect : null)), f.dataLabelsGroup && f.dataLabelsGroup.attr(d));\n        });\n        c.clipRect.attr(b || c.clipBox);\n      },\n      dragStart: function (a) {\n        var b = this.chart;\n        b.mouseIsDown = a.type;\n        b.cancelClick = !1;\n        b.mouseDownX = this.mouseDownX = a.chartX;\n        b.mouseDownY = this.mouseDownY = a.chartY;\n      },\n      drag: function (a) {\n        var b = this.chart,\n            c = b.options.chart,\n            d = a.chartX,\n            f = a.chartY,\n            n = this.zoomHor,\n            e = this.zoomVert,\n            g = b.plotLeft,\n            m = b.plotTop,\n            A = b.plotWidth,\n            z = b.plotHeight,\n            B = this.selectionMarker,\n            l = this.mouseDownX,\n            p = this.mouseDownY,\n            q = c.panKey && a[c.panKey + \"Key\"];\n        if (!B || !B.touch) if (d < g ? d = g : d > g + A && (d = g + A), f < m ? f = m : f > m + z && (f = m + z), this.hasDragged = Math.sqrt(Math.pow(l - d, 2) + Math.pow(p - f, 2)), 10 < this.hasDragged) {\n          var k = b.isInsidePlot(l - g, p - m);\n          b.hasCartesianSeries && (this.zoomX || this.zoomY) && k && !q && !B && (this.selectionMarker = B = b.renderer.rect(g, m, n ? 1 : A, e ? 1 : z, 0).attr({\n            \"class\": \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), b.styledMode || B.attr({\n            fill: c.selectionMarkerFill || u(\"#335cad\").setOpacity(.25).get()\n          }));\n          B && n && (d -= l, B.attr({\n            width: Math.abs(d),\n            x: (0 < d ? 0 : d) + l\n          }));\n          B && e && (d = f - p, B.attr({\n            height: Math.abs(d),\n            y: (0 < d ? 0 : d) + p\n          }));\n          k && !B && c.panning && b.pan(a, c.panning);\n        }\n      },\n      drop: function (a) {\n        var b = this,\n            d = this.chart,\n            f = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var m = {\n            originalEvent: a,\n            xAxis: [],\n            yAxis: []\n          },\n              n = this.selectionMarker,\n              e = n.attr ? n.attr(\"x\") : n.x,\n              g = n.attr ? n.attr(\"y\") : n.y,\n              F = n.attr ? n.attr(\"width\") : n.width,\n              A = n.attr ? n.attr(\"height\") : n.height,\n              z;\n          if (this.hasDragged || f) d.axes.forEach(function (c) {\n            if (c.zoomEnabled && D(c.min) && (f || b[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[c.coll]])) {\n              var d = c.horiz,\n                  h = \"touchend\" === a.type ? c.minPixelPadding : 0,\n                  n = c.toValue((d ? e : g) + h);\n              d = c.toValue((d ? e + F : g + A) - h);\n              m[c.coll].push({\n                axis: c,\n                min: Math.min(n, d),\n                max: Math.max(n, d)\n              });\n              z = !0;\n            }\n          }), z && c(d, \"selection\", m, function (a) {\n            d.zoom(p(a, f ? {\n              animation: !1\n            } : null));\n          });\n          H(d.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          f && this.scaleGroups();\n        }\n\n        d && H(d.index) && (l(d.container, {\n          cursor: d._cursor\n        }), d.cancelClick = 10 < this.hasDragged, d.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      },\n      onContainerMouseDown: function (a) {\n        a = this.normalize(a);\n        2 !== a.button && (this.zoomOption(a), a.preventDefault && a.preventDefault(), this.dragStart(a));\n      },\n      onDocumentMouseUp: function (a) {\n        G[d.hoverChartIndex] && G[d.hoverChartIndex].pointer.drop(a);\n      },\n      onDocumentMouseMove: function (a) {\n        var b = this.chart,\n            c = this.chartPosition;\n        a = this.normalize(a, c);\n        !c || this.inClass(a.target, \"highcharts-tracker\") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset();\n      },\n      onContainerMouseLeave: function (a) {\n        var b = G[d.hoverChartIndex];\n        b && (a.relatedTarget || a.toElement) && (b.pointer.reset(), b.pointer.chartPosition = null);\n      },\n      onContainerMouseMove: function (a) {\n        var b = this.chart;\n        D(d.hoverChartIndex) && G[d.hoverChartIndex] && G[d.hoverChartIndex].mouseIsDown || (d.hoverChartIndex = b.index);\n        a = this.normalize(a);\n        a.preventDefault || (a.returnValue = !1);\n        \"mousedown\" === b.mouseIsDown && this.drag(a);\n        !this.inClass(a.target, \"highcharts-tracker\") && !b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || b.openMenu || this.runPointActions(a);\n      },\n      inClass: function (a, b) {\n        for (var c; a;) {\n          if (c = w(a, \"class\")) {\n            if (-1 !== c.indexOf(b)) return !0;\n            if (-1 !== c.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          a = a.parentNode;\n        }\n      },\n      onTrackerMouseOut: function (a) {\n        var b = this.chart.hoverSeries;\n        a = a.relatedTarget || a.toElement;\n        this.isDirectTouch = !1;\n        if (!(!b || !a || b.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + b.index) && this.inClass(a, \"highcharts-tracker\"))) b.onMouseOut();\n      },\n      onContainerClick: function (a) {\n        var b = this.chart,\n            d = b.hoverPoint,\n            f = b.plotLeft,\n            m = b.plotTop;\n        a = this.normalize(a);\n        b.cancelClick || (d && this.inClass(a.target, \"highcharts-tracker\") ? (c(d.series, \"click\", p(a, {\n          point: d\n        })), b.hoverPoint && d.firePointEvent(\"click\", a)) : (p(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - f, a.chartY - m) && c(b, \"click\", a)));\n      },\n      setDOMEvents: function () {\n        var a = this,\n            b = a.chart.container,\n            c = b.ownerDocument;\n\n        b.onmousedown = function (b) {\n          a.onContainerMouseDown(b);\n        };\n\n        b.onmousemove = function (b) {\n          a.onContainerMouseMove(b);\n        };\n\n        b.onclick = function (b) {\n          a.onContainerClick(b);\n        };\n\n        this.unbindContainerMouseLeave = t(b, \"mouseleave\", a.onContainerMouseLeave);\n        d.unbindDocumentMouseUp || (d.unbindDocumentMouseUp = t(c, \"mouseup\", a.onDocumentMouseUp));\n        d.hasTouch && (t(b, \"touchstart\", function (b) {\n          a.onContainerTouchStart(b);\n        }), t(b, \"touchmove\", function (b) {\n          a.onContainerTouchMove(b);\n        }), d.unbindDocumentTouchEnd || (d.unbindDocumentTouchEnd = t(c, \"touchend\", a.onDocumentTouchEnd)));\n      },\n      destroy: function () {\n        var a = this;\n        a.unDocMouseMove && a.unDocMouseMove();\n        this.unbindContainerMouseLeave();\n        d.chartCount || (d.unbindDocumentMouseUp && (d.unbindDocumentMouseUp = d.unbindDocumentMouseUp()), d.unbindDocumentTouchEnd && (d.unbindDocumentTouchEnd = d.unbindDocumentTouchEnd()));\n        clearInterval(a.tooltipTimeout);\n        y(a, function (b, c) {\n          a[c] = null;\n        });\n      }\n    };\n  });\n  K(I, \"parts/TouchPointer.js\", [I[\"parts/Globals.js\"]], function (d) {\n    var k = d.charts,\n        w = d.extend,\n        D = d.noop,\n        H = d.pick;\n    w(d.Pointer.prototype, {\n      pinchTranslate: function (d, k, C, t, w, u) {\n        this.zoomHor && this.pinchTranslateDirection(!0, d, k, C, t, w, u);\n        this.zoomVert && this.pinchTranslateDirection(!1, d, k, C, t, w, u);\n      },\n      pinchTranslateDirection: function (d, k, C, t, w, u, l, p) {\n        var q = this.chart,\n            c = d ? \"x\" : \"y\",\n            a = d ? \"X\" : \"Y\",\n            b = \"chart\" + a,\n            f = d ? \"width\" : \"height\",\n            m = q[\"plot\" + (d ? \"Left\" : \"Top\")],\n            h,\n            r,\n            x = p || 1,\n            v = q.inverted,\n            n = q.bounds[d ? \"h\" : \"v\"],\n            e = 1 === k.length,\n            g = k[0][b],\n            F = C[0][b],\n            A = !e && k[1][b],\n            z = !e && C[1][b];\n\n        C = function () {\n          !e && 20 < Math.abs(g - A) && (x = p || Math.abs(F - z) / Math.abs(g - A));\n          r = (m - F) / x + g;\n          h = q[\"plot\" + (d ? \"Width\" : \"Height\")] / x;\n        };\n\n        C();\n        k = r;\n\n        if (k < n.min) {\n          k = n.min;\n          var B = !0;\n        } else k + h > n.max && (k = n.max - h, B = !0);\n\n        B ? (F -= .8 * (F - l[c][0]), e || (z -= .8 * (z - l[c][1])), C()) : l[c] = [F, z];\n        v || (u[c] = r - m, u[f] = h);\n        u = v ? 1 / x : x;\n        w[f] = h;\n        w[c] = k;\n        t[v ? d ? \"scaleY\" : \"scaleX\" : \"scale\" + a] = x;\n        t[\"translate\" + a] = u * m + (F - u * g);\n      },\n      pinch: function (d) {\n        var k = this,\n            C = k.chart,\n            t = k.pinchDown,\n            E = d.touches,\n            u = E.length,\n            l = k.lastValidTouch,\n            p = k.hasZoom,\n            q = k.selectionMarker,\n            c = {},\n            a = 1 === u && (k.inClass(d.target, \"highcharts-tracker\") && C.runTrackerClick || k.runChartClick),\n            b = {};\n        1 < u && (k.initiated = !0);\n        p && k.initiated && !a && d.preventDefault();\n        [].map.call(E, function (a) {\n          return k.normalize(a);\n        });\n        \"touchstart\" === d.type ? ([].forEach.call(E, function (a, b) {\n          t[b] = {\n            chartX: a.chartX,\n            chartY: a.chartY\n          };\n        }), l.x = [t[0].chartX, t[1] && t[1].chartX], l.y = [t[0].chartY, t[1] && t[1].chartY], C.axes.forEach(function (a) {\n          if (a.zoomEnabled) {\n            var b = C.bounds[a.horiz ? \"h\" : \"v\"],\n                c = a.minPixelPadding,\n                d = a.toPixels(Math.min(H(a.options.min, a.dataMin), a.dataMin)),\n                f = a.toPixels(Math.max(H(a.options.max, a.dataMax), a.dataMax)),\n                v = Math.max(d, f);\n            b.min = Math.min(a.pos, Math.min(d, f) - c);\n            b.max = Math.max(a.pos + a.len, v + c);\n          }\n        }), k.res = !0) : k.followTouchMove && 1 === u ? this.runPointActions(k.normalize(d)) : t.length && (q || (k.selectionMarker = q = w({\n          destroy: D,\n          touch: !0\n        }, C.plotBox)), k.pinchTranslate(t, E, c, q, b, l), k.hasPinched = p, k.scaleGroups(c, b), k.res && (k.res = !1, this.reset(!1, 0)));\n      },\n      touch: function (k, y) {\n        var C = this.chart,\n            t;\n        if (C.index !== d.hoverChartIndex) this.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        d.hoverChartIndex = C.index;\n        if (1 === k.touches.length) {\n          if (k = this.normalize(k), (t = C.isInsidePlot(k.chartX - C.plotLeft, k.chartY - C.plotTop)) && !C.openMenu) {\n            y && this.runPointActions(k);\n\n            if (\"touchmove\" === k.type) {\n              y = this.pinchDown;\n              var w = y[0] ? 4 <= Math.sqrt(Math.pow(y[0].chartX - k.chartX, 2) + Math.pow(y[0].chartY - k.chartY, 2)) : !1;\n            }\n\n            H(w, !0) && this.pinch(k);\n          } else y && this.reset();\n        } else 2 === k.touches.length && this.pinch(k);\n      },\n      onContainerTouchStart: function (d) {\n        this.zoomOption(d);\n        this.touch(d, !0);\n      },\n      onContainerTouchMove: function (d) {\n        this.touch(d);\n      },\n      onDocumentTouchEnd: function (w) {\n        k[d.hoverChartIndex] && k[d.hoverChartIndex].pointer.drop(w);\n      }\n    });\n  });\n  K(I, \"parts/MSPointer.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.objectEach,\n        D = d.addEvent,\n        H = d.charts,\n        E = d.css,\n        y = d.doc;\n    k = d.extend;\n    var C = d.noop,\n        t = d.Pointer,\n        G = d.removeEvent,\n        u = d.win,\n        l = d.wrap;\n\n    if (!d.hasTouch && (u.PointerEvent || u.MSPointerEvent)) {\n      var p = {},\n          q = !!u.PointerEvent,\n          c = function () {\n        var a = [];\n\n        a.item = function (a) {\n          return this[a];\n        };\n\n        w(p, function (b) {\n          a.push({\n            pageX: b.pageX,\n            pageY: b.pageY,\n            target: b.target\n          });\n        });\n        return a;\n      },\n          a = function (a, f, m, h) {\n        \"touch\" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !H[d.hoverChartIndex] || (h(a), h = H[d.hoverChartIndex].pointer, h[f]({\n          type: m,\n          target: a.currentTarget,\n          preventDefault: C,\n          touches: c()\n        }));\n      };\n\n      k(t.prototype, {\n        onContainerPointerDown: function (b) {\n          a(b, \"onContainerTouchStart\", \"touchstart\", function (a) {\n            p[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY,\n              target: a.currentTarget\n            };\n          });\n        },\n        onContainerPointerMove: function (b) {\n          a(b, \"onContainerTouchMove\", \"touchmove\", function (a) {\n            p[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY\n            };\n            p[a.pointerId].target || (p[a.pointerId].target = a.currentTarget);\n          });\n        },\n        onDocumentPointerUp: function (b) {\n          a(b, \"onDocumentTouchEnd\", \"touchend\", function (a) {\n            delete p[a.pointerId];\n          });\n        },\n        batchMSEvents: function (a) {\n          a(this.chart.container, q ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n          a(this.chart.container, q ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n          a(y, q ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n        }\n      });\n      l(t.prototype, \"init\", function (a, c, d) {\n        a.call(this, c, d);\n        this.hasZoom && E(c.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      });\n      l(t.prototype, \"setDOMEvents\", function (a) {\n        a.apply(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(D);\n      });\n      l(t.prototype, \"destroy\", function (a) {\n        this.batchMSEvents(G);\n        a.call(this);\n      });\n    }\n  });\n  K(I, \"parts/Legend.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.isNumber,\n        H = d.addEvent,\n        E = d.css,\n        y = d.discardElement,\n        C = d.fireEvent;\n    k = d.isFirefox;\n    var t = d.marginNames,\n        G = d.merge,\n        u = d.pick,\n        l = d.setAnimation,\n        p = d.stableSort,\n        q = d.win,\n        c = d.wrap;\n\n    d.Legend = function (a, b) {\n      this.init(a, b);\n    };\n\n    d.Legend.prototype = {\n      init: function (a, b) {\n        this.chart = a;\n        this.setOptions(b);\n        b.enabled && (this.render(), H(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = H(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      },\n      setOptions: function (a) {\n        var b = u(a.padding, 8);\n        this.options = a;\n        this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = G(this.itemStyle, a.itemHiddenStyle));\n        this.itemMarginTop = a.itemMarginTop || 0;\n        this.padding = b;\n        this.initialItemY = b - 5;\n        this.symbolWidth = u(a.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === a.layout && !this.chart.inverted;\n      },\n      update: function (a, b) {\n        var c = this.chart;\n        this.setOptions(G(!0, this.options, a));\n        this.destroy();\n        c.isDirtyLegend = c.isDirtyBox = !0;\n        u(b, !0) && c.redraw();\n        C(this, \"afterUpdate\");\n      },\n      colorizeItem: function (a, b) {\n        a.legendGroup[b ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n\n        if (!this.chart.styledMode) {\n          var c = this.options,\n              d = a.legendItem,\n              h = a.legendLine,\n              r = a.legendSymbol,\n              l = this.itemHiddenStyle.color;\n          c = b ? c.itemStyle.color : l;\n          var v = b ? a.color || l : l,\n              n = a.options && a.options.marker,\n              e = {\n            fill: v\n          };\n          d && d.css({\n            fill: c,\n            color: c\n          });\n          h && h.attr({\n            stroke: v\n          });\n          r && (n && r.isMarker && (e = a.pointAttribs(), b || (e.stroke = e.fill = l)), r.attr(e));\n        }\n\n        C(this, \"afterColorizeItem\", {\n          item: a,\n          visible: b\n        });\n      },\n      positionItems: function () {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      },\n      positionItem: function (a) {\n        var b = this.options,\n            c = b.symbolPadding;\n        b = !b.rtl;\n        var d = a._legendItemPos,\n            h = d[0];\n        d = d[1];\n        var r = a.checkbox;\n        if ((a = a.legendGroup) && a.element) a[w(a.translateY) ? \"animate\" : \"attr\"]({\n          translateX: b ? h : this.legendWidth - h - 2 * c - 4,\n          translateY: d\n        });\n        r && (r.x = h, r.y = d);\n      },\n      destroyItem: function (a) {\n        var b = a.checkbox;\n        [\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"].forEach(function (b) {\n          a[b] && (a[b] = a[b].destroy());\n        });\n        b && y(a.checkbox);\n      },\n      destroy: function () {\n        function a(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        this.getAllItems().forEach(function (b) {\n          [\"legendItem\", \"legendGroup\"].forEach(a, b);\n        });\n        \"clipRect up down pager nav box title group\".split(\" \").forEach(a, this);\n        this.display = null;\n      },\n      positionCheckboxes: function () {\n        var a = this.group && this.group.alignAttr,\n            b = this.clipHeight || this.legendHeight,\n            c = this.titleHeight;\n\n        if (a) {\n          var d = a.translateY;\n          this.allItems.forEach(function (f) {\n            var h = f.checkbox;\n\n            if (h) {\n              var m = d + c + h.y + (this.scrollOffset || 0) + 3;\n              E(h, {\n                left: a.translateX + f.checkboxOffset + h.x - 20 + \"px\",\n                top: m + \"px\",\n                display: this.proximate || m > d - 6 && m < d + b - 6 ? \"\" : \"none\"\n              });\n            }\n          }, this);\n        }\n      },\n      renderTitle: function () {\n        var a = this.options,\n            b = this.padding,\n            c = a.title,\n            d = 0;\n        c.text && (this.title || (this.title = this.chart.renderer.label(c.text, b - 3, b - 4, null, null, null, a.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), a = this.title.getBBox(), d = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: d\n        }));\n        this.titleHeight = d;\n      },\n      setText: function (a) {\n        var b = this.options;\n        a.legendItem.attr({\n          text: b.labelFormat ? d.format(b.labelFormat, a, this.chart.time) : b.labelFormatter.call(a)\n        });\n      },\n      renderItem: function (a) {\n        var b = this.chart,\n            c = b.renderer,\n            d = this.options,\n            h = this.symbolWidth,\n            r = d.symbolPadding,\n            l = this.itemStyle,\n            v = this.itemHiddenStyle,\n            n = \"horizontal\" === d.layout ? u(d.itemDistance, 20) : 0,\n            e = !d.rtl,\n            g = a.legendItem,\n            F = !a.series,\n            A = !F && a.series.drawLegendSymbol ? a.series : a,\n            z = A.options;\n        z = this.createCheckboxForItem && z && z.showCheckbox;\n        n = h + r + n + (z ? 20 : 0);\n        var B = d.useHTML,\n            p = a.options.className;\n        g || (a.legendGroup = c.g(\"legend-item\").addClass(\"highcharts-\" + A.type + \"-series highcharts-color-\" + a.colorIndex + (p ? \" \" + p : \"\") + (F ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.legendItem = g = c.text(\"\", e ? h + r : -r, this.baseline || 0, B), b.styledMode || g.css(G(a.visible ? l : v)), g.attr({\n          align: e ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.legendGroup), this.baseline || (this.fontMetrics = c.fontMetrics(b.styledMode ? 12 : l.fontSize, g), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, g.attr(\"y\", this.baseline)), this.symbolHeight = d.symbolHeight || this.fontMetrics.f, A.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, g, B));\n        z && !a.checkbox && this.createCheckboxForItem(a);\n        this.colorizeItem(a, a.visible);\n        !b.styledMode && l.width || g.css({\n          width: (d.itemWidth || this.widthOption || b.spacingBox.width) - n\n        });\n        this.setText(a);\n        b = g.getBBox();\n        a.itemWidth = a.checkboxOffset = d.itemWidth || a.legendItemWidth || b.width + n;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || b.height || this.symbolHeight);\n      },\n      layoutItem: function (a) {\n        var b = this.options,\n            c = this.padding,\n            d = \"horizontal\" === b.layout,\n            h = a.itemHeight,\n            r = b.itemMarginBottom || 0,\n            l = this.itemMarginTop,\n            v = d ? u(b.itemDistance, 20) : 0,\n            n = this.maxLegendWidth;\n        b = b.alignColumns && this.totalItemWidth > n ? this.maxItemWidth : a.itemWidth;\n        d && this.itemX - c + b > n && (this.itemX = c, this.lastLineHeight && (this.itemY += l + this.lastLineHeight + r), this.lastLineHeight = 0);\n        this.lastItemY = l + this.itemY + r;\n        this.lastLineHeight = Math.max(h, this.lastLineHeight);\n        a._legendItemPos = [this.itemX, this.itemY];\n        d ? this.itemX += b : (this.itemY += l + h + r, this.lastLineHeight = h);\n        this.offsetWidth = this.widthOption || Math.max((d ? this.itemX - c - (a.checkbox ? 0 : v) : b) + c, this.offsetWidth);\n      },\n      getAllItems: function () {\n        var a = [];\n        this.chart.series.forEach(function (b) {\n          var c = b && b.options;\n          b && u(c.showInLegend, w(c.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || (\"point\" === c.legendType ? b.data : b)));\n        });\n        C(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      },\n      getAlignment: function () {\n        var a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      },\n      adjustMargins: function (a, b) {\n        var c = this.chart,\n            d = this.options,\n            h = this.getAlignment();\n        h && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (f, m) {\n          f.test(h) && !w(a[m]) && (c[t[m]] = Math.max(c[t[m]], c.legend[(m + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][m] * d[m % 2 ? \"x\" : \"y\"] + u(d.margin, 12) + b[m] + (c.titleOffset[m] || 0)));\n        });\n      },\n      proximatePositions: function () {\n        var a = this.chart,\n            b = [],\n            c = \"left\" === this.options.align;\n        this.allItems.forEach(function (f) {\n          var h = c;\n\n          if (f.yAxis && f.points) {\n            f.xAxis.options.reversed && (h = !h);\n            var m = d.find(h ? f.points : f.points.slice(0).reverse(), function (a) {\n              return D(a.plotY);\n            });\n            h = f.legendGroup.getBBox().height;\n            var l = f.yAxis.top - a.plotTop;\n            f.visible ? (m = m ? m.plotY : f.yAxis.height, m += l - .3 * h) : m = l + f.yAxis.height;\n            b.push({\n              target: m,\n              size: h,\n              item: f\n            });\n          }\n        }, this);\n        d.distribute(b, a.plotHeight);\n        b.forEach(function (b) {\n          b.item._legendItemPos[1] = a.plotTop - a.spacing[0] + b.pos;\n        });\n      },\n      render: function () {\n        var a = this.chart,\n            b = a.renderer,\n            c = this.group,\n            m,\n            h = this.box,\n            r = this.options,\n            l = this.padding;\n        this.itemX = l;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = d.relativeLength(r.width, a.spacingBox.width - l);\n        var v = a.spacingBox.width - 2 * l - r.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (v /= 2);\n        this.maxLegendWidth = this.widthOption || v;\n        c || (this.group = c = b.g(\"legend\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = b.g().attr({\n          zIndex: 1\n        }).add(c), this.scrollGroup = b.g().add(this.contentGroup));\n        this.renderTitle();\n        v = this.getAllItems();\n        p(v, function (a, b) {\n          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);\n        });\n        r.reversed && v.reverse();\n        this.allItems = v;\n        this.display = m = !!v.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        v.forEach(this.renderItem, this);\n        v.forEach(this.layoutItem, this);\n        v = (this.widthOption || this.offsetWidth) + l;\n        var n = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        n = this.handleOverflow(n);\n        n += l;\n        h || (this.box = h = b.rect().addClass(\"highcharts-legend-box\").attr({\n          r: r.borderRadius\n        }).add(c), h.isNew = !0);\n        a.styledMode || h.attr({\n          stroke: r.borderColor,\n          \"stroke-width\": r.borderWidth || 0,\n          fill: r.backgroundColor || \"none\"\n        }).shadow(r.shadow);\n        0 < v && 0 < n && (h[h.isNew ? \"attr\" : \"animate\"](h.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: v,\n          height: n\n        }, h.strokeWidth())), h.isNew = !1);\n        h[m ? \"show\" : \"hide\"]();\n        a.styledMode && \"none\" === c.getStyle(\"display\") && (v = n = 0);\n        this.legendWidth = v;\n        this.legendHeight = n;\n        m && (b = a.spacingBox, h = b.y, /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a.titleOffset[0] ? h += a.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a.titleOffset[2] && (h -= a.titleOffset[2]), h !== b.y && (b = G(b, {\n          y: h\n        })), c.align(G(r, {\n          width: v,\n          height: n,\n          verticalAlign: this.proximate ? \"top\" : r.verticalAlign\n        }), !0, b));\n        this.proximate || this.positionItems();\n        C(this, \"afterRender\");\n      },\n      handleOverflow: function (a) {\n        var b = this,\n            c = this.chart,\n            d = c.renderer,\n            h = this.options,\n            r = h.y,\n            l = this.padding;\n        r = c.spacingBox.height + (\"top\" === h.verticalAlign ? -r : r) - l;\n\n        var v = h.maxHeight,\n            n,\n            e = this.clipRect,\n            g = h.navigation,\n            F = u(g.animation, !0),\n            A = g.arrowSize || 12,\n            z = this.nav,\n            B = this.pages,\n            p,\n            q = this.allItems,\n            k = function (a) {\n          \"number\" === typeof a ? e.attr({\n            height: a\n          }) : e && (b.clipRect = e.destroy(), b.contentGroup.clip());\n          b.contentGroup.div && (b.contentGroup.div.style.clip = a ? \"rect(\" + l + \"px,9999px,\" + (l + a) + \"px,0)\" : \"auto\");\n        },\n            t = function (a) {\n          b[a] = d.circle(0, 0, 1.3 * A).translate(A / 2, A / 2).add(z);\n          c.styledMode || b[a].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n          return b[a];\n        };\n\n        \"horizontal\" !== h.layout || \"middle\" === h.verticalAlign || h.floating || (r /= 2);\n        v && (r = Math.min(r, v));\n        B.length = 0;\n        a > r && !1 !== g.enabled ? (this.clipHeight = n = Math.max(r - 20 - this.titleHeight - l, 0), this.currentPage = u(this.currentPage, 1), this.fullHeight = a, q.forEach(function (a, b) {\n          var e = a._legendItemPos[1],\n              c = Math.round(a.legendItem.getBBox().height),\n              g = B.length;\n          if (!g || e - B[g - 1] > n && (p || e) !== B[g - 1]) B.push(p || e), g++;\n          a.pageIx = g - 1;\n          p && (q[b - 1].pageIx = g - 1);\n          b === q.length - 1 && e + c - B[g - 1] > n && e !== p && (B.push(e), a.pageIx = g);\n          e !== p && (p = e);\n        }), e || (e = b.clipRect = d.clipRect(0, l, 9999, 0), b.contentGroup.clip(e)), k(n), z || (this.nav = z = d.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = d.symbol(\"triangle\", 0, 0, A, A).add(z), t(\"upTracker\").on(\"click\", function () {\n          b.scroll(-1, F);\n        }), this.pager = d.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), c.styledMode || this.pager.css(g.style), this.pager.add(z), this.down = d.symbol(\"triangle-down\", 0, 0, A, A).add(z), t(\"downTracker\").on(\"click\", function () {\n          b.scroll(1, F);\n        })), b.scroll(0), a = r) : z && (k(), this.nav = z.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      },\n      scroll: function (a, b) {\n        var c = this.pages,\n            d = c.length,\n            h = this.currentPage + a;\n        a = this.clipHeight;\n        var r = this.options.navigation,\n            p = this.pager,\n            v = this.padding;\n        h > d && (h = d);\n        0 < h && (void 0 !== b && l(b, this.chart), this.nav.attr({\n          translateX: v,\n          translateY: a + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), [this.up, this.upTracker].forEach(function (a) {\n          a.attr({\n            \"class\": 1 === h ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), p.attr({\n          text: h + \"/\" + d\n        }), [this.down, this.downTracker].forEach(function (a) {\n          a.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": h === d ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), this.chart.styledMode || (this.up.attr({\n          fill: 1 === h ? r.inactiveColor : r.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === h ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: h === d ? r.inactiveColor : r.activeColor\n        }), this.downTracker.css({\n          cursor: h === d ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -c[h - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = h, this.positionCheckboxes());\n      }\n    };\n    d.LegendSymbolMixin = {\n      drawRectangle: function (a, b) {\n        var c = a.symbolHeight,\n            d = a.options.squareSymbol;\n        b.legendSymbol = this.chart.renderer.rect(d ? (a.symbolWidth - c) / 2 : 0, a.baseline - c + 1, d ? c : a.symbolWidth, c, u(a.options.symbolRadius, c / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(b.legendGroup);\n      },\n      drawLineMarker: function (a) {\n        var b = this.options,\n            c = b.marker,\n            d = a.symbolWidth,\n            h = a.symbolHeight,\n            r = h / 2,\n            l = this.chart.renderer,\n            v = this.legendGroup;\n        a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n        var n = {};\n        this.chart.styledMode || (n = {\n          \"stroke-width\": b.lineWidth || 0\n        }, b.dashStyle && (n.dashstyle = b.dashStyle));\n        this.legendLine = l.path([\"M\", 0, a, \"L\", d, a]).addClass(\"highcharts-graph\").attr(n).add(v);\n        c && !1 !== c.enabled && d && (b = Math.min(u(c.radius, r), r), 0 === this.symbol.indexOf(\"url\") && (c = G(c, {\n          width: h,\n          height: h\n        }), b = 0), this.legendSymbol = c = l.symbol(this.symbol, d / 2 - b, a - b, 2 * b, 2 * b, c).addClass(\"highcharts-point\").add(v), c.isMarker = !0);\n      }\n    };\n    (/Trident\\/7\\.0/.test(q.navigator && q.navigator.userAgent) || k) && c(d.Legend.prototype, \"positionItem\", function (a, b) {\n      var c = this,\n          d = function () {\n        b._legendItemPos && a.call(c, b);\n      };\n\n      d();\n      c.bubbleLegend || setTimeout(d);\n    });\n  });\n  K(I, \"parts/Chart.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.attr,\n        D = k.defined,\n        H = k.erase,\n        E = k.isArray,\n        y = k.isNumber,\n        C = k.isObject,\n        t = k.isString,\n        G = k.objectEach,\n        u = k.pInt,\n        l = k.splat,\n        p = d.addEvent,\n        q = d.animate,\n        c = d.animObject,\n        a = d.doc,\n        b = d.Axis,\n        f = d.createElement,\n        m = d.defaultOptions,\n        h = d.discardElement,\n        r = d.charts,\n        x = d.css,\n        v = d.extend,\n        n = d.find,\n        e = d.fireEvent,\n        g = d.Legend,\n        F = d.marginNames,\n        A = d.merge,\n        z = d.Pointer,\n        B = d.pick,\n        J = d.removeEvent,\n        M = d.seriesTypes,\n        T = d.syncTimeout,\n        N = d.win,\n        R = d.Chart = function () {\n      this.getArgs.apply(this, arguments);\n    };\n\n    d.chart = function (a, b, e) {\n      return new R(a, b, e);\n    };\n\n    v(R.prototype, {\n      callbacks: [],\n      getArgs: function () {\n        var a = [].slice.call(arguments);\n        if (t(a[0]) || a[0].nodeName) this.renderTo = a.shift();\n        this.init(a[0], a[1]);\n      },\n      init: function (a, b) {\n        var c,\n            g = a.series,\n            f = a.plotOptions || {};\n        e(this, \"init\", {\n          args: arguments\n        }, function () {\n          a.series = null;\n          c = A(m, a);\n          G(c.plotOptions, function (a, b) {\n            C(a) && (a.tooltip = f[b] && A(f[b].tooltip) || void 0);\n          });\n          c.tooltip.userOptions = a.chart && a.chart.forExport && a.tooltip.userOptions || a.tooltip;\n          c.series = a.series = g;\n          this.userOptions = a;\n          var h = c.chart,\n              n = h.events;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = b;\n          this.isResizing = 0;\n          this.options = c;\n          this.axes = [];\n          this.series = [];\n          this.time = a.time && Object.keys(a.time).length ? new d.Time(a.time) : d.time;\n          this.styledMode = h.styledMode;\n          this.hasCartesianSeries = h.showAxes;\n          var F = this;\n          F.index = r.length;\n          r.push(F);\n          d.chartCount++;\n          n && G(n, function (a, b) {\n            d.isFunction(a) && p(F, b, a);\n          });\n          F.xAxis = [];\n          F.yAxis = [];\n          F.pointCount = F.colorCounter = F.symbolCounter = 0;\n          e(F, \"afterInit\");\n          F.firstRender();\n        });\n      },\n      initSeries: function (a) {\n        var b = this.options.chart;\n        (b = M[a.type || b.type || b.defaultSeriesType]) || d.error(17, !0, this);\n        b = new b();\n        b.init(this, a);\n        return b;\n      },\n      orderSeries: function (a) {\n        var b = this.series;\n\n        for (a = a || 0; a < b.length; a++) b[a] && (b[a].index = a, b[a].name = b[a].getName());\n      },\n      isInsidePlot: function (a, b, e) {\n        var c = e ? b : a;\n        a = e ? a : b;\n        return 0 <= c && c <= this.plotWidth && 0 <= a && a <= this.plotHeight;\n      },\n      redraw: function (a) {\n        e(this, \"beforeRedraw\");\n        var b = this.axes,\n            c = this.series,\n            g = this.pointer,\n            f = this.legend,\n            h = this.userOptions.legend,\n            n = this.isDirtyLegend,\n            A = this.hasCartesianSeries,\n            F = this.isDirtyBox,\n            m = this.renderer,\n            z = m.isHidden(),\n            B = [];\n        this.setResponsive && this.setResponsive(!1);\n        d.setAnimation(a, this);\n        z && this.temporaryDisplay();\n        this.layOutTitles();\n\n        for (a = c.length; a--;) {\n          var r = c[a];\n\n          if (r.options.stacking) {\n            var l = !0;\n\n            if (r.isDirty) {\n              var p = !0;\n              break;\n            }\n          }\n        }\n\n        if (p) for (a = c.length; a--;) r = c[a], r.options.stacking && (r.isDirty = !0);\n        c.forEach(function (a) {\n          a.isDirty && (\"point\" === a.options.legendType ? (a.updateTotals && a.updateTotals(), n = !0) : h && (h.labelFormatter || h.labelFormat) && (n = !0));\n          a.isDirtyData && e(a, \"updatedData\");\n        });\n        n && f && f.options.enabled && (f.render(), this.isDirtyLegend = !1);\n        l && this.getStacks();\n        A && b.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        });\n        this.getMargins();\n        A && (b.forEach(function (a) {\n          a.isDirty && (F = !0);\n        }), b.forEach(function (a) {\n          var b = a.min + \",\" + a.max;\n          a.extKey !== b && (a.extKey = b, B.push(function () {\n            e(a, \"afterSetExtremes\", v(a.eventArgs, a.getExtremes()));\n            delete a.eventArgs;\n          }));\n          (F || l) && a.redraw();\n        }));\n        F && this.drawChartBox();\n        e(this, \"predraw\");\n        c.forEach(function (a) {\n          (F || a.isDirty) && a.visible && a.redraw();\n          a.isDirtyData = !1;\n        });\n        g && g.reset(!0);\n        m.draw();\n        e(this, \"redraw\");\n        e(this, \"render\");\n        z && this.temporaryDisplay(!0);\n        B.forEach(function (a) {\n          a.call();\n        });\n      },\n      get: function (a) {\n        function b(b) {\n          return b.id === a || b.options && b.options.id === a;\n        }\n\n        var e = this.series,\n            c;\n        var g = n(this.axes, b) || n(this.series, b);\n\n        for (c = 0; !g && c < e.length; c++) g = n(e[c].points || [], b);\n\n        return g;\n      },\n      getAxes: function () {\n        var a = this,\n            c = this.options,\n            g = c.xAxis = l(c.xAxis || {});\n        c = c.yAxis = l(c.yAxis || {});\n        e(this, \"getAxes\");\n        g.forEach(function (a, b) {\n          a.index = b;\n          a.isX = !0;\n        });\n        c.forEach(function (a, b) {\n          a.index = b;\n        });\n        g.concat(c).forEach(function (e) {\n          new b(a, e);\n        });\n        e(this, \"afterGetAxes\");\n      },\n      getSelectedPoints: function () {\n        var a = [];\n        this.series.forEach(function (b) {\n          a = a.concat((b[b.hasGroupedData ? \"points\" : \"data\"] || []).filter(function (a) {\n            return B(a.selectedStaging, a.selected);\n          }));\n        });\n        return a;\n      },\n      getSelectedSeries: function () {\n        return this.series.filter(function (a) {\n          return a.selected;\n        });\n      },\n      setTitle: function (a, b, e) {\n        this.applyDescription(\"title\", a);\n        this.applyDescription(\"subtitle\", b);\n        this.applyDescription(\"caption\", void 0);\n        this.layOutTitles(e);\n      },\n      applyDescription: function (a, b) {\n        var e = this,\n            c = \"title\" === a ? {\n          color: \"#333333\",\n          fontSize: this.options.isStock ? \"16px\" : \"18px\"\n        } : {\n          color: \"#666666\"\n        };\n        c = this.options[a] = A(!this.styledMode && {\n          style: c\n        }, this.options[a], b);\n        var g = this[a];\n        g && b && (this[a] = g = g.destroy());\n        c && !g && (g = this.renderer.text(c.text, 0, 0, c.useHTML).attr({\n          align: c.align,\n          \"class\": \"highcharts-\" + a,\n          zIndex: c.zIndex || 4\n        }).add(), g.update = function (b) {\n          e[{\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          }[a]](b);\n        }, this.styledMode || g.css(c.style), this[a] = g);\n      },\n      layOutTitles: function (a) {\n        var b = [0, 0, 0],\n            e = this.renderer,\n            c = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (a) {\n          var g = this[a],\n              d = this.options[a],\n              f = d.verticalAlign || \"top\";\n          a = \"title\" === a ? -3 : \"top\" === f ? b[0] + 2 : 0;\n\n          if (g) {\n            if (!this.styledMode) var h = d.style.fontSize;\n            h = e.fontMetrics(h, g).b;\n            g.css({\n              width: (d.width || c.width + (d.widthAdjust || 0)) + \"px\"\n            });\n            var n = g.getBBox(d.useHTML).height;\n            g.align(v({\n              y: \"bottom\" === f ? h : a + h,\n              height: n\n            }, d), !1, \"spacingBox\");\n            d.floating || (\"top\" === f ? b[0] = Math.ceil(b[0] + n) : \"bottom\" === f && (b[2] = Math.ceil(b[2] + n)));\n          }\n        }, this);\n        b[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (b[0] += this.options.title.margin);\n        b[2] && \"bottom\" === this.options.caption.verticalAlign && (b[2] += this.options.caption.margin);\n        var g = !this.titleOffset || this.titleOffset.join(\",\") !== b.join(\",\");\n        this.titleOffset = b;\n        !this.isDirtyBox && g && (this.isDirtyBox = this.isDirtyLegend = g, this.hasRendered && B(a, !0) && this.isDirtyBox && this.redraw());\n      },\n      getChartSize: function () {\n        var a = this.options.chart,\n            b = a.width;\n        a = a.height;\n        var e = this.renderTo;\n        D(b) || (this.containerWidth = d.getStyle(e, \"width\"));\n        D(a) || (this.containerHeight = d.getStyle(e, \"height\"));\n        this.chartWidth = Math.max(0, b || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, d.relativeLength(a, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      },\n      temporaryDisplay: function (b) {\n        var e = this.renderTo;\n        if (b) for (; e && e.style;) e.hcOrigStyle && (d.css(e, e.hcOrigStyle), delete e.hcOrigStyle), e.hcOrigDetached && (a.body.removeChild(e), e.hcOrigDetached = !1), e = e.parentNode;else for (; e && e.style;) {\n          a.body.contains(e) || e.parentNode || (e.hcOrigDetached = !0, a.body.appendChild(e));\n          if (\"none\" === d.getStyle(e, \"display\", !1) || e.hcOricDetached) e.hcOrigStyle = {\n            display: e.style.display,\n            height: e.style.height,\n            overflow: e.style.overflow\n          }, b = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, e !== this.renderTo && (b.height = 0), d.css(e, b), e.offsetWidth || e.style.setProperty(\"display\", \"block\", \"important\");\n          e = e.parentNode;\n          if (e === a.body) break;\n        }\n      },\n      setClassName: function (a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      },\n      getContainer: function () {\n        var b = this.options,\n            c = b.chart;\n        var g = this.renderTo;\n        var h = d.uniqueKey(),\n            n,\n            A;\n        g || (this.renderTo = g = c.renderTo);\n        t(g) && (this.renderTo = g = a.getElementById(g));\n        g || d.error(13, !0, this);\n        var F = u(w(g, \"data-highcharts-chart\"));\n        y(F) && r[F] && r[F].hasRendered && r[F].destroy();\n        w(g, \"data-highcharts-chart\", this.index);\n        g.innerHTML = \"\";\n        c.skipClone || g.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        F = this.chartWidth;\n        var m = this.chartHeight;\n        x(g, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (n = v({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: F + \"px\",\n          height: m + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\"\n        }, c.style));\n        this.container = g = f(\"div\", {\n          id: h\n        }, n, g);\n        this._cursor = g.style.cursor;\n        this.renderer = new (d[c.renderer] || d.Renderer)(g, F, m, null, c.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);\n        this.setClassName(c.className);\n        if (this.styledMode) for (A in b.defs) this.renderer.definition(b.defs[A]);else this.renderer.setStyle(c.style);\n        this.renderer.chartIndex = this.index;\n        e(this, \"afterGetContainer\");\n      },\n      getMargins: function (a) {\n        var b = this.spacing,\n            c = this.margin,\n            g = this.titleOffset;\n        this.resetMargins();\n        g[0] && !D(c[0]) && (this.plotTop = Math.max(this.plotTop, g[0] + b[0]));\n        g[2] && !D(c[2]) && (this.marginBottom = Math.max(this.marginBottom, g[2] + b[2]));\n        this.legend && this.legend.display && this.legend.adjustMargins(c, b);\n        e(this, \"getMargins\");\n        a || this.getAxisMargins();\n      },\n      getAxisMargins: function () {\n        var a = this,\n            b = a.axisOffset = [0, 0, 0, 0],\n            e = a.colorAxis,\n            c = a.margin,\n            g = function (a) {\n          a.forEach(function (a) {\n            a.visible && a.getOffset();\n          });\n        };\n\n        a.hasCartesianSeries ? g(a.axes) : e && e.length && g(e);\n        F.forEach(function (e, g) {\n          D(c[g]) || (a[e] += b[g]);\n        });\n        a.setChartSize();\n      },\n      reflow: function (b) {\n        var e = this,\n            c = e.options.chart,\n            g = e.renderTo,\n            f = D(c.width) && D(c.height),\n            h = c.width || d.getStyle(g, \"width\");\n        c = c.height || d.getStyle(g, \"height\");\n        g = b ? b.target : N;\n\n        if (!f && !e.isPrinting && h && c && (g === N || g === a)) {\n          if (h !== e.containerWidth || c !== e.containerHeight) d.clearTimeout(e.reflowTimeout), e.reflowTimeout = T(function () {\n            e.container && e.setSize(void 0, void 0, !1);\n          }, b ? 100 : 0);\n          e.containerWidth = h;\n          e.containerHeight = c;\n        }\n      },\n      setReflow: function (a) {\n        var b = this;\n        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = p(N, \"resize\", function (a) {\n          b.options && b.reflow(a);\n        }), p(this, \"destroy\", this.unbindReflow));\n      },\n      setSize: function (a, b, g) {\n        var f = this,\n            h = f.renderer;\n        f.isResizing += 1;\n        d.setAnimation(g, f);\n        f.oldChartHeight = f.chartHeight;\n        f.oldChartWidth = f.chartWidth;\n        void 0 !== a && (f.options.chart.width = a);\n        void 0 !== b && (f.options.chart.height = b);\n        f.getChartSize();\n\n        if (!f.styledMode) {\n          var n = h.globalAnimation;\n          (n ? q : x)(f.container, {\n            width: f.chartWidth + \"px\",\n            height: f.chartHeight + \"px\"\n          }, n);\n        }\n\n        f.setChartSize(!0);\n        h.setSize(f.chartWidth, f.chartHeight, g);\n        f.axes.forEach(function (a) {\n          a.isDirty = !0;\n          a.setScale();\n        });\n        f.isDirtyLegend = !0;\n        f.isDirtyBox = !0;\n        f.layOutTitles();\n        f.getMargins();\n        f.redraw(g);\n        f.oldChartHeight = null;\n        e(f, \"resize\");\n        T(function () {\n          f && e(f, \"endResize\", null, function () {\n            --f.isResizing;\n          });\n        }, c(n).duration);\n      },\n      setChartSize: function (a) {\n        var b = this.inverted,\n            c = this.renderer,\n            g = this.chartWidth,\n            d = this.chartHeight,\n            f = this.options.chart,\n            h = this.spacing,\n            n = this.clipOffset,\n            A,\n            F,\n            m,\n            z;\n        this.plotLeft = A = Math.round(this.plotLeft);\n        this.plotTop = F = Math.round(this.plotTop);\n        this.plotWidth = m = Math.max(0, Math.round(g - A - this.marginRight));\n        this.plotHeight = z = Math.max(0, Math.round(d - F - this.marginBottom));\n        this.plotSizeX = b ? z : m;\n        this.plotSizeY = b ? m : z;\n        this.plotBorderWidth = f.plotBorderWidth || 0;\n        this.spacingBox = c.spacingBox = {\n          x: h[3],\n          y: h[0],\n          width: g - h[3] - h[1],\n          height: d - h[0] - h[2]\n        };\n        this.plotBox = c.plotBox = {\n          x: A,\n          y: F,\n          width: m,\n          height: z\n        };\n        g = 2 * Math.floor(this.plotBorderWidth / 2);\n        b = Math.ceil(Math.max(g, n[3]) / 2);\n        c = Math.ceil(Math.max(g, n[0]) / 2);\n        this.clipBox = {\n          x: b,\n          y: c,\n          width: Math.floor(this.plotSizeX - Math.max(g, n[1]) / 2 - b),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(g, n[2]) / 2 - c))\n        };\n        a || this.axes.forEach(function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        });\n        e(this, \"afterSetChartSize\", {\n          skipAxes: a\n        });\n      },\n      resetMargins: function () {\n        e(this, \"resetMargins\");\n        var a = this,\n            b = a.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (e) {\n          var c = b[e],\n              g = C(c) ? c : [c, c, c, c];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (c, d) {\n            a[e][d] = B(b[e + c], g[d]);\n          });\n        });\n        F.forEach(function (b, e) {\n          a[b] = B(a.margin[e], a.spacing[e]);\n        });\n        a.axisOffset = [0, 0, 0, 0];\n        a.clipOffset = [0, 0, 0, 0];\n      },\n      drawChartBox: function () {\n        var a = this.options.chart,\n            b = this.renderer,\n            c = this.chartWidth,\n            g = this.chartHeight,\n            d = this.chartBackground,\n            f = this.plotBackground,\n            h = this.plotBorder,\n            n = this.styledMode,\n            A = this.plotBGImage,\n            F = a.backgroundColor,\n            m = a.plotBackgroundColor,\n            z = a.plotBackgroundImage,\n            B,\n            r = this.plotLeft,\n            l = this.plotTop,\n            v = this.plotWidth,\n            p = this.plotHeight,\n            x = this.plotBox,\n            J = this.clipRect,\n            q = this.clipBox,\n            u = \"animate\";\n        d || (this.chartBackground = d = b.rect().addClass(\"highcharts-background\").add(), u = \"attr\");\n        if (n) var k = B = d.strokeWidth();else {\n          k = a.borderWidth || 0;\n          B = k + (a.shadow ? 8 : 0);\n          F = {\n            fill: F || \"none\"\n          };\n          if (k || d[\"stroke-width\"]) F.stroke = a.borderColor, F[\"stroke-width\"] = k;\n          d.attr(F).shadow(a.shadow);\n        }\n        d[u]({\n          x: B / 2,\n          y: B / 2,\n          width: c - B - k % 2,\n          height: g - B - k % 2,\n          r: a.borderRadius\n        });\n        u = \"animate\";\n        f || (u = \"attr\", this.plotBackground = f = b.rect().addClass(\"highcharts-plot-background\").add());\n        f[u](x);\n        n || (f.attr({\n          fill: m || \"none\"\n        }).shadow(a.plotShadow), z && (A ? A.animate(x) : this.plotBGImage = b.image(z, r, l, v, p).add()));\n        J ? J.animate({\n          width: q.width,\n          height: q.height\n        }) : this.clipRect = b.clipRect(q);\n        u = \"animate\";\n        h || (u = \"attr\", this.plotBorder = h = b.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        n || h.attr({\n          stroke: a.plotBorderColor,\n          \"stroke-width\": a.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        h[u](h.crisp({\n          x: r,\n          y: l,\n          width: v,\n          height: p\n        }, -h.strokeWidth()));\n        this.isDirtyBox = !1;\n        e(this, \"afterDrawChartBox\");\n      },\n      propFromSeries: function () {\n        var a = this,\n            b = a.options.chart,\n            e,\n            c = a.options.series,\n            g,\n            d;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (f) {\n          e = M[b.type || b.defaultSeriesType];\n          d = b[f] || e && e.prototype[f];\n\n          for (g = c && c.length; !d && g--;) (e = M[c[g].type]) && e.prototype[f] && (d = !0);\n\n          a[f] = d;\n        });\n      },\n      linkSeries: function () {\n        var a = this,\n            b = a.series;\n        b.forEach(function (a) {\n          a.linkedSeries.length = 0;\n        });\n        b.forEach(function (b) {\n          var e = b.options.linkedTo;\n          t(e) && (e = \":previous\" === e ? a.series[b.index - 1] : a.get(e)) && e.linkedParent !== b && (e.linkedSeries.push(b), b.linkedParent = e, b.visible = B(b.options.visible, e.options.visible, b.visible));\n        });\n        e(this, \"afterLinkSeries\");\n      },\n      renderSeries: function () {\n        this.series.forEach(function (a) {\n          a.translate();\n          a.render();\n        });\n      },\n      renderLabels: function () {\n        var a = this,\n            b = a.options.labels;\n        b.items && b.items.forEach(function (e) {\n          var c = v(b.style, e.style),\n              g = u(c.left) + a.plotLeft,\n              d = u(c.top) + a.plotTop + 12;\n          delete c.left;\n          delete c.top;\n          a.renderer.text(e.html, g, d).attr({\n            zIndex: 2\n          }).css(c).add();\n        });\n      },\n      render: function () {\n        var a = this.axes,\n            b = this.colorAxis,\n            e = this.renderer,\n            c = this.options,\n            d = 0,\n            f = function (a) {\n          a.forEach(function (a) {\n            a.visible && a.render();\n          });\n        };\n\n        this.setTitle();\n        this.legend = new g(this, c.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        c = this.plotWidth;\n        a.some(function (a) {\n          if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return d = 21, !0;\n        });\n        var h = this.plotHeight = Math.max(this.plotHeight - d, 0);\n        a.forEach(function (a) {\n          a.setScale();\n        });\n        this.getAxisMargins();\n        var n = 1.1 < c / this.plotWidth;\n        var A = 1.05 < h / this.plotHeight;\n        if (n || A) a.forEach(function (a) {\n          (a.horiz && n || !a.horiz && A) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries ? f(a) : b && b.length && f(b);\n        this.seriesGroup || (this.seriesGroup = e.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.updateContainerScaling();\n        this.hasRendered = !0;\n      },\n      addCredits: function (a) {\n        var b = this;\n        a = A(!0, this.options.credits, a);\n        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          a.href && (N.location.href = a.href);\n        }).attr({\n          align: a.position.align,\n          zIndex: 8\n        }), b.styledMode || this.credits.css(a.style), this.credits.add().align(a.position), this.credits.update = function (a) {\n          b.credits = b.credits.destroy();\n          b.addCredits(a);\n        });\n      },\n      updateContainerScaling: function () {\n        var a = this.container;\n\n        if (a.offsetWidth && a.offsetHeight && a.getBoundingClientRect) {\n          var b = a.getBoundingClientRect(),\n              e = b.width / a.offsetWidth;\n          a = b.height / a.offsetHeight;\n          1 !== e || 1 !== a ? this.containerScaling = {\n            scaleX: e,\n            scaleY: a\n          } : delete this.containerScaling;\n        }\n      },\n      destroy: function () {\n        var a = this,\n            b = a.axes,\n            c = a.series,\n            g = a.container,\n            f,\n            n = g && g.parentNode;\n        e(a, \"destroy\");\n        a.renderer.forExport ? H(r, a) : r[a.index] = void 0;\n        d.chartCount--;\n        a.renderTo.removeAttribute(\"data-highcharts-chart\");\n        J(a);\n\n        for (f = b.length; f--;) b[f] = b[f].destroy();\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (f = c.length; f--;) c[f] = c[f].destroy();\n\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (b) {\n          var e = a[b];\n          e && e.destroy && (a[b] = e.destroy());\n        });\n        g && (g.innerHTML = \"\", J(g), n && h(g));\n        G(a, function (b, e) {\n          delete a[e];\n        });\n      },\n      firstRender: function () {\n        var a = this,\n            b = a.options;\n\n        if (!a.isReadyToRender || a.isReadyToRender()) {\n          a.getContainer();\n          a.resetMargins();\n          a.setChartSize();\n          a.propFromSeries();\n          a.getAxes();\n          (E(b.series) ? b.series : []).forEach(function (b) {\n            a.initSeries(b);\n          });\n          a.linkSeries();\n          e(a, \"beforeRender\");\n          z && (a.pointer = new z(a, b));\n          a.render();\n          if (!a.renderer.imgCount && a.onload) a.onload();\n          a.temporaryDisplay(!0);\n        }\n      },\n      onload: function () {\n        this.callbacks.concat([this.callback]).forEach(function (a) {\n          a && void 0 !== this.index && a.apply(this, [this]);\n        }, this);\n        e(this, \"load\");\n        e(this, \"render\");\n        D(this.index) && this.setReflow(this.options.chart.reflow);\n        this.onload = null;\n      }\n    });\n  });\n  K(I, \"parts/ScrollablePlotArea.js\", [I[\"parts/Globals.js\"]], function (d) {\n    var k = d.addEvent,\n        w = d.Chart;\n    \"\";\n    k(w, \"afterSetChartSize\", function (k) {\n      var w = this.options.chart.scrollablePlotArea,\n          E = w && w.minWidth;\n      w = w && w.minHeight;\n\n      if (!this.renderer.forExport) {\n        if (E) {\n          if (this.scrollablePixelsX = E = Math.max(0, E - this.chartWidth)) {\n            this.plotWidth += E;\n            this.inverted ? (this.clipBox.height += E, this.plotBox.height += E) : (this.clipBox.width += E, this.plotBox.width += E);\n            var y = {\n              1: {\n                name: \"right\",\n                value: E\n              }\n            };\n          }\n        } else w && (this.scrollablePixelsY = E = Math.max(0, w - this.chartHeight)) && (this.plotHeight += E, this.inverted ? (this.clipBox.width += E, this.plotBox.width += E) : (this.clipBox.height += E, this.plotBox.height += E), y = {\n          2: {\n            name: \"bottom\",\n            value: E\n          }\n        });\n\n        y && !k.skipAxes && this.axes.forEach(function (k) {\n          y[k.side] ? k.getPlotLinePath = function () {\n            var t = y[k.side].name,\n                C = this[t];\n            this[t] = C - y[k.side].value;\n            var u = d.Axis.prototype.getPlotLinePath.apply(this, arguments);\n            this[t] = C;\n            return u;\n          } : (k.setAxisSize(), k.setAxisTranslation());\n        });\n      }\n    });\n    k(w, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    w.prototype.setUpScrolling = function () {\n      var k = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (k.overflowX = \"auto\");\n      this.scrollablePixelsY && (k.overflowY = \"auto\");\n      this.scrollingContainer = d.createElement(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, k, this.renderTo);\n      this.innerContainer = d.createElement(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    w.prototype.moveFixedElements = function () {\n      var d = this.container,\n          k = this.fixedRenderer,\n          w = \".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-reset-zoom .highcharts-subtitle .highcharts-title .highcharts-legend-checkbox\".split(\" \"),\n          y;\n      this.scrollablePixelsX && !this.inverted ? y = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? y = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? y = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (y = \".highcharts-yaxis\");\n      w.push(y, y + \"-labels\");\n      w.forEach(function (y) {\n        [].forEach.call(d.querySelectorAll(y), function (d) {\n          (d.namespaceURI === k.SVG_NS ? k.box : k.box.parentNode).appendChild(d);\n          d.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n\n    w.prototype.applyFixed = function () {\n      var w,\n          H = !this.fixedDiv,\n          E = this.options.chart.scrollablePlotArea;\n      H ? (this.fixedDiv = d.createElement(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: 2\n      }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = w = new d.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight), this.scrollableMask = w.path().attr({\n        fill: d.color(this.options.chart.backgroundColor || \"#fff\").setOpacity(d.pick(E.opacity, .85)).get(),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), this.moveFixedElements(), k(this, \"afterShowResetZoom\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      w = this.chartWidth + (this.scrollablePixelsX || 0);\n      var y = this.chartHeight + (this.scrollablePixelsY || 0);\n      d.stop(this.container);\n      this.container.style.width = w + \"px\";\n      this.container.style.height = y + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: w,\n        height: y,\n        viewBox: [0, 0, w, y].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: w,\n        height: y\n      });\n      this.scrollablePixelsY && (this.scrollingContainer.style.height = this.chartHeight + \"px\");\n      H && (E.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * E.scrollPositionX), E.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * E.scrollPositionY));\n      y = this.axisOffset;\n      H = this.plotTop - y[0] - 1;\n      E = this.plotLeft - y[3] - 1;\n      w = this.plotTop + this.plotHeight + y[2] + 1;\n      y = this.plotLeft + this.plotWidth + y[1] + 1;\n      var C = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n          t = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      H = this.scrollablePixelsX ? [\"M\", 0, H, \"L\", this.plotLeft - 1, H, \"L\", this.plotLeft - 1, w, \"L\", 0, w, \"Z\", \"M\", C, H, \"L\", this.chartWidth, H, \"L\", this.chartWidth, w, \"L\", C, w, \"Z\"] : this.scrollablePixelsY ? [\"M\", E, 0, \"L\", E, this.plotTop - 1, \"L\", y, this.plotTop - 1, \"L\", y, 0, \"Z\", \"M\", E, t, \"L\", E, this.chartHeight, \"L\", y, this.chartHeight, \"L\", y, t, \"Z\"] : [\"M\", 0, 0];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: H\n      });\n    };\n  });\n  K(I, \"parts/Point.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.erase,\n        H = k.isArray,\n        E = k.isNumber,\n        y = k.isObject,\n        C,\n        t = d.extend,\n        G = d.fireEvent,\n        u = d.format,\n        l = d.pick,\n        p = d.uniqueKey,\n        q = d.removeEvent;\n\n    d.Point = C = function () {};\n\n    d.Point.prototype = {\n      init: function (c, a, b) {\n        this.series = c;\n        this.applyOptions(a, b);\n        this.id = w(this.id) ? this.id : p();\n        this.resolveColor();\n        c.chart.pointCount++;\n        G(this, \"afterInit\");\n        return this;\n      },\n      resolveColor: function () {\n        var c = this.series;\n        var a = c.chart.options.chart.colorCount;\n        var b = c.chart.styledMode;\n        b || this.options.color || (this.color = c.color);\n        c.options.colorByPoint ? (b || (a = c.options.colors || c.chart.options.colors, this.color = this.color || a[c.colorCounter], a = a.length), b = c.colorCounter, c.colorCounter++, c.colorCounter === a && (c.colorCounter = 0)) : b = c.colorIndex;\n        this.colorIndex = l(this.colorIndex, b);\n      },\n      applyOptions: function (c, a) {\n        var b = this.series,\n            d = b.options.pointValKey || b.pointValKey;\n        c = C.prototype.optionsToObject.call(this, c);\n        t(this, c);\n        this.options = this.options ? t(this.options, c) : c;\n        c.group && delete this.group;\n        c.dataLabels && delete this.dataLabels;\n        d && (this.y = this[d]);\n        this.formatPrefix = (this.isNull = l(this.isValid && !this.isValid(), null === this.x || !E(this.y))) ? \"null\" : \"point\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && void 0 === a && b.xAxis && b.xAxis.hasNames && (this.x = b.xAxis.nameToX(this));\n        void 0 === this.x && b && (this.x = void 0 === a ? b.autoIncrement(this) : a);\n        return this;\n      },\n      setNestedProperty: function (c, a, b) {\n        b.split(\".\").reduce(function (b, c, d, r) {\n          b[c] = r.length - 1 === d ? a : y(b[c], !0) ? b[c] : {};\n          return b[c];\n        }, c);\n        return c;\n      },\n      optionsToObject: function (c) {\n        var a = {},\n            b = this.series,\n            f = b.options.keys,\n            m = f || b.pointArrayMap || [\"y\"],\n            h = m.length,\n            r = 0,\n            l = 0;\n        if (E(c) || null === c) a[m[0]] = c;else if (H(c)) for (!f && c.length > h && (b = typeof c[0], \"string\" === b ? a.name = c[0] : \"number\" === b && (a.x = c[0]), r++); l < h;) f && void 0 === c[r] || (0 < m[l].indexOf(\".\") ? d.Point.prototype.setNestedProperty(a, c[r], m[l]) : a[m[l]] = c[r]), r++, l++;else \"object\" === typeof c && (a = c, c.dataLabels && (b._hasPointLabels = !0), c.marker && (b._hasPointMarkers = !0));\n        return a;\n      },\n      getClassName: function () {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      },\n      getZone: function () {\n        var c = this.series,\n            a = c.zones;\n        c = c.zoneAxis || \"y\";\n        var b = 0,\n            d;\n\n        for (d = a[b]; this[c] >= d.value;) d = a[++b];\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = d && d.color && !this.options.color ? d.color : this.nonZonedColor;\n        return d;\n      },\n      destroy: function () {\n        var c = this.series.chart,\n            a = c.hoverPoints,\n            b;\n        c.pointCount--;\n        a && (this.setState(), D(a, this), a.length || (c.hoverPoints = null));\n        if (this === c.hoverPoint) this.onMouseOut();\n        if (this.graphic || this.dataLabel || this.dataLabels) q(this), this.destroyElements();\n        this.legendItem && c.legend.destroyItem(this);\n\n        for (b in this) this[b] = null;\n      },\n      destroyElements: function (c) {\n        var a = this,\n            b = [],\n            d;\n        c = c || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        c.graphic && b.push(\"graphic\", \"shadowGroup\");\n        c.dataLabel && b.push(\"dataLabel\", \"dataLabelUpper\", \"connector\");\n\n        for (d = b.length; d--;) {\n          var m = b[d];\n          a[m] && (a[m] = a[m].destroy());\n        }\n\n        [\"dataLabel\", \"connector\"].forEach(function (b) {\n          var d = b + \"s\";\n          c[b] && a[d] && (a[d].forEach(function (a) {\n            a.element && a.destroy();\n          }), delete a[d]);\n        });\n      },\n      getLabelConfig: function () {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      },\n      tooltipFormatter: function (c) {\n        var a = this.series,\n            b = a.tooltipOptions,\n            d = l(b.valueDecimals, \"\"),\n            m = b.valuePrefix || \"\",\n            h = b.valueSuffix || \"\";\n        a.chart.styledMode && (c = a.chart.tooltip.styledModeFormat(c));\n        (a.pointArrayMap || [\"y\"]).forEach(function (a) {\n          a = \"{point.\" + a;\n          if (m || h) c = c.replace(RegExp(a + \"}\", \"g\"), m + a + \"}\" + h);\n          c = c.replace(RegExp(a + \"}\", \"g\"), a + \":,.\" + d + \"f}\");\n        });\n        return u(c, {\n          point: this,\n          series: this.series\n        }, a.chart.time);\n      },\n      firePointEvent: function (c, a, b) {\n        var d = this,\n            m = this.series.options;\n        (m.point.events[c] || d.options && d.options.events && d.options.events[c]) && this.importEvents();\n        \"click\" === c && m.allowPointSelect && (b = function (a) {\n          d.select && d.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        G(this, c, a, b);\n      },\n      visible: !0\n    };\n  });\n  K(I, \"parts/Series.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.erase,\n        H = k.isArray,\n        E = k.isNumber,\n        y = k.isString,\n        C = k.objectEach,\n        t = k.splat,\n        G = d.addEvent,\n        u = d.animObject,\n        l = d.arrayMax,\n        p = d.arrayMin,\n        q = d.correctFloat,\n        c = d.defaultOptions,\n        a = d.defaultPlotOptions,\n        b = d.extend,\n        f = d.fireEvent,\n        m = d.merge,\n        h = d.pick,\n        r = d.removeEvent,\n        x = d.SVGElement,\n        v = d.syncTimeout,\n        n = d.win;\n    d.Series = d.seriesType(\"line\", null, {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        lineWidth: 0,\n        lineColor: \"#ffffff\",\n        enabledThreshold: 2,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        align: \"center\",\n        formatter: function () {\n          return null === this.y ? \"\" : d.numberFormat(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 50\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    }, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      isCartesian: !0,\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: d.Point,\n      requireSorting: !0,\n      sorted: !0,\n      init: function (a, c) {\n        f(this, \"init\", {\n          options: c\n        });\n        var e = this,\n            g = a.series,\n            n;\n        this.eventOptions = this.eventOptions || {};\n        e.chart = a;\n        e.options = c = e.setOptions(c);\n        e.linkedSeries = [];\n        e.bindAxes();\n        b(e, {\n          name: c.name,\n          state: \"\",\n          visible: !1 !== c.visible,\n          selected: !0 === c.selected\n        });\n        var m = c.events;\n        C(m, function (a, b) {\n          d.isFunction(a) && e.eventOptions[b] !== a && (d.isFunction(e.eventOptions[b]) && r(e, b, e.eventOptions[b]), e.eventOptions[b] = a, G(e, b, a));\n        });\n        if (m && m.click || c.point && c.point.events && c.point.events.click || c.allowPointSelect) a.runTrackerClick = !0;\n        e.getColor();\n        e.getSymbol();\n        e.parallelArrays.forEach(function (a) {\n          e[a + \"Data\"] || (e[a + \"Data\"] = []);\n        });\n        e.points || e.data || e.setData(c.data, !1);\n        e.isCartesian && (a.hasCartesianSeries = !0);\n        g.length && (n = g[g.length - 1]);\n        e._i = h(n && n._i, -1) + 1;\n        a.orderSeries(this.insert(g));\n        f(this, \"afterInit\");\n      },\n      insert: function (a) {\n        var b = this.options.index,\n            e;\n\n        if (E(b)) {\n          for (e = a.length; e--;) if (b >= h(a[e].options.index, a[e]._i)) {\n            a.splice(e + 1, 0, this);\n            break;\n          }\n\n          -1 === e && a.unshift(this);\n          e += 1;\n        } else a.push(this);\n\n        return h(e, a.length - 1);\n      },\n      bindAxes: function () {\n        var a = this,\n            b = a.options,\n            c = a.chart,\n            h;\n        f(this, \"bindAxes\", null, function () {\n          (a.axisTypes || []).forEach(function (e) {\n            c[e].forEach(function (c) {\n              h = c.options;\n              if (b[e] === h.index || void 0 !== b[e] && b[e] === h.id || void 0 === b[e] && 0 === h.index) a.insert(c.series), a[e] = c, c.isDirty = !0;\n            });\n            a[e] || a.optionalAxis === e || d.error(18, !0, c);\n          });\n        });\n      },\n      updateParallelArrays: function (a, b) {\n        var e = a.series,\n            c = arguments,\n            g = E(b) ? function (c) {\n          var g = \"y\" === c && e.toYData ? e.toYData(a) : a[c];\n          e[c + \"Data\"][b] = g;\n        } : function (a) {\n          Array.prototype[b].apply(e[a + \"Data\"], Array.prototype.slice.call(c, 2));\n        };\n        e.parallelArrays.forEach(g);\n      },\n      hasData: function () {\n        return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      },\n      autoIncrement: function () {\n        var a = this.options,\n            b = this.xIncrement,\n            c,\n            d = a.pointIntervalUnit,\n            f = this.chart.time;\n        b = h(b, a.pointStart, 0);\n        this.pointInterval = c = h(this.pointInterval, a.pointInterval, 1);\n        d && (a = new f.Date(b), \"day\" === d ? f.set(\"Date\", a, f.get(\"Date\", a) + c) : \"month\" === d ? f.set(\"Month\", a, f.get(\"Month\", a) + c) : \"year\" === d && f.set(\"FullYear\", a, f.get(\"FullYear\", a) + c), c = a.getTime() - b);\n        this.xIncrement = b + c;\n        return b;\n      },\n      setOptions: function (a) {\n        var b = this.chart,\n            e = b.options,\n            d = e.plotOptions,\n            n = b.userOptions || {};\n        a = m(a);\n        b = b.styledMode;\n        var B = {\n          plotOptions: d,\n          userOptions: a\n        };\n        f(this, \"setOptions\", B);\n        var l = B.plotOptions[this.type],\n            r = n.plotOptions || {};\n        this.userOptions = B.userOptions;\n        n = m(l, d.series, n.plotOptions && n.plotOptions[this.type], a);\n        this.tooltipOptions = m(c.tooltip, c.plotOptions.series && c.plotOptions.series.tooltip, c.plotOptions[this.type].tooltip, e.tooltip.userOptions, d.series && d.series.tooltip, d[this.type].tooltip, a.tooltip);\n        this.stickyTracking = h(a.stickyTracking, r[this.type] && r[this.type].stickyTracking, r.series && r.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : n.stickyTracking);\n        null === l.marker && delete n.marker;\n        this.zoneAxis = n.zoneAxis;\n        e = this.zones = (n.zones || []).slice();\n        !n.negativeColor && !n.negativeFillColor || n.zones || (d = {\n          value: n[this.zoneAxis + \"Threshold\"] || n.threshold || 0,\n          className: \"highcharts-negative\"\n        }, b || (d.color = n.negativeColor, d.fillColor = n.negativeFillColor), e.push(d));\n        e.length && w(e[e.length - 1].value) && e.push(b ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        f(this, \"afterSetOptions\", {\n          options: n\n        });\n        return n;\n      },\n      getName: function () {\n        return h(this.options.name, \"Series \" + (this.index + 1));\n      },\n      getCyclic: function (a, b, c) {\n        var e = this.chart,\n            g = this.userOptions,\n            d = a + \"Index\",\n            f = a + \"Counter\",\n            n = c ? c.length : h(e.options.chart[a + \"Count\"], e[a + \"Count\"]);\n\n        if (!b) {\n          var m = h(g[d], g[\"_\" + d]);\n          w(m) || (e.series.length || (e[f] = 0), g[\"_\" + d] = m = e[f] % n, e[f] += 1);\n          c && (b = c[m]);\n        }\n\n        void 0 !== m && (this[d] = m);\n        this[a] = b;\n      },\n      getColor: function () {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || a[this.type].color, this.chart.options.colors);\n      },\n      getSymbol: function () {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      },\n      findPointIndex: function (a, b) {\n        var e = a.id;\n        a = a.x;\n        var c = this.points,\n            g;\n\n        if (e) {\n          var d = (e = this.chart.get(e)) && e.index;\n          void 0 !== d && (g = !0);\n        }\n\n        void 0 === d && E(a) && (d = this.xData.indexOf(a, b));\n        -1 !== d && void 0 !== d && this.cropped && (d = d >= this.cropStart ? d - this.cropStart : d);\n        !g && c[d] && c[d].touched && (d = void 0);\n        return d;\n      },\n      drawLegendSymbol: d.LegendSymbolMixin.drawLineMarker,\n      updateData: function (a) {\n        var b = this.options,\n            e = this.points,\n            c = [],\n            d,\n            f,\n            h,\n            n = this.requireSorting,\n            m = a.length === e.length,\n            l = !0;\n        this.xIncrement = null;\n        a.forEach(function (a, g) {\n          var f = w(a) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, a) || {};\n          var A = f.x;\n          if (f.id || E(A)) if (A = this.findPointIndex(f, h), -1 === A || void 0 === A ? c.push(a) : e[A] && a !== b.data[A] ? (e[A].update(a, !1, null, !1), e[A].touched = !0, n && (h = A + 1)) : e[A] && (e[A].touched = !0), !m || g !== A || this.hasDerivedData) d = !0;\n        }, this);\n        if (d) for (a = e.length; a--;) (f = e[a]) && !f.touched && f.remove(!1);else m ? a.forEach(function (a, b) {\n          e[b].update && a !== e[b].y && e[b].update(a, !1, null, !1);\n        }) : l = !1;\n        e.forEach(function (a) {\n          a && (a.touched = !1);\n        });\n        if (!l) return !1;\n        c.forEach(function (a) {\n          this.addPoint(a, !1, null, null, !1);\n        }, this);\n        return !0;\n      },\n      setData: function (a, b, c, f) {\n        var e = this,\n            g = e.points,\n            n = g && g.length || 0,\n            A,\n            m = e.options,\n            F = e.chart,\n            l = null,\n            r = e.xAxis,\n            v = m.turboThreshold,\n            p = this.xData,\n            x = this.yData,\n            u = (A = e.pointArrayMap) && A.length,\n            q = m.keys,\n            k = 0,\n            t = 1,\n            w;\n        a = a || [];\n        A = a.length;\n        b = h(b, !0);\n        !1 !== f && A && n && !e.cropped && !e.hasGroupedData && e.visible && !e.isSeriesBoosting && (w = this.updateData(a));\n\n        if (!w) {\n          e.xIncrement = null;\n          e.colorCounter = 0;\n          this.parallelArrays.forEach(function (a) {\n            e[a + \"Data\"].length = 0;\n          });\n\n          if (v && A > v) {\n            for (c = 0; null === l && c < A;) l = a[c], c++;\n\n            if (E(l)) for (c = 0; c < A; c++) p[c] = this.autoIncrement(), x[c] = a[c];else if (H(l)) {\n              if (u) for (c = 0; c < A; c++) l = a[c], p[c] = l[0], x[c] = l.slice(1, u + 1);else for (q && (k = q.indexOf(\"x\"), t = q.indexOf(\"y\"), k = 0 <= k ? k : 0, t = 0 <= t ? t : 1), c = 0; c < A; c++) l = a[c], p[c] = l[k], x[c] = l[t];\n            } else d.error(12, !1, F);\n          } else for (c = 0; c < A; c++) void 0 !== a[c] && (l = {\n            series: e\n          }, e.pointClass.prototype.applyOptions.apply(l, [a[c]]), e.updateParallelArrays(l, c));\n\n          x && y(x[0]) && d.error(14, !0, F);\n          e.data = [];\n          e.options.data = e.userOptions.data = a;\n\n          for (c = n; c--;) g[c] && g[c].destroy && g[c].destroy();\n\n          r && (r.minRange = r.userMinRange);\n          e.isDirty = F.isDirtyBox = !0;\n          e.isDirtyData = !!g;\n          c = !1;\n        }\n\n        \"point\" === m.legendType && (this.processData(), this.generatePoints());\n        b && F.redraw(c);\n      },\n      processData: function (a) {\n        var b = this.xData,\n            e = this.yData,\n            c = b.length;\n        var f = 0;\n        var h = this.xAxis,\n            n = this.options;\n        var m = n.cropThreshold;\n        var l = this.getExtremesFromAll || n.getExtremesFromAll,\n            r = this.isCartesian;\n        n = h && h.val2lin;\n        var v = h && h.isLog,\n            p = this.requireSorting;\n        if (r && !this.isDirty && !h.isDirty && !this.yAxis.isDirty && !a) return !1;\n\n        if (h) {\n          a = h.getExtremes();\n          var x = a.min;\n          var q = a.max;\n        }\n\n        if (r && this.sorted && !l && (!m || c > m || this.forceCrop)) if (b[c - 1] < x || b[0] > q) b = [], e = [];else if (this.yData && (b[0] < x || b[c - 1] > q)) {\n          f = this.cropData(this.xData, this.yData, x, q);\n          b = f.xData;\n          e = f.yData;\n          f = f.start;\n          var u = !0;\n        }\n\n        for (m = b.length || 1; --m;) if (c = v ? n(b[m]) - n(b[m - 1]) : b[m] - b[m - 1], 0 < c && (void 0 === k || c < k)) var k = c;else 0 > c && p && (d.error(15, !1, this.chart), p = !1);\n\n        this.cropped = u;\n        this.cropStart = f;\n        this.processedXData = b;\n        this.processedYData = e;\n        this.closestPointRange = this.basePointRange = k;\n      },\n      cropData: function (a, b, c, d, f) {\n        var e = a.length,\n            g = 0,\n            n = e,\n            A;\n        f = h(f, this.cropShoulder);\n\n        for (A = 0; A < e; A++) if (a[A] >= c) {\n          g = Math.max(0, A - f);\n          break;\n        }\n\n        for (c = A; c < e; c++) if (a[c] > d) {\n          n = c + f;\n          break;\n        }\n\n        return {\n          xData: a.slice(g, n),\n          yData: b.slice(g, n),\n          start: g,\n          end: n\n        };\n      },\n      generatePoints: function () {\n        var a = this.options,\n            c = a.data,\n            d = this.data,\n            h,\n            n = this.processedXData,\n            m = this.processedYData,\n            l = this.pointClass,\n            r = n.length,\n            v = this.cropStart || 0,\n            p = this.hasGroupedData;\n        a = a.keys;\n        var x = [],\n            q;\n        d || p || (d = [], d.length = c.length, d = this.data = d);\n        a && p && (this.options.keys = !1);\n\n        for (q = 0; q < r; q++) {\n          var u = v + q;\n\n          if (p) {\n            var k = new l().init(this, [n[q]].concat(t(m[q])));\n            k.dataGroup = this.groupMap[q];\n            k.dataGroup.options && (k.options = k.dataGroup.options, b(k, k.dataGroup.options), delete k.dataLabels);\n          } else (k = d[u]) || void 0 === c[u] || (d[u] = k = new l().init(this, c[u], n[q]));\n\n          k && (k.index = u, x[q] = k);\n        }\n\n        this.options.keys = a;\n        if (d && (r !== (h = d.length) || p)) for (q = 0; q < h; q++) q !== v || p || (q += r), d[q] && (d[q].destroyElements(), d[q].plotX = void 0);\n        this.data = d;\n        this.points = x;\n        f(this, \"afterGeneratePoints\");\n      },\n      getXExtremes: function (a) {\n        return {\n          min: p(a),\n          max: l(a)\n        };\n      },\n      getExtremes: function (a) {\n        var b = this.xAxis,\n            c = this.yAxis,\n            e = this.processedXData || this.xData,\n            d = [],\n            h = 0,\n            n = 0;\n        var m = 0;\n        var r = this.requireSorting ? this.cropShoulder : 0,\n            v = c ? c.positiveValuesOnly : !1,\n            q;\n        a = a || this.stackedYData || this.processedYData || [];\n        c = a.length;\n        b && (m = b.getExtremes(), n = m.min, m = m.max);\n\n        for (q = 0; q < c; q++) {\n          var x = e[q];\n          var k = a[q];\n          var u = (E(k) || H(k)) && (k.length || 0 < k || !v);\n          x = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !b || (e[q + r] || x) >= n && (e[q - r] || x) <= m;\n          if (u && x) if (u = k.length) for (; u--;) E(k[u]) && (d[h++] = k[u]);else d[h++] = k;\n        }\n\n        this.dataMin = p(d);\n        this.dataMax = l(d);\n        f(this, \"afterGetExtremes\");\n      },\n      translate: function () {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var a = this.options,\n            b = a.stacking,\n            c = this.xAxis,\n            d = c.categories,\n            n = this.yAxis,\n            m = this.points,\n            l = m.length,\n            r = !!this.modifyValue,\n            v,\n            p = this.pointPlacementToXValue(),\n            x = E(p),\n            k = a.threshold,\n            u = a.startFromThreshold ? k : 0,\n            t,\n            y = this.zoneAxis || \"y\",\n            C = Number.MAX_VALUE;\n\n        for (v = 0; v < l; v++) {\n          var G = m[v],\n              D = G.x;\n          var I = G.y;\n          var S = G.low,\n              K = b && n.stacks[(this.negStacks && I < (u ? 0 : k) ? \"-\" : \"\") + this.stackKey];\n          n.positiveValuesOnly && null !== I && 0 >= I && (G.isNull = !0);\n          G.plotX = t = q(Math.min(Math.max(-1E5, c.translate(D, 0, 0, 0, 1, p, \"flags\" === this.type)), 1E5));\n\n          if (b && this.visible && K && K[D]) {\n            var Y = this.getStackIndicator(Y, D, this.index);\n\n            if (!G.isNull) {\n              var Z = K[D];\n              var U = Z.points[Y.key];\n            }\n          }\n\n          H(U) && (S = U[0], I = U[1], S === u && Y.key === K[D].base && (S = h(E(k) && k, n.min)), n.positiveValuesOnly && 0 >= S && (S = null), G.total = G.stackTotal = Z.total, G.percentage = Z.total && G.y / Z.total * 100, G.stackY = I, this.irregularWidths || Z.setOffset(this.pointXOffset || 0, this.barW || 0));\n          G.yBottom = w(S) ? Math.min(Math.max(-1E5, n.translate(S, 0, 1, 0, 1)), 1E5) : null;\n          r && (I = this.modifyValue(I, G));\n          G.plotY = I = \"number\" === typeof I && Infinity !== I ? Math.min(Math.max(-1E5, n.translate(I, 0, 1, 0, 1)), 1E5) : void 0;\n          G.isInside = void 0 !== I && 0 <= I && I <= n.len && 0 <= t && t <= c.len;\n          G.clientX = x ? q(c.translate(D, 0, 0, 0, 1, p)) : t;\n          G.negative = G[y] < (a[y + \"Threshold\"] || k || 0);\n          G.category = d && void 0 !== d[G.x] ? d[G.x] : G.x;\n\n          if (!G.isNull) {\n            void 0 !== V && (C = Math.min(C, Math.abs(t - V)));\n            var V = t;\n          }\n\n          G.zone = this.zones.length && G.getZone();\n        }\n\n        this.closestPointRangePx = C;\n        f(this, \"afterTranslate\");\n      },\n      getValidPoints: function (a, b, c) {\n        var e = this.chart;\n        return (a || this.points || []).filter(function (a) {\n          return b && !e.isInsidePlot(a.plotX, a.plotY, e.inverted) ? !1 : c || !a.isNull;\n        });\n      },\n      getClipBox: function (a, b) {\n        var c = this.options,\n            e = this.chart,\n            g = e.inverted,\n            d = this.xAxis,\n            f = d && this.yAxis;\n        a && !1 === c.clip && f ? a = g ? {\n          y: -e.chartWidth + f.len + f.pos,\n          height: e.chartWidth,\n          width: e.chartHeight,\n          x: -e.chartHeight + d.len + d.pos\n        } : {\n          y: -f.pos,\n          height: e.chartHeight,\n          width: e.chartWidth,\n          x: -d.pos\n        } : (a = this.clipBox || e.clipBox, b && (a.width = e.plotSizeX, a.x = 0));\n        return b ? {\n          width: a.width,\n          x: a.x\n        } : a;\n      },\n      setClip: function (a) {\n        var b = this.chart,\n            c = this.options,\n            e = b.renderer,\n            d = b.inverted,\n            f = this.clipBox,\n            h = this.getClipBox(a),\n            n = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, h.height, c.xAxis, c.yAxis].join(),\n            m = b[n],\n            l = b[n + \"m\"];\n        m || (a && (h.width = 0, d && (h.x = b.plotSizeX + (!1 !== c.clip ? 0 : b.plotTop)), b[n + \"m\"] = l = e.clipRect(d ? b.plotSizeX + 99 : -99, d ? -b.plotLeft : -b.plotTop, 99, d ? b.chartWidth : b.chartHeight)), b[n] = m = e.clipRect(h), m.count = {\n          length: 0\n        });\n        a && !m.count[this.index] && (m.count[this.index] = !0, m.count.length += 1);\n        if (!1 !== c.clip || a) this.group.clip(a || f ? m : b.clipRect), this.markerGroup.clip(l), this.sharedClipKey = n;\n        a || (m.count[this.index] && (delete m.count[this.index], --m.count.length), 0 === m.count.length && n && b[n] && (f || (b[n] = b[n].destroy()), b[n + \"m\"] && (b[n + \"m\"] = b[n + \"m\"].destroy())));\n      },\n      animate: function (a) {\n        var b = this.chart,\n            c = u(this.options.animation);\n        if (a) this.setClip(c);else {\n          var e = this.sharedClipKey;\n          a = b[e];\n          var d = this.getClipBox(c, !0);\n          a && a.animate(d, c);\n          b[e + \"m\"] && b[e + \"m\"].animate({\n            width: d.width + 99,\n            x: d.x - (b.inverted ? 0 : 99)\n          }, c);\n          this.animate = null;\n        }\n      },\n      afterAnimate: function () {\n        this.setClip();\n        f(this, \"afterAnimate\");\n        this.finishedAnimating = !0;\n      },\n      drawPoints: function () {\n        var a = this.points,\n            b = this.chart,\n            c,\n            d = this.options.marker,\n            f = this[this.specialGroup] || this.markerGroup;\n        var n = this.xAxis;\n        var m = h(d.enabled, !n || n.isRadial ? !0 : null, this.closestPointRangePx >= d.enabledThreshold * d.radius);\n        if (!1 !== d.enabled || this._hasPointMarkers) for (n = 0; n < a.length; n++) {\n          var l = a[n];\n          var r = (c = l.graphic) ? \"animate\" : \"attr\";\n          var v = l.marker || {};\n          var p = !!l.marker;\n          var q = m && void 0 === v.enabled || v.enabled;\n          var k = !1 !== l.isInside;\n\n          if (q && !l.isNull) {\n            q = h(v.symbol, this.symbol);\n            var x = this.markerAttribs(l, l.selected && \"select\");\n            c ? c[k ? \"show\" : \"hide\"](k).animate(x) : k && (0 < x.width || l.hasImage) && (l.graphic = c = b.renderer.symbol(q, x.x, x.y, x.width, x.height, p ? v : d).add(f));\n            if (c && !b.styledMode) c[r](this.pointAttribs(l, l.selected && \"select\"));\n            c && c.addClass(l.getClassName(), !0);\n          } else c && (l.graphic = c.destroy());\n        }\n      },\n      markerAttribs: function (a, b) {\n        var c = this.options.marker,\n            e = a.marker || {},\n            d = e.symbol || c.symbol,\n            g = h(e.radius, c.radius);\n        b && (c = c.states[b], b = e.states && e.states[b], g = h(b && b.radius, c && c.radius, g + (c && c.radiusPlus || 0)));\n        a.hasImage = d && 0 === d.indexOf(\"url\");\n        a.hasImage && (g = 0);\n        a = {\n          x: Math.floor(a.plotX) - g,\n          y: a.plotY - g\n        };\n        g && (a.width = a.height = 2 * g);\n        return a;\n      },\n      pointAttribs: function (a, b) {\n        var c = this.options.marker,\n            e = a && a.options,\n            d = e && e.marker || {},\n            g = this.color,\n            f = e && e.color,\n            n = a && a.color;\n        e = h(d.lineWidth, c.lineWidth);\n        var m = a && a.zone && a.zone.color;\n        a = 1;\n        g = f || m || n || g;\n        f = d.fillColor || c.fillColor || g;\n        g = d.lineColor || c.lineColor || g;\n        b = b || \"normal\";\n        c = c.states[b];\n        b = d.states && d.states[b] || {};\n        e = h(b.lineWidth, c.lineWidth, e + h(b.lineWidthPlus, c.lineWidthPlus, 0));\n        f = b.fillColor || c.fillColor || f;\n        g = b.lineColor || c.lineColor || g;\n        a = h(b.opacity, c.opacity, a);\n        return {\n          stroke: g,\n          \"stroke-width\": e,\n          fill: f,\n          opacity: a\n        };\n      },\n      destroy: function (a) {\n        var b = this,\n            c = b.chart,\n            e = /AppleWebKit\\/533/.test(n.navigator.userAgent),\n            h,\n            m,\n            l = b.data || [],\n            v,\n            p;\n        f(b, \"destroy\");\n        a || r(b);\n        (b.axisTypes || []).forEach(function (a) {\n          (p = b[a]) && p.series && (D(p.series, b), p.isDirty = p.forceRedraw = !0);\n        });\n        b.legendItem && b.chart.legend.destroyItem(b);\n\n        for (m = l.length; m--;) (v = l[m]) && v.destroy && v.destroy();\n\n        b.points = null;\n        d.clearTimeout(b.animationTimeout);\n        C(b, function (a, b) {\n          a instanceof x && !a.survive && (h = e && \"group\" === b ? \"hide\" : \"destroy\", a[h]());\n        });\n        c.hoverSeries === b && (c.hoverSeries = null);\n        D(c.series, b);\n        c.orderSeries();\n        C(b, function (c, e) {\n          a && \"hcEvents\" === e || delete b[e];\n        });\n      },\n      getGraphPath: function (a, b, c) {\n        var e = this,\n            d = e.options,\n            g = d.step,\n            f,\n            n = [],\n            h = [],\n            m;\n        a = a || e.points;\n        (f = a.reversed) && a.reverse();\n        (g = {\n          right: 1,\n          center: 2\n        }[g] || g && 3) && f && (g = 4 - g);\n        !d.connectNulls || b || c || (a = this.getValidPoints(a));\n        a.forEach(function (f, A) {\n          var l = f.plotX,\n              r = f.plotY,\n              v = a[A - 1];\n          (f.leftCliff || v && v.rightCliff) && !c && (m = !0);\n          f.isNull && !w(b) && 0 < A ? m = !d.connectNulls : f.isNull && !b ? m = !0 : (0 === A || m ? A = [\"M\", f.plotX, f.plotY] : e.getPointSpline ? A = e.getPointSpline(a, f, A) : g ? (A = 1 === g ? [\"L\", v.plotX, r] : 2 === g ? [\"L\", (v.plotX + l) / 2, v.plotY, \"L\", (v.plotX + l) / 2, r] : [\"L\", l, v.plotY], A.push(\"L\", l, r)) : A = [\"L\", l, r], h.push(f.x), g && (h.push(f.x), 2 === g && h.push(f.x)), n.push.apply(n, A), m = !1);\n        });\n        n.xMap = h;\n        return e.graphPath = n;\n      },\n      drawGraph: function () {\n        var a = this,\n            b = this.options,\n            c = (this.gappedPath || this.getGraphPath).call(this),\n            d = this.chart.styledMode,\n            f = [[\"graph\", \"highcharts-graph\"]];\n        d || f[0].push(b.lineColor || this.color || \"#cccccc\", b.dashStyle);\n        f = a.getZonesGraphs(f);\n        f.forEach(function (e, g) {\n          var f = e[0],\n              n = a[f],\n              h = n ? \"animate\" : \"attr\";\n          n ? (n.endX = a.preventGraphAnimation ? null : c.xMap, n.animate({\n            d: c\n          })) : c.length && (a[f] = n = a.chart.renderer.path(c).addClass(e[1]).attr({\n            zIndex: 1\n          }).add(a.group));\n          n && !d && (f = {\n            stroke: e[2],\n            \"stroke-width\": b.lineWidth,\n            fill: a.fillGraph && a.color || \"none\"\n          }, e[3] ? f.dashstyle = e[3] : \"square\" !== b.linecap && (f[\"stroke-linecap\"] = f[\"stroke-linejoin\"] = \"round\"), n[h](f).shadow(2 > g && b.shadow));\n          n && (n.startX = c.xMap, n.isArea = c.isArea);\n        });\n      },\n      getZonesGraphs: function (a) {\n        this.zones.forEach(function (b, c) {\n          c = [\"zone-graph-\" + c, \"highcharts-graph highcharts-zone-graph-\" + c + \" \" + (b.className || \"\")];\n          this.chart.styledMode || c.push(b.color || this.color, b.dashStyle || this.options.dashStyle);\n          a.push(c);\n        }, this);\n        return a;\n      },\n      applyZones: function () {\n        var a = this,\n            b = this.chart,\n            c = b.renderer,\n            d = this.zones,\n            f,\n            n,\n            m = this.clips || [],\n            l,\n            v = this.graph,\n            r = this.area,\n            p = Math.max(b.chartWidth, b.chartHeight),\n            q = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            x = b.inverted,\n            k,\n            u,\n            t,\n            y = !1;\n\n        if (d.length && (v || r) && q && void 0 !== q.min) {\n          var w = q.reversed;\n          var C = q.horiz;\n          v && !this.showLine && v.hide();\n          r && r.hide();\n          var G = q.getExtremes();\n          d.forEach(function (e, d) {\n            f = w ? C ? b.plotWidth : 0 : C ? 0 : q.toPixels(G.min) || 0;\n            f = Math.min(Math.max(h(n, f), 0), p);\n            n = Math.min(Math.max(Math.round(q.toPixels(h(e.value, G.max), !0) || 0), 0), p);\n            y && (f = n = q.toPixels(G.max));\n            k = Math.abs(f - n);\n            u = Math.min(f, n);\n            t = Math.max(f, n);\n            q.isXAxis ? (l = {\n              x: x ? t : u,\n              y: 0,\n              width: k,\n              height: p\n            }, C || (l.x = b.plotHeight - l.x)) : (l = {\n              x: 0,\n              y: x ? t : u,\n              width: p,\n              height: k\n            }, C && (l.y = b.plotWidth - l.y));\n            x && c.isVML && (l = q.isXAxis ? {\n              x: 0,\n              y: w ? u : t,\n              height: l.width,\n              width: b.chartWidth\n            } : {\n              x: l.y - b.plotLeft - b.spacingBox.x,\n              y: 0,\n              width: l.height,\n              height: b.chartHeight\n            });\n            m[d] ? m[d].animate(l) : m[d] = c.clipRect(l);\n            v && a[\"zone-graph-\" + d].clip(m[d]);\n            r && a[\"zone-area-\" + d].clip(m[d]);\n            y = e.value > G.max;\n            a.resetZones && 0 === n && (n = void 0);\n          });\n          this.clips = m;\n        } else a.visible && (v && v.show(!0), r && r.show(!0));\n      },\n      invertGroups: function (a) {\n        function b() {\n          [\"group\", \"markerGroup\"].forEach(function (b) {\n            c[b] && (e.renderer.isVML && c[b].attr({\n              width: c.yAxis.len,\n              height: c.xAxis.len\n            }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(a));\n          });\n        }\n\n        var c = this,\n            e = c.chart;\n\n        if (c.xAxis) {\n          var d = G(e, \"resize\", b);\n          G(c, \"destroy\", d);\n          b(a);\n          c.invertGroups = b;\n        }\n      },\n      plotGroup: function (a, b, c, d, f) {\n        var e = this[a],\n            g = !e;\n        g && (this[a] = e = this.chart.renderer.g().attr({\n          zIndex: d || .1\n        }).add(f));\n        e.addClass(\"highcharts-\" + b + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (w(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (e.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        e.attr({\n          visibility: c\n        })[g ? \"attr\" : \"animate\"](this.getPlotBox());\n        return e;\n      },\n      getPlotBox: function () {\n        var a = this.chart,\n            b = this.xAxis,\n            c = this.yAxis;\n        a.inverted && (b = c, c = this.xAxis);\n        return {\n          translateX: b ? b.left : a.plotLeft,\n          translateY: c ? c.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      },\n      render: function () {\n        var a = this,\n            b = a.chart,\n            c = a.options,\n            d = !!a.animate && b.renderer.isSVG && u(c.animation).duration,\n            n = a.visible ? \"inherit\" : \"hidden\",\n            h = c.zIndex,\n            m = a.hasRendered,\n            l = b.seriesGroup,\n            r = b.inverted;\n        f(this, \"render\");\n        var p = a.plotGroup(\"group\", \"series\", n, h, l);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", n, h, l);\n        d && a.animate(!0);\n        p.inverted = a.isCartesian || a.invertable ? r : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.visible && a.drawPoints();\n        a.drawDataLabels && a.drawDataLabels();\n        a.redrawPoints && a.redrawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(r);\n        !1 === c.clip || a.sharedClipKey || m || p.clip(b.clipRect);\n        d && a.animate();\n        m || (a.animationTimeout = v(function () {\n          a.afterAnimate();\n        }, d));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        f(a, \"afterRender\");\n      },\n      redraw: function () {\n        var a = this.chart,\n            b = this.isDirty || this.isDirtyData,\n            c = this.group,\n            d = this.xAxis,\n            f = this.yAxis;\n        c && (a.inverted && c.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), c.animate({\n          translateX: h(d && d.left, a.plotLeft),\n          translateY: h(f && f.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      },\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      searchPoint: function (a, b) {\n        var c = this.xAxis,\n            e = this.yAxis,\n            d = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: d ? c.len - a.chartY + c.pos : a.chartX - c.pos,\n          plotY: d ? e.len - a.chartX + e.pos : a.chartY - e.pos\n        }, b, a);\n      },\n      buildKDTree: function (a) {\n        function b(a, e, d) {\n          var g;\n\n          if (g = a && a.length) {\n            var f = c.kdAxisArray[e % d];\n            a.sort(function (a, b) {\n              return a[f] - b[f];\n            });\n            g = Math.floor(g / 2);\n            return {\n              point: a[g],\n              left: b(a.slice(0, g), e + 1, d),\n              right: b(a.slice(g + 1), e + 1, d)\n            };\n          }\n        }\n\n        this.buildingKdTree = !0;\n        var c = this,\n            e = -1 < c.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete c.kdTree;\n        v(function () {\n          c.kdTree = b(c.getValidPoints(null, !c.directTouch), e, e);\n          c.buildingKdTree = !1;\n        }, c.options.kdNow || a && \"touchstart\" === a.type ? 0 : 1);\n      },\n      searchKDTree: function (a, b, c) {\n        function e(a, b, c, h) {\n          var m = b.point,\n              A = d.kdAxisArray[c % h],\n              l = m;\n          var r = w(a[g]) && w(m[g]) ? Math.pow(a[g] - m[g], 2) : null;\n          var v = w(a[f]) && w(m[f]) ? Math.pow(a[f] - m[f], 2) : null;\n          v = (r || 0) + (v || 0);\n          m.dist = w(v) ? Math.sqrt(v) : Number.MAX_VALUE;\n          m.distX = w(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n          A = a[A] - m[A];\n          v = 0 > A ? \"left\" : \"right\";\n          r = 0 > A ? \"right\" : \"left\";\n          b[v] && (v = e(a, b[v], c + 1, h), l = v[n] < l[n] ? v : m);\n          b[r] && Math.sqrt(A * A) < l[n] && (a = e(a, b[r], c + 1, h), l = a[n] < l[n] ? a : l);\n          return l;\n        }\n\n        var d = this,\n            g = this.kdAxisArray[0],\n            f = this.kdAxisArray[1],\n            n = b ? \"distX\" : \"dist\";\n        b = -1 < d.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(c);\n        if (this.kdTree) return e(a, this.kdTree, b, b);\n      },\n      pointPlacementToXValue: function () {\n        var a = this.options.pointPlacement;\n        \"between\" === a && (a = .5);\n        E(a) && (a *= h(this.options.pointRange || this.xAxis.pointRange));\n        return a;\n      }\n    });\n    \"\";\n  });\n  K(I, \"parts/Stacking.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.objectEach;\n    k = d.Axis;\n    var H = d.Chart,\n        E = d.correctFloat,\n        y = d.destroyObjectProperties,\n        C = d.format,\n        t = d.pick,\n        G = d.Series;\n\n    d.StackItem = function (d, l, p, q, c) {\n      var a = d.chart.inverted;\n      this.axis = d;\n      this.isNegative = p;\n      this.options = l = l || {};\n      this.x = q;\n      this.total = null;\n      this.points = {};\n      this.stack = c;\n      this.rightCliff = this.leftCliff = 0;\n      this.alignOptions = {\n        align: l.align || (a ? p ? \"left\" : \"right\" : \"center\"),\n        verticalAlign: l.verticalAlign || (a ? \"middle\" : p ? \"bottom\" : \"top\"),\n        y: l.y,\n        x: l.x\n      };\n      this.textAlign = l.textAlign || (a ? p ? \"right\" : \"left\" : \"center\");\n    };\n\n    d.StackItem.prototype = {\n      destroy: function () {\n        y(this, this.axis);\n      },\n      render: function (d) {\n        var l = this.axis.chart,\n            p = this.options,\n            q = p.format;\n        q = q ? C(q, this, l.time) : p.formatter.call(this);\n        this.label ? this.label.attr({\n          text: q,\n          visibility: \"hidden\"\n        }) : (this.label = l.renderer.label(q, null, null, p.shape, null, null, p.useHTML, !1, \"stack-labels\"), q = {\n          text: q,\n          align: this.textAlign,\n          rotation: p.rotation,\n          padding: t(p.padding, 0),\n          visibility: \"hidden\"\n        }, this.label.attr(q), l.styledMode || this.label.css(p.style), this.label.added || this.label.add(d));\n        this.label.labelrank = l.plotHeight;\n      },\n      setOffset: function (d, l, p, q, c) {\n        var a = this.axis,\n            b = a.chart;\n        q = a.translate(a.usePercentage ? 100 : q ? q : this.total, 0, 0, 0, 1);\n        p = a.translate(p ? p : 0);\n        p = w(q) && Math.abs(q - p);\n        d = t(c, b.xAxis[0].translate(this.x)) + d;\n        a = w(q) && this.getStackBox(b, this, d, q, l, p, a);\n        l = this.label;\n        d = this.isNegative;\n        c = \"justify\" === t(this.options.overflow, \"justify\");\n\n        if (l && a) {\n          p = l.getBBox();\n          var f = b.inverted ? d ? p.width : 0 : p.width / 2,\n              m = b.inverted ? p.height / 2 : d ? -4 : p.height + 4;\n          this.alignOptions.x = t(this.options.x, 0);\n          l.align(this.alignOptions, null, a);\n          q = l.alignAttr;\n          l.show();\n          q.y -= m;\n          c && (q.x -= f, G.prototype.justifyDataLabel.call(this.axis, l, this.alignOptions, q, p, a), q.x += f);\n          q.x = l.alignAttr.x;\n          l.attr({\n            x: q.x,\n            y: q.y\n          });\n          t(!c && this.options.crop, !0) && ((b = b.isInsidePlot(l.x + (b.inverted ? 0 : -p.width / 2), l.y) && b.isInsidePlot(l.x + (b.inverted ? d ? -p.width : p.width : p.width / 2), l.y + p.height)) || l.hide());\n        }\n      },\n      getStackBox: function (d, l, p, q, c, a, b) {\n        var f = l.axis.reversed,\n            m = d.inverted;\n        d = b.height + b.pos - (m ? d.plotLeft : d.plotTop);\n        l = l.isNegative && !f || !l.isNegative && f;\n        return {\n          x: m ? l ? q : q - a : p,\n          y: m ? d - p - c : l ? d - q - a : d - q,\n          width: m ? a : c,\n          height: m ? c : a\n        };\n      }\n    };\n\n    H.prototype.getStacks = function () {\n      var d = this,\n          l = d.inverted;\n      d.yAxis.forEach(function (d) {\n        d.stacks && d.hasVisibleSeries && (d.oldStacks = d.stacks);\n      });\n      d.series.forEach(function (p) {\n        var q = p.xAxis && p.xAxis.options || {};\n        !p.options.stacking || !0 !== p.visible && !1 !== d.options.chart.ignoreHiddenSeries || (p.stackKey = [p.type, t(p.options.stack, \"\"), l ? q.top : q.left, l ? q.height : q.width].join());\n      });\n    };\n\n    k.prototype.buildStacks = function () {\n      var d = this.series,\n          l = t(this.options.reversedStacks, !0),\n          p = d.length,\n          q;\n\n      if (!this.isXAxis) {\n        this.usePercentage = !1;\n\n        for (q = p; q--;) d[l ? q : p - q - 1].setStackedPoints();\n\n        for (q = 0; q < p; q++) d[q].modifyStacks();\n      }\n    };\n\n    k.prototype.renderStackTotals = function () {\n      var d = this.chart,\n          l = d.renderer,\n          p = this.stacks,\n          q = this.stackTotalGroup;\n      q || (this.stackTotalGroup = q = l.g(\"stack-labels\").attr({\n        visibility: \"visible\",\n        zIndex: 6\n      }).add());\n      q.translate(d.plotLeft, d.plotTop);\n      D(p, function (c) {\n        D(c, function (a) {\n          a.render(q);\n        });\n      });\n    };\n\n    k.prototype.resetStacks = function () {\n      var d = this,\n          l = d.stacks;\n      d.isXAxis || D(l, function (l) {\n        D(l, function (p, c) {\n          p.touched < d.stacksTouched ? (p.destroy(), delete l[c]) : (p.total = null, p.cumulative = null);\n        });\n      });\n    };\n\n    k.prototype.cleanStacks = function () {\n      if (!this.isXAxis) {\n        if (this.oldStacks) var d = this.stacks = this.oldStacks;\n        D(d, function (d) {\n          D(d, function (d) {\n            d.cumulative = d.total;\n          });\n        });\n      }\n    };\n\n    G.prototype.setStackedPoints = function () {\n      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var k = this.processedXData,\n            l = this.processedYData,\n            p = [],\n            q = l.length,\n            c = this.options,\n            a = c.threshold,\n            b = t(c.startFromThreshold && a, 0),\n            f = c.stack;\n        c = c.stacking;\n        var m = this.stackKey,\n            h = \"-\" + m,\n            r = this.negStacks,\n            x = this.yAxis,\n            v = x.stacks,\n            n = x.oldStacks,\n            e,\n            g;\n        x.stacksTouched += 1;\n\n        for (g = 0; g < q; g++) {\n          var F = k[g];\n          var A = l[g];\n          var z = this.getStackIndicator(z, F, this.index);\n          var B = z.key;\n          var J = (e = r && A < (b ? 0 : a)) ? h : m;\n          v[J] || (v[J] = {});\n          v[J][F] || (n[J] && n[J][F] ? (v[J][F] = n[J][F], v[J][F].total = null) : v[J][F] = new d.StackItem(x, x.options.stackLabels, e, F, f));\n          J = v[J][F];\n          null !== A ? (J.points[B] = J.points[this.index] = [t(J.cumulative, b)], w(J.cumulative) || (J.base = B), J.touched = x.stacksTouched, 0 < z.index && !1 === this.singleStacks && (J.points[B][0] = J.points[this.index + \",\" + F + \",0\"][0])) : J.points[B] = J.points[this.index] = null;\n          \"percent\" === c ? (e = e ? m : h, r && v[e] && v[e][F] ? (e = v[e][F], J.total = e.total = Math.max(e.total, J.total) + Math.abs(A) || 0) : J.total = E(J.total + (Math.abs(A) || 0))) : J.total = E(J.total + (A || 0));\n          J.cumulative = t(J.cumulative, b) + (A || 0);\n          null !== A && (J.points[B].push(J.cumulative), p[g] = J.cumulative);\n        }\n\n        \"percent\" === c && (x.usePercentage = !0);\n        this.stackedYData = p;\n        x.oldStacks = {};\n      }\n    };\n\n    G.prototype.modifyStacks = function () {\n      var d = this,\n          l = d.stackKey,\n          p = d.yAxis.stacks,\n          q = d.processedXData,\n          c,\n          a = d.options.stacking;\n      d[a + \"Stacker\"] && [l, \"-\" + l].forEach(function (b) {\n        for (var f = q.length, m, h; f--;) if (m = q[f], c = d.getStackIndicator(c, m, d.index, b), h = (m = p[b] && p[b][m]) && m.points[c.key]) d[a + \"Stacker\"](h, m, f);\n      });\n    };\n\n    G.prototype.percentStacker = function (d, l, p) {\n      l = l.total ? 100 / l.total : 0;\n      d[0] = E(d[0] * l);\n      d[1] = E(d[1] * l);\n      this.stackedYData[p] = d[1];\n    };\n\n    G.prototype.getStackIndicator = function (d, l, p, q) {\n      !w(d) || d.x !== l || q && d.key !== q ? d = {\n        x: l,\n        index: 0,\n        key: q\n      } : d.index++;\n      d.key = [p, l, d.index].join();\n      return d;\n    };\n  });\n  K(I, \"parts/Dynamics.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.erase,\n        H = k.isArray,\n        E = k.isNumber,\n        y = k.isObject,\n        C = k.isString,\n        t = k.objectEach,\n        G = k.splat,\n        u = d.addEvent,\n        l = d.animate,\n        p = d.Axis;\n    k = d.Chart;\n    var q = d.createElement,\n        c = d.css,\n        a = d.extend,\n        b = d.fireEvent,\n        f = d.merge,\n        m = d.pick,\n        h = d.Point,\n        r = d.Series,\n        x = d.seriesTypes,\n        v = d.setAnimation;\n\n    d.cleanRecursively = function (a, b) {\n      var c = {};\n      t(a, function (e, g) {\n        if (y(a[g], !0) && !a.nodeType && b[g]) e = d.cleanRecursively(a[g], b[g]), Object.keys(e).length && (c[g] = e);else if (y(a[g]) || a[g] !== b[g]) c[g] = a[g];\n      });\n      return c;\n    };\n\n    a(k.prototype, {\n      addSeries: function (a, c, d) {\n        var e,\n            g = this;\n        a && (c = m(c, !0), b(g, \"addSeries\", {\n          options: a\n        }, function () {\n          e = g.initSeries(a);\n          g.isDirtyLegend = !0;\n          g.linkSeries();\n          b(g, \"afterAddSeries\", {\n            series: e\n          });\n          c && g.redraw(d);\n        }));\n        return e;\n      },\n      addAxis: function (a, b, c, d) {\n        return this.createAxis(b ? \"xAxis\" : \"yAxis\", {\n          axis: a,\n          redraw: c,\n          animation: d\n        });\n      },\n      addColorAxis: function (a, b, c) {\n        return this.createAxis(\"colorAxis\", {\n          axis: a,\n          redraw: b,\n          animation: c\n        });\n      },\n      createAxis: function (a, b) {\n        var c = this.options,\n            e = \"colorAxis\" === a,\n            n = b.redraw,\n            h = b.animation;\n        b = f(b.axis, {\n          index: this[a].length,\n          isX: \"xAxis\" === a\n        });\n        var l = e ? new d.ColorAxis(this, b) : new p(this, b);\n        c[a] = G(c[a] || {});\n        c[a].push(b);\n        e && (this.isDirtyLegend = !0);\n        m(n, !0) && this.redraw(h);\n        return l;\n      },\n      showLoading: function (b) {\n        var d = this,\n            g = d.options,\n            f = d.loadingDiv,\n            h = g.loading,\n            n = function () {\n          f && c(f, {\n            left: d.plotLeft + \"px\",\n            top: d.plotTop + \"px\",\n            width: d.plotWidth + \"px\",\n            height: d.plotHeight + \"px\"\n          });\n        };\n\n        f || (d.loadingDiv = f = q(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, d.container), d.loadingSpan = q(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, f), u(d, \"redraw\", n));\n        f.className = \"highcharts-loading\";\n        d.loadingSpan.innerHTML = m(b, g.lang.loading, \"\");\n        d.styledMode || (c(f, a(h.style, {\n          zIndex: 10\n        })), c(d.loadingSpan, h.labelStyle), d.loadingShown || (c(f, {\n          opacity: 0,\n          display: \"\"\n        }), l(f, {\n          opacity: h.style.opacity || .5\n        }, {\n          duration: h.showDuration || 0\n        })));\n        d.loadingShown = !0;\n        n();\n      },\n      hideLoading: function () {\n        var a = this.options,\n            b = this.loadingDiv;\n        b && (b.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || l(b, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function () {\n            c(b, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      },\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \"),\n      collectionsWithUpdate: \"xAxis yAxis zAxis series colorAxis pane\".split(\" \"),\n      update: function (a, c, g, h) {\n        var e = this,\n            n = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\",\n          caption: \"setCaption\"\n        },\n            l,\n            v,\n            r,\n            p = a.isResponsiveOptions,\n            F = [];\n        b(e, \"update\", {\n          options: a\n        });\n        p || e.setResponsive(!1, !0);\n        a = d.cleanRecursively(a, e.options);\n        f(!0, e.userOptions, a);\n\n        if (l = a.chart) {\n          f(!0, e.options.chart, l);\n          \"className\" in l && e.setClassName(l.className);\n          \"reflow\" in l && e.setReflow(l.reflow);\n\n          if (\"inverted\" in l || \"polar\" in l || \"type\" in l) {\n            e.propFromSeries();\n            var q = !0;\n          }\n\n          \"alignTicks\" in l && (q = !0);\n          t(l, function (a, b) {\n            -1 !== e.propsRequireUpdateSeries.indexOf(\"chart.\" + b) && (v = !0);\n            -1 !== e.propsRequireDirtyBox.indexOf(b) && (e.isDirtyBox = !0);\n            p || -1 === e.propsRequireReflow.indexOf(b) || (r = !0);\n          });\n          !e.styledMode && \"style\" in l && e.renderer.setStyle(l.style);\n        }\n\n        !e.styledMode && a.colors && (this.options.colors = a.colors);\n        a.plotOptions && f(!0, this.options.plotOptions, a.plotOptions);\n        a.time && this.time === d.time && (this.time = new d.Time(a.time));\n        t(a, function (a, b) {\n          if (e[b] && \"function\" === typeof e[b].update) e[b].update(a, !1);else if (\"function\" === typeof e[n[b]]) e[n[b]](a);\n          \"chart\" !== b && -1 !== e.propsRequireUpdateSeries.indexOf(b) && (v = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (b) {\n          if (a[b]) {\n            if (\"series\" === b) {\n              var c = [];\n              e[b].forEach(function (a, b) {\n                a.options.isInternal || c.push(m(a.options.index, b));\n              });\n            }\n\n            G(a[b]).forEach(function (a, d) {\n              (d = w(a.id) && e.get(a.id) || e[b][c ? c[d] : d]) && d.coll === b && (d.update(a, !1), g && (d.touched = !0));\n              !d && g && e.collectionsWithInit[b] && (e.collectionsWithInit[b][0].apply(e, [a].concat(e.collectionsWithInit[b][1] || []).concat([!1])).touched = !0);\n            });\n            g && e[b].forEach(function (a) {\n              a.touched || a.options.isInternal ? delete a.touched : F.push(a);\n            });\n          }\n        });\n        F.forEach(function (a) {\n          a.remove && a.remove(!1);\n        });\n        q && e.axes.forEach(function (a) {\n          a.update({}, !1);\n        });\n        v && e.series.forEach(function (a) {\n          a.update({}, !1);\n        });\n        a.loading && f(!0, e.options.loading, a.loading);\n        q = l && l.width;\n        l = l && l.height;\n        C(l) && (l = d.relativeLength(l, q || e.chartWidth));\n        r || E(q) && q !== e.chartWidth || E(l) && l !== e.chartHeight ? e.setSize(q, l, h) : m(c, !0) && e.redraw(h);\n        b(e, \"afterUpdate\", {\n          options: a,\n          redraw: c,\n          animation: h\n        });\n      },\n      setSubtitle: function (a, b) {\n        this.applyDescription(\"subtitle\", a);\n        this.layOutTitles(b);\n      },\n      setCaption: function (a, b) {\n        this.applyDescription(\"caption\", a);\n        this.layOutTitles(b);\n      }\n    });\n    k.prototype.collectionsWithInit = {\n      xAxis: [k.prototype.addAxis, [!0]],\n      yAxis: [k.prototype.addAxis, [!1]],\n      colorAxis: [k.prototype.addColorAxis, [!1]],\n      series: [k.prototype.addSeries]\n    };\n    a(h.prototype, {\n      update: function (a, b, c, d) {\n        function e() {\n          g.applyOptions(a);\n          null === g.y && h && (g.graphic = h.destroy());\n          y(a, !0) && (h && h.element && a && a.marker && void 0 !== a.marker.symbol && (g.graphic = h.destroy()), a && a.dataLabels && g.dataLabel && (g.dataLabel = g.dataLabel.destroy()), g.connector && (g.connector = g.connector.destroy()));\n          n = g.index;\n          f.updateParallelArrays(g, n);\n          v.data[n] = y(v.data[n], !0) || y(a, !0) ? g.options : m(a, v.data[n]);\n          f.isDirty = f.isDirtyData = !0;\n          !f.fixedBox && f.hasCartesianSeries && (l.isDirtyBox = !0);\n          \"point\" === v.legendType && (l.isDirtyLegend = !0);\n          b && l.redraw(c);\n        }\n\n        var g = this,\n            f = g.series,\n            h = g.graphic,\n            n,\n            l = f.chart,\n            v = f.options;\n        b = m(b, !0);\n        !1 === d ? e() : g.firePointEvent(\"update\", {\n          options: a\n        }, e);\n      },\n      remove: function (a, b) {\n        this.series.removePoint(this.series.data.indexOf(this), a, b);\n      }\n    });\n    a(r.prototype, {\n      addPoint: function (a, c, d, f, h) {\n        var e = this.options,\n            g = this.data,\n            n = this.chart,\n            l = this.xAxis;\n        l = l && l.hasNames && l.names;\n        var A = e.data,\n            v = this.xData,\n            r;\n        c = m(c, !0);\n        var p = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(p, [a]);\n        var q = p.x;\n        var F = v.length;\n        if (this.requireSorting && q < v[F - 1]) for (r = !0; F && v[F - 1] > q;) F--;\n        this.updateParallelArrays(p, \"splice\", F, 0, 0);\n        this.updateParallelArrays(p, F);\n        l && p.name && (l[q] = p.name);\n        A.splice(F, 0, a);\n        r && (this.data.splice(F, 0, null), this.processData());\n        \"point\" === e.legendType && this.generatePoints();\n        d && (g[0] && g[0].remove ? g[0].remove(!1) : (g.shift(), this.updateParallelArrays(p, \"shift\"), A.shift()));\n        !1 !== h && b(this, \"addPoint\", {\n          point: p\n        });\n        this.isDirtyData = this.isDirty = !0;\n        c && n.redraw(f);\n      },\n      removePoint: function (a, b, c) {\n        var d = this,\n            e = d.data,\n            g = e[a],\n            f = d.points,\n            h = d.chart,\n            n = function () {\n          f && f.length === e.length && f.splice(a, 1);\n          e.splice(a, 1);\n          d.options.data.splice(a, 1);\n          d.updateParallelArrays(g || {\n            series: d\n          }, \"splice\", a, 1);\n          g && g.destroy();\n          d.isDirty = !0;\n          d.isDirtyData = !0;\n          b && h.redraw();\n        };\n\n        v(c, h);\n        b = m(b, !0);\n        g ? g.firePointEvent(\"remove\", null, n) : n();\n      },\n      remove: function (a, c, d, f) {\n        function e() {\n          g.destroy(f);\n          g.remove = null;\n          h.isDirtyLegend = h.isDirtyBox = !0;\n          h.linkSeries();\n          m(a, !0) && h.redraw(c);\n        }\n\n        var g = this,\n            h = g.chart;\n        !1 !== d ? b(g, \"remove\", null, e) : e();\n      },\n      update: function (c, e) {\n        c = d.cleanRecursively(c, this.userOptions);\n        b(this, \"update\", {\n          options: c\n        });\n        var g = this,\n            h = g.chart,\n            n = g.userOptions,\n            l = g.initialType || g.type,\n            v = c.type || n.type || h.options.chart.type,\n            r = !(this.hasDerivedData || c.dataGrouping || v && v !== this.type || void 0 !== c.pointStart || c.pointInterval || c.pointIntervalUnit || c.keys),\n            p = x[l].prototype,\n            q,\n            k = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"],\n            u = [\"eventOptions\", \"navigatorSeries\", \"baseSeries\"],\n            t = g.finishedAnimating && {\n          animation: !1\n        },\n            y = {};\n        r && (u.push(\"data\", \"isDirtyData\", \"points\", \"processedXData\", \"processedYData\", \"xIncrement\", \"_hasPointMarkers\", \"_hasPointLabels\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== c.visible && u.push(\"area\", \"graph\"), g.parallelArrays.forEach(function (a) {\n          u.push(a + \"Data\");\n        }), c.data && this.setData(c.data, !1));\n        c = f(n, t, {\n          index: void 0 === n.index ? g.index : n.index,\n          pointStart: m(n.pointStart, g.xData[0])\n        }, !r && {\n          data: g.options.data\n        }, c);\n        r && c.data && (c.data = g.options.data);\n        u = k.concat(u);\n        u.forEach(function (a) {\n          u[a] = g[a];\n          delete g[a];\n        });\n        g.remove(!1, null, !1, !0);\n\n        for (q in p) g[q] = void 0;\n\n        x[v || l] ? a(g, x[v || l].prototype) : d.error(17, !0, h);\n        u.forEach(function (a) {\n          g[a] = u[a];\n        });\n        g.init(h, c);\n\n        if (r && this.points) {\n          var w = g.options;\n          !1 === w.visible ? (y.graphic = 1, y.dataLabel = 1) : g._hasPointLabels || (v = w.marker, p = w.dataLabels, v && (!1 === v.enabled || \"symbol\" in v) && (y.graphic = 1), p && !1 === p.enabled && (y.dataLabel = 1));\n          this.points.forEach(function (a) {\n            a && a.series && (a.resolveColor(), Object.keys(y).length && a.destroyElements(y), !1 === w.showInLegend && a.legendItem && h.legend.destroyItem(a));\n          }, this);\n        }\n\n        c.zIndex !== n.zIndex && k.forEach(function (a) {\n          g[a] && g[a].attr({\n            zIndex: c.zIndex\n          });\n        });\n        g.initialType = l;\n        h.linkSeries();\n        b(this, \"afterUpdate\");\n        m(e, !0) && h.redraw(r ? void 0 : !1);\n      },\n      setName: function (a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      }\n    });\n    a(p.prototype, {\n      update: function (b, c) {\n        var d = this.chart,\n            e = b && b.events || {};\n        b = f(this.userOptions, b);\n        d.options[this.coll].indexOf && (d.options[this.coll][d.options[this.coll].indexOf(this.userOptions)] = b);\n        t(d.options[this.coll].events, function (a, b) {\n          \"undefined\" === typeof e[b] && (e[b] = void 0);\n        });\n        this.destroy(!0);\n        this.init(d, a(b, {\n          events: e\n        }));\n        d.isDirtyBox = !0;\n        m(c, !0) && d.redraw();\n      },\n      remove: function (a) {\n        for (var b = this.chart, c = this.coll, d = this.series, f = d.length; f--;) d[f] && d[f].remove(!1);\n\n        D(b.axes, this);\n        D(b[c], this);\n        H(b.options[c]) ? b.options[c].splice(this.options.index, 1) : delete b.options[c];\n        b[c].forEach(function (a, b) {\n          a.options.index = a.userOptions.index = b;\n        });\n        this.destroy();\n        b.isDirtyBox = !0;\n        m(a, !0) && b.redraw();\n      },\n      setTitle: function (a, b) {\n        this.update({\n          title: a\n        }, b);\n      },\n      setCategories: function (a, b) {\n        this.update({\n          categories: a\n        }, b);\n      }\n    });\n  });\n  K(I, \"parts/AreaSeries.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.objectEach,\n        D = d.color,\n        H = d.pick,\n        E = d.Series;\n    k = d.seriesType;\n    k(\"area\", \"line\", {\n      softThreshold: !1,\n      threshold: 0\n    }, {\n      singleStacks: !1,\n      getStackPoints: function (d) {\n        var k = [],\n            t = [],\n            y = this.xAxis,\n            u = this.yAxis,\n            l = u.stacks[this.stackKey],\n            p = {},\n            q = this.index,\n            c = u.series,\n            a = c.length,\n            b = H(u.options.reversedStacks, !0) ? 1 : -1,\n            f;\n        d = d || this.points;\n\n        if (this.options.stacking) {\n          for (f = 0; f < d.length; f++) d[f].leftNull = d[f].rightNull = null, p[d[f].x] = d[f];\n\n          w(l, function (a, b) {\n            null !== a.total && t.push(b);\n          });\n          t.sort(function (a, b) {\n            return a - b;\n          });\n          var m = c.map(function (a) {\n            return a.visible;\n          });\n          t.forEach(function (c, d) {\n            var h = 0,\n                v,\n                n;\n            if (p[c] && !p[c].isNull) k.push(p[c]), [-1, 1].forEach(function (e) {\n              var g = 1 === e ? \"rightNull\" : \"leftNull\",\n                  h = 0,\n                  r = l[t[d + e]];\n              if (r) for (f = q; 0 <= f && f < a;) v = r.points[f], v || (f === q ? p[c][g] = !0 : m[f] && (n = l[c].points[f]) && (h -= n[1] - n[0])), f += b;\n              p[c][1 === e ? \"rightCliff\" : \"leftCliff\"] = h;\n            });else {\n              for (f = q; 0 <= f && f < a;) {\n                if (v = l[c].points[f]) {\n                  h = v[1];\n                  break;\n                }\n\n                f += b;\n              }\n\n              h = u.translate(h, 0, 1, 0, 1);\n              k.push({\n                isNull: !0,\n                plotX: y.translate(c, 0, 0, 0, 1),\n                x: c,\n                plotY: h,\n                yBottom: h\n              });\n            }\n          });\n        }\n\n        return k;\n      },\n      getGraphPath: function (k) {\n        var y = E.prototype.getGraphPath,\n            t = this.options,\n            w = t.stacking,\n            u = this.yAxis,\n            l,\n            p = [],\n            q = [],\n            c = this.index,\n            a = u.stacks[this.stackKey],\n            b = t.threshold,\n            f = Math.round(u.getThreshold(t.threshold));\n        t = d.pick(t.connectNulls, \"percent\" === w);\n\n        var m = function (d, h, e) {\n          var g = k[d];\n          d = w && a[g.x].points[c];\n          var n = g[e + \"Null\"] || 0;\n          e = g[e + \"Cliff\"] || 0;\n          g = !0;\n\n          if (e || n) {\n            var m = (n ? d[0] : d[1]) + e;\n            var l = d[0] + e;\n            g = !!n;\n          } else !w && k[h] && k[h].isNull && (m = l = b);\n\n          void 0 !== m && (q.push({\n            plotX: r,\n            plotY: null === m ? f : u.getThreshold(m),\n            isNull: g,\n            isCliff: !0\n          }), p.push({\n            plotX: r,\n            plotY: null === l ? f : u.getThreshold(l),\n            doCurve: !1\n          }));\n        };\n\n        k = k || this.points;\n        w && (k = this.getStackPoints(k));\n\n        for (l = 0; l < k.length; l++) {\n          var h = k[l].isNull;\n          var r = H(k[l].rectPlotX, k[l].plotX);\n          var x = H(k[l].yBottom, f);\n          if (!h || t) t || m(l, l - 1, \"left\"), h && !w && t || (q.push(k[l]), p.push({\n            x: l,\n            plotX: r,\n            plotY: x\n          })), t || m(l, l + 1, \"right\");\n        }\n\n        l = y.call(this, q, !0, !0);\n        p.reversed = !0;\n        h = y.call(this, p, !0, !0);\n        h.length && (h[0] = \"L\");\n        h = l.concat(h);\n        y = y.call(this, q, !1, t);\n        h.xMap = l.xMap;\n        this.areaPath = h;\n        return y;\n      },\n      drawGraph: function () {\n        this.areaPath = [];\n        E.prototype.drawGraph.apply(this);\n        var d = this,\n            k = this.areaPath,\n            t = this.options,\n            w = [[\"area\", \"highcharts-area\", this.color, t.fillColor]];\n        this.zones.forEach(function (k, l) {\n          w.push([\"zone-area-\" + l, \"highcharts-area highcharts-zone-area-\" + l + \" \" + k.className, k.color || d.color, k.fillColor || t.fillColor]);\n        });\n        w.forEach(function (u) {\n          var l = u[0],\n              p = d[l],\n              q = p ? \"animate\" : \"attr\",\n              c = {};\n          p ? (p.endX = d.preventGraphAnimation ? null : k.xMap, p.animate({\n            d: k\n          })) : (c.zIndex = 0, p = d[l] = d.chart.renderer.path(k).addClass(u[1]).add(d.group), p.isArea = !0);\n          d.chart.styledMode || (c.fill = H(u[3], D(u[2]).setOpacity(H(t.fillOpacity, .75)).get()));\n          p[q](c);\n          p.startX = k.xMap;\n          p.shiftUnit = t.step ? 2 : 1;\n        });\n      },\n      drawLegendSymbol: d.LegendSymbolMixin.drawRectangle\n    });\n    \"\";\n  });\n  K(I, \"parts/SplineSeries.js\", [I[\"parts/Globals.js\"]], function (d) {\n    var k = d.pick;\n    d = d.seriesType;\n    d(\"spline\", \"line\", {}, {\n      getPointSpline: function (d, D, H) {\n        var w = D.plotX,\n            y = D.plotY,\n            C = d[H - 1];\n        H = d[H + 1];\n\n        if (C && !C.isNull && !1 !== C.doCurve && !D.isCliff && H && !H.isNull && !1 !== H.doCurve && !D.isCliff) {\n          d = C.plotY;\n          var t = H.plotX;\n          H = H.plotY;\n          var G = 0;\n          var u = (1.5 * w + C.plotX) / 2.5;\n          var l = (1.5 * y + d) / 2.5;\n          t = (1.5 * w + t) / 2.5;\n          var p = (1.5 * y + H) / 2.5;\n          t !== u && (G = (p - l) * (t - w) / (t - u) + y - p);\n          l += G;\n          p += G;\n          l > d && l > y ? (l = Math.max(d, y), p = 2 * y - l) : l < d && l < y && (l = Math.min(d, y), p = 2 * y - l);\n          p > H && p > y ? (p = Math.max(H, y), l = 2 * y - p) : p < H && p < y && (p = Math.min(H, y), l = 2 * y - p);\n          D.rightContX = t;\n          D.rightContY = p;\n        }\n\n        D = [\"C\", k(C.rightContX, C.plotX), k(C.rightContY, C.plotY), k(u, w), k(l, y), w, y];\n        C.rightContX = C.rightContY = null;\n        return D;\n      }\n    });\n    \"\";\n  });\n  K(I, \"parts/AreaSplineSeries.js\", [I[\"parts/Globals.js\"]], function (d) {\n    var k = d.seriesTypes.area.prototype,\n        w = d.seriesType;\n    w(\"areaspline\", \"spline\", d.defaultPlotOptions.area, {\n      getStackPoints: k.getStackPoints,\n      getGraphPath: k.getGraphPath,\n      drawGraph: k.drawGraph,\n      drawLegendSymbol: d.LegendSymbolMixin.drawRectangle\n    });\n    \"\";\n  });\n  K(I, \"parts/ColumnSeries.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.isNumber,\n        H = d.animObject,\n        E = d.color,\n        y = d.extend,\n        C = d.merge,\n        t = d.pick,\n        G = d.Series;\n    k = d.seriesType;\n    var u = d.svg;\n    k(\"column\", \"line\", {\n      borderRadius: 0,\n      crisp: !0,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: null,\n        verticalAlign: null,\n        y: null\n      },\n      softThreshold: !1,\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    }, {\n      cropShoulder: 0,\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      negStacks: !0,\n      init: function () {\n        G.prototype.init.apply(this, arguments);\n        var d = this,\n            p = d.chart;\n        p.hasRendered && p.series.forEach(function (l) {\n          l.type === d.type && (l.isDirty = !0);\n        });\n      },\n      getColumnMetrics: function () {\n        var d = this,\n            p = d.options,\n            k = d.xAxis,\n            c = d.yAxis,\n            a = k.options.reversedStacks;\n        a = k.reversed && !a || !k.reversed && a;\n        var b,\n            f = {},\n            m = 0;\n        !1 === p.grouping ? m = 1 : d.chart.series.forEach(function (a) {\n          var h = a.yAxis,\n              e = a.options;\n\n          if (a.type === d.type && (a.visible || !d.chart.options.chart.ignoreHiddenSeries) && c.len === h.len && c.pos === h.pos) {\n            if (e.stacking) {\n              b = a.stackKey;\n              void 0 === f[b] && (f[b] = m++);\n              var g = f[b];\n            } else !1 !== e.grouping && (g = m++);\n\n            a.columnIndex = g;\n          }\n        });\n        var h = Math.min(Math.abs(k.transA) * (k.ordinalSlope || p.pointRange || k.closestPointRange || k.tickInterval || 1), k.len),\n            r = h * p.groupPadding,\n            x = (h - 2 * r) / (m || 1);\n        p = Math.min(p.maxPointWidth || k.len, t(p.pointWidth, x * (1 - 2 * p.pointPadding)));\n        d.columnMetrics = {\n          width: p,\n          offset: (x - p) / 2 + (r + ((d.columnIndex || 0) + (a ? 1 : 0)) * x - h / 2) * (a ? -1 : 1)\n        };\n        return d.columnMetrics;\n      },\n      crispCol: function (d, p, k, c) {\n        var a = this.chart,\n            b = this.borderWidth,\n            f = -(b % 2 ? .5 : 0);\n        b = b % 2 ? .5 : 1;\n        a.inverted && a.renderer.isVML && (b += 1);\n        this.options.crisp && (k = Math.round(d + k) + f, d = Math.round(d) + f, k -= d);\n        c = Math.round(p + c) + b;\n        f = .5 >= Math.abs(p) && .5 < c;\n        p = Math.round(p) + b;\n        c -= p;\n        f && c && (--p, c += 1);\n        return {\n          x: d,\n          y: p,\n          width: k,\n          height: c\n        };\n      },\n      translate: function () {\n        var d = this,\n            p = d.chart,\n            k = d.options,\n            c = d.dense = 2 > d.closestPointRange * d.xAxis.transA;\n        c = d.borderWidth = t(k.borderWidth, c ? 0 : 1);\n        var a = d.yAxis,\n            b = k.threshold,\n            f = d.translatedThreshold = a.getThreshold(b),\n            m = t(k.minPointLength, 5),\n            h = d.getColumnMetrics(),\n            r = h.width,\n            x = d.barW = Math.max(r, 1 + 2 * c),\n            v = d.pointXOffset = h.offset,\n            n = d.dataMin,\n            e = d.dataMax;\n        p.inverted && (f -= .5);\n        k.pointPadding && (x = Math.ceil(x));\n        G.prototype.translate.apply(d);\n        d.points.forEach(function (c) {\n          var g = t(c.yBottom, f),\n              h = 999 + Math.abs(g),\n              l = r;\n          h = Math.min(Math.max(-h, c.plotY), a.len + h);\n          var k = c.plotX + v,\n              q = x,\n              u = Math.min(h, g),\n              y = Math.max(h, g) - u;\n\n          if (m && Math.abs(y) < m) {\n            y = m;\n            var C = !a.reversed && !c.negative || a.reversed && c.negative;\n            c.y === b && d.dataMax <= b && a.min < b && n !== e && (C = !C);\n            u = Math.abs(u - f) > m ? g - m : f - (C ? m : 0);\n          }\n\n          w(c.options.pointWidth) && (l = q = Math.ceil(c.options.pointWidth), k -= Math.round((l - r) / 2));\n          c.barX = k;\n          c.pointWidth = l;\n          c.tooltipPos = p.inverted ? [a.len + a.pos - p.plotLeft - h, d.xAxis.len - k - q / 2, y] : [k + q / 2, h + a.pos - p.plotTop, y];\n          c.shapeType = d.pointClass.prototype.shapeType || \"rect\";\n          c.shapeArgs = d.crispCol.apply(d, c.isNull ? [k, f, q, 0] : [k, u, q, y]);\n        });\n      },\n      getSymbol: d.noop,\n      drawLegendSymbol: d.LegendSymbolMixin.drawRectangle,\n      drawGraph: function () {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      },\n      pointAttribs: function (d, p) {\n        var l = this.options,\n            c = this.pointAttrToOptions || {};\n        var a = c.stroke || \"borderColor\";\n        var b = c[\"stroke-width\"] || \"borderWidth\",\n            f = d && d.color || this.color,\n            m = d && d[a] || l[a] || this.color || f,\n            h = d && d[b] || l[b] || this[b] || 0;\n        c = d && d.options.dashStyle || l.dashStyle;\n        var r = t(l.opacity, 1);\n\n        if (d && this.zones.length) {\n          var k = d.getZone();\n          f = d.options.color || k && (k.color || d.nonZonedColor) || this.color;\n          k && (m = k.borderColor || m, c = k.dashStyle || c, h = k.borderWidth || h);\n        }\n\n        p && (d = C(l.states[p], d.options.states && d.options.states[p] || {}), p = d.brightness, f = d.color || void 0 !== p && E(f).brighten(d.brightness).get() || f, m = d[a] || m, h = d[b] || h, c = d.dashStyle || c, r = t(d.opacity, r));\n        a = {\n          fill: f,\n          stroke: m,\n          \"stroke-width\": h,\n          opacity: r\n        };\n        c && (a.dashstyle = c);\n        return a;\n      },\n      drawPoints: function () {\n        var d = this,\n            p = this.chart,\n            k = d.options,\n            c = p.renderer,\n            a = k.animationLimit || 250,\n            b;\n        d.points.forEach(function (f) {\n          var m = f.graphic,\n              h = m && p.pointCount < a ? \"animate\" : \"attr\";\n\n          if (D(f.plotY) && null !== f.y) {\n            b = f.shapeArgs;\n            m && m.element.nodeName !== f.shapeType && (m = m.destroy());\n            if (m) m[h](C(b));else f.graphic = m = c[f.shapeType](b).add(f.group || d.group);\n            if (k.borderRadius) m[h]({\n              r: k.borderRadius\n            });\n            p.styledMode || m[h](d.pointAttribs(f, f.selected && \"select\")).shadow(!1 !== f.allowShadow && k.shadow, null, k.stacking && !k.borderRadius);\n            m.addClass(f.getClassName(), !0);\n          } else m && (f.graphic = m.destroy());\n        });\n      },\n      animate: function (d) {\n        var l = this,\n            k = this.yAxis,\n            c = l.options,\n            a = this.chart.inverted,\n            b = {},\n            f = a ? \"translateX\" : \"translateY\";\n        if (u) if (d) b.scaleY = .001, d = Math.min(k.pos + k.len, Math.max(k.pos, k.toPixels(c.threshold))), a ? b.translateX = d - k.len : b.translateY = d, l.clipBox && l.setClip(), l.group.attr(b);else {\n          var m = l.group.attr(f);\n          l.group.animate({\n            scaleY: 1\n          }, y(H(l.options.animation), {\n            step: function (a, c) {\n              b[f] = m + c.pos * (k.pos - m);\n              l.group.attr(b);\n            }\n          }));\n          l.animate = null;\n        }\n      },\n      remove: function () {\n        var d = this,\n            k = d.chart;\n        k.hasRendered && k.series.forEach(function (l) {\n          l.type === d.type && (l.isDirty = !0);\n        });\n        G.prototype.remove.apply(d, arguments);\n      }\n    });\n    \"\";\n  });\n  K(I, \"parts/BarSeries.js\", [I[\"parts/Globals.js\"]], function (d) {\n    d = d.seriesType;\n    d(\"bar\", \"column\", null, {\n      inverted: !0\n    });\n    \"\";\n  });\n  K(I, \"parts/ScatterSeries.js\", [I[\"parts/Globals.js\"]], function (d) {\n    var k = d.Series,\n        w = d.seriesType;\n    w(\"scatter\", \"line\", {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>',\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n      }\n    }, {\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1,\n      drawGraph: function () {\n        this.options.lineWidth && k.prototype.drawGraph.call(this);\n      },\n      applyJitter: function () {\n        var d = this,\n            k = this.options.jitter,\n            w = this.points.length;\n        k && this.points.forEach(function (y, C) {\n          [\"x\", \"y\"].forEach(function (t, G) {\n            var u = \"plot\" + t.toUpperCase();\n\n            if (k[t] && !y.isNull) {\n              var l = d[t + \"Axis\"];\n              var p = k[t] * l.transA;\n\n              if (l && !l.isLog) {\n                var q = Math.max(0, y[u] - p);\n                l = Math.min(l.len, y[u] + p);\n                G = 1E4 * Math.sin(C + G * w);\n                y[u] = q + (l - q) * (G - Math.floor(G));\n                \"x\" === t && (y.clientX = y.plotX);\n              }\n            }\n          });\n        });\n      }\n    });\n    d.addEvent(k, \"afterTranslate\", function () {\n      this.applyJitter && this.applyJitter();\n    });\n    \"\";\n  });\n  K(I, \"mixins/centered-series.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.isNumber,\n        D = d.deg2rad,\n        H = d.pick,\n        E = d.relativeLength;\n    d.CenteredSeriesMixin = {\n      getCenter: function () {\n        var d = this.options,\n            k = this.chart,\n            t = 2 * (d.slicedOffset || 0),\n            w = k.plotWidth - 2 * t;\n        k = k.plotHeight - 2 * t;\n        var u = d.center;\n        u = [H(u[0], \"50%\"), H(u[1], \"50%\"), d.size || \"100%\", d.innerSize || 0];\n        var l = Math.min(w, k),\n            p;\n\n        for (p = 0; 4 > p; ++p) {\n          var q = u[p];\n          d = 2 > p || 2 === p && /%$/.test(q);\n          u[p] = E(q, [w, k, l, u[2]][p]) + (d ? t : 0);\n        }\n\n        u[3] > u[2] && (u[3] = u[2]);\n        return u;\n      },\n      getStartAndEndRadians: function (d, k) {\n        d = w(d) ? d : 0;\n        k = w(k) && k > d && 360 > k - d ? k : d + 360;\n        return {\n          start: D * (d + -90),\n          end: D * (k + -90)\n        };\n      }\n    };\n  });\n  K(I, \"parts/PieSeries.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.isNumber,\n        H = d.addEvent;\n    k = d.CenteredSeriesMixin;\n    var E = k.getStartAndEndRadians,\n        y = d.merge,\n        C = d.noop,\n        t = d.pick,\n        G = d.Point,\n        u = d.Series,\n        l = d.seriesType,\n        p = d.fireEvent,\n        q = d.setAnimation;\n    l(\"pie\", \"line\", {\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        distance: 30,\n        enabled: !0,\n        formatter: function () {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0,\n        connectorShape: \"fixedOffset\",\n        crookDistance: \"70%\"\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    }, {\n      isCartesian: !1,\n      requireSorting: !1,\n      directTouch: !0,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      axisTypes: [],\n      pointAttribs: d.seriesTypes.column.prototype.pointAttribs,\n      animate: function (c) {\n        var a = this,\n            b = a.points,\n            d = a.startAngleRad;\n        c || (b.forEach(function (b) {\n          var c = b.graphic,\n              f = b.shapeArgs;\n          c && (c.attr({\n            r: b.startR || a.center[3] / 2,\n            start: d,\n            end: d\n          }), c.animate({\n            r: f.r,\n            start: f.start,\n            end: f.end\n          }, a.options.animation));\n        }), a.animate = null);\n      },\n      hasData: function () {\n        return !!this.processedXData.length;\n      },\n      updateTotals: function () {\n        var c,\n            a = 0,\n            b = this.points,\n            d = b.length,\n            m = this.options.ignoreHiddenPoint;\n\n        for (c = 0; c < d; c++) {\n          var h = b[c];\n          a += m && !h.visible ? 0 : h.isNull ? 0 : h.y;\n        }\n\n        this.total = a;\n\n        for (c = 0; c < d; c++) h = b[c], h.percentage = 0 < a && (h.visible || !m) ? h.y / a * 100 : 0, h.total = a;\n      },\n      generatePoints: function () {\n        u.prototype.generatePoints.call(this);\n        this.updateTotals();\n      },\n      getX: function (c, a, b) {\n        var d = this.center,\n            m = this.radii ? this.radii[b.index] : d[2] / 2;\n        return d[0] + (a ? -1 : 1) * Math.cos(Math.asin(Math.max(Math.min((c - d[1]) / (m + b.labelDistance), 1), -1))) * (m + b.labelDistance) + (0 < b.labelDistance ? (a ? -1 : 1) * this.options.dataLabels.padding : 0);\n      },\n      translate: function (c) {\n        this.generatePoints();\n        var a = 0,\n            b = this.options,\n            f = b.slicedOffset,\n            m = f + (b.borderWidth || 0),\n            h = E(b.startAngle, b.endAngle),\n            l = this.startAngleRad = h.start;\n        h = (this.endAngleRad = h.end) - l;\n        var k = this.points,\n            v = b.dataLabels.distance;\n        b = b.ignoreHiddenPoint;\n        var n,\n            e = k.length;\n        c || (this.center = c = this.getCenter());\n\n        for (n = 0; n < e; n++) {\n          var g = k[n];\n          var F = l + a * h;\n          if (!b || g.visible) a += g.percentage / 100;\n          var A = l + a * h;\n          g.shapeType = \"arc\";\n          g.shapeArgs = {\n            x: c[0],\n            y: c[1],\n            r: c[2] / 2,\n            innerR: c[3] / 2,\n            start: Math.round(1E3 * F) / 1E3,\n            end: Math.round(1E3 * A) / 1E3\n          };\n          g.labelDistance = t(g.options.dataLabels && g.options.dataLabels.distance, v);\n          g.labelDistance = d.relativeLength(g.labelDistance, g.shapeArgs.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, g.labelDistance);\n          A = (A + F) / 2;\n          A > 1.5 * Math.PI ? A -= 2 * Math.PI : A < -Math.PI / 2 && (A += 2 * Math.PI);\n          g.slicedTranslation = {\n            translateX: Math.round(Math.cos(A) * f),\n            translateY: Math.round(Math.sin(A) * f)\n          };\n          var z = Math.cos(A) * c[2] / 2;\n          var q = Math.sin(A) * c[2] / 2;\n          g.tooltipPos = [c[0] + .7 * z, c[1] + .7 * q];\n          g.half = A < -Math.PI / 2 || A > Math.PI / 2 ? 1 : 0;\n          g.angle = A;\n          F = Math.min(m, g.labelDistance / 5);\n          g.labelPosition = {\n            natural: {\n              x: c[0] + z + Math.cos(A) * g.labelDistance,\n              y: c[1] + q + Math.sin(A) * g.labelDistance\n            },\n            \"final\": {},\n            alignment: 0 > g.labelDistance ? \"center\" : g.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: c[0] + z + Math.cos(A) * F,\n                y: c[1] + q + Math.sin(A) * F\n              },\n              touchingSliceAt: {\n                x: c[0] + z,\n                y: c[1] + q\n              }\n            }\n          };\n        }\n\n        p(this, \"afterTranslate\");\n      },\n      drawEmpty: function () {\n        var c = this.options;\n\n        if (0 === this.total) {\n          var a = this.center[0];\n          var b = this.center[1];\n          this.graph || (this.graph = this.chart.renderer.circle(a, b, 0).addClass(\"highcharts-graph\").add(this.group));\n          this.graph.animate({\n            \"stroke-width\": c.borderWidth,\n            cx: a,\n            cy: b,\n            r: this.center[2] / 2,\n            fill: c.fillColor || \"none\",\n            stroke: c.color || \"#cccccc\"\n          });\n        } else this.graph && (this.graph = this.graph.destroy());\n      },\n      redrawPoints: function () {\n        var c = this,\n            a = c.chart,\n            b = a.renderer,\n            d,\n            m,\n            h,\n            l,\n            k = c.options.shadow;\n        this.drawEmpty();\n        !k || c.shadowGroup || a.styledMode || (c.shadowGroup = b.g(\"shadow\").attr({\n          zIndex: -1\n        }).add(c.group));\n        c.points.forEach(function (f) {\n          var n = {};\n          m = f.graphic;\n\n          if (!f.isNull && m) {\n            l = f.shapeArgs;\n            d = f.getTranslate();\n\n            if (!a.styledMode) {\n              var e = f.shadowGroup;\n              k && !e && (e = f.shadowGroup = b.g(\"shadow\").add(c.shadowGroup));\n              e && e.attr(d);\n              h = c.pointAttribs(f, f.selected && \"select\");\n            }\n\n            f.delayedRendering ? (m.setRadialReference(c.center).attr(l).attr(d), a.styledMode || m.attr(h).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(k, e), f.delayedRendering = !1) : (m.setRadialReference(c.center), a.styledMode || y(!0, n, h), y(!0, n, l, d), m.animate(n));\n            m.attr({\n              visibility: f.visible ? \"inherit\" : \"hidden\"\n            });\n            m.addClass(f.getClassName());\n          } else m && (f.graphic = m.destroy());\n        });\n      },\n      drawPoints: function () {\n        var c = this.chart.renderer;\n        this.points.forEach(function (a) {\n          a.graphic || (a.graphic = c[a.shapeType](a.shapeArgs).add(a.series.group), a.delayedRendering = !0);\n        });\n      },\n      searchPoint: C,\n      sortByAngle: function (c, a) {\n        c.sort(function (b, c) {\n          return void 0 !== b.angle && (c.angle - b.angle) * a;\n        });\n      },\n      drawLegendSymbol: d.LegendSymbolMixin.drawRectangle,\n      getCenter: k.getCenter,\n      getSymbol: C,\n      drawGraph: null\n    }, {\n      init: function () {\n        G.prototype.init.apply(this, arguments);\n        var c = this;\n        c.name = t(c.name, \"Slice\");\n\n        var a = function (a) {\n          c.slice(\"select\" === a.type);\n        };\n\n        H(c, \"select\", a);\n        H(c, \"unselect\", a);\n        return c;\n      },\n      isValid: function () {\n        return D(this.y) && 0 <= this.y;\n      },\n      setVisible: function (c, a) {\n        var b = this,\n            d = b.series,\n            m = d.chart,\n            h = d.options.ignoreHiddenPoint;\n        a = t(a, h);\n        c !== b.visible && (b.visible = b.options.visible = c = void 0 === c ? !b.visible : c, d.options.data[d.data.indexOf(b)] = b.options, [\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"].forEach(function (a) {\n          if (b[a]) b[a][c ? \"show\" : \"hide\"](!0);\n        }), b.legendItem && m.legend.colorizeItem(b, c), c || \"hover\" !== b.state || b.setState(\"\"), h && (d.isDirty = !0), a && m.redraw());\n      },\n      slice: function (c, a, b) {\n        var d = this.series;\n        q(b, d.chart);\n        t(a, !0);\n        this.sliced = this.options.sliced = w(c) ? c : !this.sliced;\n        d.options.data[d.data.indexOf(this)] = this.options;\n        this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      },\n      getTranslate: function () {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      },\n      haloPath: function (c) {\n        var a = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(a.x, a.y, a.r + c, a.r + c, {\n          innerR: a.r - 1,\n          start: a.start,\n          end: a.end\n        });\n      },\n      connectorShapes: {\n        fixedOffset: function (c, a, b) {\n          var d = a.breakAt;\n          a = a.touchingSliceAt;\n          return [\"M\", c.x, c.y].concat(b.softConnector ? [\"C\", c.x + (\"left\" === c.alignment ? -5 : 5), c.y, 2 * d.x - a.x, 2 * d.y - a.y, d.x, d.y] : [\"L\", d.x, d.y]).concat([\"L\", a.x, a.y]);\n        },\n        straight: function (c, a) {\n          a = a.touchingSliceAt;\n          return [\"M\", c.x, c.y, \"L\", a.x, a.y];\n        },\n        crookedLine: function (c, a, b) {\n          a = a.touchingSliceAt;\n          var f = this.series,\n              m = f.center[0],\n              h = f.chart.plotWidth,\n              l = f.chart.plotLeft;\n          f = c.alignment;\n          var k = this.shapeArgs.r;\n          b = d.relativeLength(b.crookDistance, 1);\n          b = \"left\" === f ? m + k + (h + l - m - k) * (1 - b) : l + (m - k) * b;\n          m = [\"L\", b, c.y];\n          if (\"left\" === f ? b > c.x || b < a.x : b < c.x || b > a.x) m = [];\n          return [\"M\", c.x, c.y].concat(m).concat([\"L\", a.x, a.y]);\n        }\n      },\n      getConnectorPath: function () {\n        var c = this.labelPosition,\n            a = this.series.options.dataLabels,\n            b = a.connectorShape,\n            d = this.connectorShapes;\n        d[b] && (b = d[b]);\n        return b.call(this, {\n          x: c.final.x,\n          y: c.final.y,\n          alignment: c.alignment\n        }, c.connectorPosition, a);\n      }\n    });\n    \"\";\n  });\n  K(I, \"parts/DataLabels.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.isArray,\n        H = k.objectEach,\n        E = k.splat,\n        y = d.arrayMax,\n        C = d.extend,\n        t = d.format,\n        G = d.merge;\n    k = d.noop;\n    var u = d.pick,\n        l = d.relativeLength,\n        p = d.Series,\n        q = d.seriesTypes,\n        c = d.stableSort;\n\n    d.distribute = function (a, b, f) {\n      function m(a, b) {\n        return a.target - b.target;\n      }\n\n      var h,\n          l = !0,\n          k = a,\n          v = [];\n      var n = 0;\n      var e = k.reducedLen || b;\n\n      for (h = a.length; h--;) n += a[h].size;\n\n      if (n > e) {\n        c(a, function (a, b) {\n          return (b.rank || 0) - (a.rank || 0);\n        });\n\n        for (n = h = 0; n <= e;) n += a[h].size, h++;\n\n        v = a.splice(h - 1, a.length);\n      }\n\n      c(a, m);\n\n      for (a = a.map(function (a) {\n        return {\n          size: a.size,\n          targets: [a.target],\n          align: u(a.align, .5)\n        };\n      }); l;) {\n        for (h = a.length; h--;) l = a[h], n = (Math.min.apply(0, l.targets) + Math.max.apply(0, l.targets)) / 2, l.pos = Math.min(Math.max(0, n - l.size * l.align), b - l.size);\n\n        h = a.length;\n\n        for (l = !1; h--;) 0 < h && a[h - 1].pos + a[h - 1].size > a[h].pos && (a[h - 1].size += a[h].size, a[h - 1].targets = a[h - 1].targets.concat(a[h].targets), a[h - 1].align = .5, a[h - 1].pos + a[h - 1].size > b && (a[h - 1].pos = b - a[h - 1].size), a.splice(h, 1), l = !0);\n      }\n\n      k.push.apply(k, v);\n      h = 0;\n      a.some(function (a) {\n        var c = 0;\n        if (a.targets.some(function () {\n          k[h].pos = a.pos + c;\n          if (Math.abs(k[h].pos - k[h].target) > f) return k.slice(0, h + 1).forEach(function (a) {\n            delete a.pos;\n          }), k.reducedLen = (k.reducedLen || b) - .1 * b, k.reducedLen > .1 * b && d.distribute(k, b, f), !0;\n          c += k[h].size;\n          h++;\n        })) return !0;\n      });\n      c(k, m);\n    };\n\n    p.prototype.drawDataLabels = function () {\n      function a(a, b) {\n        var c = b.filter;\n        return c ? (b = c.operator, a = a[c.property], c = c.value, \">\" === b && a > c || \"<\" === b && a < c || \">=\" === b && a >= c || \"<=\" === b && a <= c || \"==\" === b && a == c || \"===\" === b && a === c ? !0 : !1) : !0;\n      }\n\n      function b(a, b) {\n        var c = [],\n            d;\n        if (D(a) && !D(b)) c = a.map(function (a) {\n          return G(a, b);\n        });else if (D(b) && !D(a)) c = b.map(function (b) {\n          return G(a, b);\n        });else if (D(a) || D(b)) for (d = Math.max(a.length, b.length); d--;) c[d] = G(a[d], b[d]);else c = G(a, b);\n        return c;\n      }\n\n      var c = this,\n          m = c.chart,\n          h = c.options,\n          l = h.dataLabels,\n          k = c.points,\n          v,\n          n = c.hasRendered || 0,\n          e = d.animObject(h.animation).duration,\n          g = Math.min(e, 200),\n          p = !m.renderer.forExport && u(l.defer, 0 < g),\n          A = m.renderer;\n      l = b(b(m.options.plotOptions && m.options.plotOptions.series && m.options.plotOptions.series.dataLabels, m.options.plotOptions && m.options.plotOptions[c.type] && m.options.plotOptions[c.type].dataLabels), l);\n      d.fireEvent(this, \"drawDataLabels\");\n\n      if (D(l) || l.enabled || c._hasPointLabels) {\n        var q = c.plotGroup(\"dataLabelsGroup\", \"data-labels\", p && !n ? \"hidden\" : \"inherit\", l.zIndex || 6);\n        p && (q.attr({\n          opacity: +n\n        }), n || setTimeout(function () {\n          var a = c.dataLabelsGroup;\n          a && (c.visible && q.show(!0), a[h.animation ? \"animate\" : \"attr\"]({\n            opacity: 1\n          }, {\n            duration: g\n          }));\n        }, e - g));\n        k.forEach(function (d) {\n          v = E(b(l, d.dlOptions || d.options && d.options.dataLabels));\n          v.forEach(function (b, e) {\n            var g = b.enabled && (!d.isNull || d.dataLabelOnNull) && a(d, b),\n                f = d.dataLabels ? d.dataLabels[e] : d.dataLabel,\n                n = d.connectors ? d.connectors[e] : d.connector,\n                l = u(b.distance, d.labelDistance),\n                v = !f;\n\n            if (g) {\n              var k = d.getLabelConfig();\n              var r = u(b[d.formatPrefix + \"Format\"], b.format);\n              k = w(r) ? t(r, k, m.time) : (b[d.formatPrefix + \"Formatter\"] || b.formatter).call(k, b);\n              r = b.style;\n              var p = b.rotation;\n              m.styledMode || (r.color = u(b.color, r.color, c.color, \"#000000\"), \"contrast\" === r.color && (d.contrastColor = A.getContrast(d.color || c.color), r.color = !w(l) && b.inside || 0 > l || h.stacking ? d.contrastColor : \"#000000\"), h.cursor && (r.cursor = h.cursor));\n              var z = {\n                r: b.borderRadius || 0,\n                rotation: p,\n                padding: b.padding,\n                zIndex: 1\n              };\n              m.styledMode || (z.fill = b.backgroundColor, z.stroke = b.borderColor, z[\"stroke-width\"] = b.borderWidth);\n              H(z, function (a, b) {\n                void 0 === a && delete z[b];\n              });\n            }\n\n            !f || g && w(k) ? g && w(k) && (f ? z.text = k : (d.dataLabels = d.dataLabels || [], f = d.dataLabels[e] = p ? A.text(k, 0, -9999).addClass(\"highcharts-data-label\") : A.label(k, 0, -9999, b.shape, null, null, b.useHTML, null, \"data-label\"), e || (d.dataLabel = f), f.addClass(\" highcharts-data-label-color-\" + d.colorIndex + \" \" + (b.className || \"\") + (b.useHTML ? \" highcharts-tracker\" : \"\"))), f.options = b, f.attr(z), m.styledMode || f.css(r).shadow(b.shadow), f.added || f.add(q), b.textPath && !b.useHTML && f.setTextPath(d.getDataLabelPath && d.getDataLabelPath(f) || d.graphic, b.textPath), c.alignDataLabel(d, f, b, null, v)) : (d.dataLabel = d.dataLabel && d.dataLabel.destroy(), d.dataLabels && (1 === d.dataLabels.length ? delete d.dataLabels : delete d.dataLabels[e]), e || delete d.dataLabel, n && (d.connector = d.connector.destroy(), d.connectors && (1 === d.connectors.length ? delete d.connectors : delete d.connectors[e])));\n          });\n        });\n      }\n\n      d.fireEvent(this, \"afterDrawDataLabels\");\n    };\n\n    p.prototype.alignDataLabel = function (a, b, c, d, h) {\n      var f = this.chart,\n          m = this.isCartesian && f.inverted,\n          l = u(a.dlBox && a.dlBox.centerX, a.plotX, -9999),\n          n = u(a.plotY, -9999),\n          e = b.getBBox(),\n          g = c.rotation,\n          k = c.align,\n          A = this.visible && (a.series.forceDL || f.isInsidePlot(l, Math.round(n), m) || d && f.isInsidePlot(l, m ? d.x + 1 : d.y + d.height - 1, m)),\n          p = \"justify\" === u(c.overflow, \"justify\");\n\n      if (A) {\n        var q = f.renderer.fontMetrics(f.styledMode ? void 0 : c.style.fontSize, b).b;\n        d = C({\n          x: m ? this.yAxis.len - n : l,\n          y: Math.round(m ? this.xAxis.len - l : n),\n          width: 0,\n          height: 0\n        }, d);\n        C(c, {\n          width: e.width,\n          height: e.height\n        });\n        g ? (p = !1, l = f.renderer.rotCorr(q, g), l = {\n          x: d.x + c.x + d.width / 2 + l.x,\n          y: d.y + c.y + {\n            top: 0,\n            middle: .5,\n            bottom: 1\n          }[c.verticalAlign] * d.height\n        }, b[h ? \"attr\" : \"animate\"](l).attr({\n          align: k\n        }), n = (g + 720) % 360, n = 180 < n && 360 > n, \"left\" === k ? l.y -= n ? e.height : 0 : \"center\" === k ? (l.x -= e.width / 2, l.y -= e.height / 2) : \"right\" === k && (l.x -= e.width, l.y -= n ? 0 : e.height), b.placed = !0, b.alignAttr = l) : (b.align(c, null, d), l = b.alignAttr);\n        p && 0 <= d.height ? this.justifyDataLabel(b, c, l, e, d, h) : u(c.crop, !0) && (A = f.isInsidePlot(l.x, l.y) && f.isInsidePlot(l.x + e.width, l.y + e.height));\n        if (c.shape && !g) b[h ? \"attr\" : \"animate\"]({\n          anchorX: m ? f.plotWidth - a.plotY : a.plotX,\n          anchorY: m ? f.plotHeight - a.plotX : a.plotY\n        });\n      }\n\n      A || (b.hide(!0), b.placed = !1);\n    };\n\n    p.prototype.justifyDataLabel = function (a, b, c, d, h, l) {\n      var f = this.chart,\n          m = b.align,\n          n = b.verticalAlign,\n          e = a.box ? 0 : a.padding || 0;\n      var g = c.x + e;\n\n      if (0 > g) {\n        \"right\" === m ? (b.align = \"left\", b.inside = !0) : b.x = -g;\n        var k = !0;\n      }\n\n      g = c.x + d.width - e;\n      g > f.plotWidth && (\"left\" === m ? (b.align = \"right\", b.inside = !0) : b.x = f.plotWidth - g, k = !0);\n      g = c.y + e;\n      0 > g && (\"bottom\" === n ? (b.verticalAlign = \"top\", b.inside = !0) : b.y = -g, k = !0);\n      g = c.y + d.height - e;\n      g > f.plotHeight && (\"top\" === n ? (b.verticalAlign = \"bottom\", b.inside = !0) : b.y = f.plotHeight - g, k = !0);\n      k && (a.placed = !l, a.align(b, null, h));\n      return k;\n    };\n\n    q.pie && (q.pie.prototype.dataLabelPositioners = {\n      radialDistributionY: function (a) {\n        return a.top + a.distributeBox.pos;\n      },\n      radialDistributionX: function (a, b, c, d) {\n        return a.getX(c < b.top + 2 || c > b.bottom - 2 ? d : c, b.half, b);\n      },\n      justify: function (a, b, c) {\n        return c[0] + (a.half ? -1 : 1) * (b + a.labelDistance);\n      },\n      alignToPlotEdges: function (a, b, c, d) {\n        a = a.getBBox().width;\n        return b ? a + d : c - a - d;\n      },\n      alignToConnectors: function (a, b, c, d) {\n        var f = 0,\n            m;\n        a.forEach(function (a) {\n          m = a.dataLabel.getBBox().width;\n          m > f && (f = m);\n        });\n        return b ? f + d : c - f - d;\n      }\n    }, q.pie.prototype.drawDataLabels = function () {\n      var a = this,\n          b = a.data,\n          c,\n          m = a.chart,\n          h = a.options.dataLabels,\n          l = h.connectorPadding,\n          k,\n          v = m.plotWidth,\n          n = m.plotHeight,\n          e = m.plotLeft,\n          g = Math.round(m.chartWidth / 3),\n          q,\n          A = a.center,\n          z = A[2] / 2,\n          B = A[1],\n          t,\n          C,\n          E,\n          D,\n          H = [[], []],\n          L,\n          I,\n          O,\n          K,\n          W = [0, 0, 0, 0],\n          da = a.dataLabelPositioners,\n          X;\n      a.visible && (h.enabled || a._hasPointLabels) && (b.forEach(function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n          width: \"auto\"\n        }).css({\n          width: \"auto\",\n          textOverflow: \"clip\"\n        }), a.dataLabel.shortened = !1);\n      }), p.prototype.drawDataLabels.apply(a), b.forEach(function (a) {\n        a.dataLabel && (a.visible ? (H[a.half].push(a), a.dataLabel._pos = null, !w(h.style.width) && !w(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > g && (a.dataLabel.css({\n          width: .7 * g\n        }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n      }), H.forEach(function (b, g) {\n        var f = b.length,\n            k = [],\n            r;\n\n        if (f) {\n          a.sortByAngle(b, g - .5);\n\n          if (0 < a.maxLabelDistance) {\n            var p = Math.max(0, B - z - a.maxLabelDistance);\n            var q = Math.min(B + z + a.maxLabelDistance, m.plotHeight);\n            b.forEach(function (a) {\n              0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, B - z - a.labelDistance), a.bottom = Math.min(B + z + a.labelDistance, m.plotHeight), r = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n                target: a.labelPosition.natural.y - a.top + r / 2,\n                size: r,\n                rank: a.y\n              }, k.push(a.distributeBox));\n            });\n            p = q + r - p;\n            d.distribute(k, p, p / 5);\n          }\n\n          for (K = 0; K < f; K++) {\n            c = b[K];\n            E = c.labelPosition;\n            t = c.dataLabel;\n            O = !1 === c.visible ? \"hidden\" : \"inherit\";\n            I = p = E.natural.y;\n            k && w(c.distributeBox) && (void 0 === c.distributeBox.pos ? O = \"hidden\" : (D = c.distributeBox.size, I = da.radialDistributionY(c)));\n            delete c.positionIndex;\n            if (h.justify) L = da.justify(c, z, A);else switch (h.alignTo) {\n              case \"connectors\":\n                L = da.alignToConnectors(b, g, v, e);\n                break;\n\n              case \"plotEdges\":\n                L = da.alignToPlotEdges(t, g, v, e);\n                break;\n\n              default:\n                L = da.radialDistributionX(a, c, I, p);\n            }\n            t._attr = {\n              visibility: O,\n              align: E.alignment\n            };\n            t._pos = {\n              x: L + h.x + ({\n                left: l,\n                right: -l\n              }[E.alignment] || 0),\n              y: I + h.y - 10\n            };\n            E.final.x = L;\n            E.final.y = I;\n            u(h.crop, !0) && (C = t.getBBox().width, p = null, L - C < l && 1 === g ? (p = Math.round(C - L + l), W[3] = Math.max(p, W[3])) : L + C > v - l && 0 === g && (p = Math.round(L + C - v + l), W[1] = Math.max(p, W[1])), 0 > I - D / 2 ? W[0] = Math.max(Math.round(-I + D / 2), W[0]) : I + D / 2 > n && (W[2] = Math.max(Math.round(I + D / 2 - n), W[2])), t.sideOverflow = p);\n          }\n        }\n      }), 0 === y(W) || this.verifyDataLabelOverflow(W)) && (this.placeDataLabels(), this.points.forEach(function (b) {\n        X = G(h, b.options.dataLabels);\n\n        if (k = u(X.connectorWidth, 1)) {\n          var c;\n          q = b.connector;\n\n          if ((t = b.dataLabel) && t._pos && b.visible && 0 < b.labelDistance) {\n            O = t._attr.visibility;\n            if (c = !q) b.connector = q = m.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + b.colorIndex + (b.className ? \" \" + b.className : \"\")).add(a.dataLabelsGroup), m.styledMode || q.attr({\n              \"stroke-width\": k,\n              stroke: X.connectorColor || b.color || \"#666666\"\n            });\n            q[c ? \"attr\" : \"animate\"]({\n              d: b.getConnectorPath()\n            });\n            q.attr(\"visibility\", O);\n          } else q && (b.connector = q.destroy());\n        }\n      }));\n    }, q.pie.prototype.placeDataLabels = function () {\n      this.points.forEach(function (a) {\n        var b = a.dataLabel,\n            c;\n        b && a.visible && ((c = b._pos) ? (b.sideOverflow && (b._attr.width = Math.max(b.getBBox().width - b.sideOverflow, 0), b.css({\n          width: b._attr.width + \"px\",\n          textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n        }), b.shortened = !0), b.attr(b._attr), b[b.moved ? \"animate\" : \"attr\"](c), b.moved = !0) : b && b.attr({\n          y: -9999\n        }));\n        delete a.distributeBox;\n      }, this);\n    }, q.pie.prototype.alignDataLabel = k, q.pie.prototype.verifyDataLabelOverflow = function (a) {\n      var b = this.center,\n          c = this.options,\n          d = c.center,\n          h = c.minSize || 80,\n          k = null !== c.size;\n\n      if (!k) {\n        if (null !== d[0]) var p = Math.max(b[2] - Math.max(a[1], a[3]), h);else p = Math.max(b[2] - a[1] - a[3], h), b[0] += (a[3] - a[1]) / 2;\n        null !== d[1] ? p = Math.max(Math.min(p, b[2] - Math.max(a[0], a[2])), h) : (p = Math.max(Math.min(p, b[2] - a[0] - a[2]), h), b[1] += (a[0] - a[2]) / 2);\n        p < b[2] ? (b[2] = p, b[3] = Math.min(l(c.innerSize || 0, p), p), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : k = !0;\n      }\n\n      return k;\n    });\n    q.column && (q.column.prototype.alignDataLabel = function (a, b, c, d, h) {\n      var f = this.chart.inverted,\n          m = a.series,\n          l = a.dlBox || a.shapeArgs,\n          n = u(a.below, a.plotY > u(this.translatedThreshold, m.yAxis.len)),\n          e = u(c.inside, !!this.options.stacking);\n      l && (d = G(l), 0 > d.y && (d.height += d.y, d.y = 0), l = d.y + d.height - m.yAxis.len, 0 < l && (d.height -= l), f && (d = {\n        x: m.yAxis.len - d.y - d.height,\n        y: m.xAxis.len - d.x - d.width,\n        width: d.height,\n        height: d.width\n      }), e || (f ? (d.x += n ? 0 : d.width, d.width = 0) : (d.y += n ? d.height : 0, d.height = 0)));\n      c.align = u(c.align, !f || e ? \"center\" : n ? \"right\" : \"left\");\n      c.verticalAlign = u(c.verticalAlign, f || e ? \"middle\" : n ? \"top\" : \"bottom\");\n      p.prototype.alignDataLabel.call(this, a, b, c, d, h);\n      c.inside && a.contrastColor && b.css({\n        color: a.contrastColor\n      });\n    });\n  });\n  K(I, \"modules/overlapping-datalabels.src.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.isArray,\n        D = k.objectEach;\n    k = d.Chart;\n    var H = d.pick,\n        E = d.addEvent,\n        y = d.fireEvent;\n    E(k, \"render\", function () {\n      var d = [];\n      (this.labelCollectors || []).forEach(function (k) {\n        d = d.concat(k());\n      });\n      (this.yAxis || []).forEach(function (k) {\n        k.options.stackLabels && !k.options.stackLabels.allowOverlap && D(k.stacks, function (k) {\n          D(k, function (k) {\n            d.push(k.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (k) {\n        var t = k.options.dataLabels;\n        k.visible && (!1 !== t.enabled || k._hasPointLabels) && k.points.forEach(function (k) {\n          k.visible && (w(k.dataLabels) ? k.dataLabels : k.dataLabel ? [k.dataLabel] : []).forEach(function (l) {\n            var p = l.options;\n            l.labelrank = H(p.labelrank, k.labelrank, k.shapeArgs && k.shapeArgs.height);\n            p.allowOverlap || d.push(l);\n          });\n        });\n      });\n      this.hideOverlappingLabels(d);\n    });\n\n    k.prototype.hideOverlappingLabels = function (d) {\n      var k = this,\n          w = d.length,\n          u = k.renderer,\n          l,\n          p,\n          q;\n\n      var c = function (a) {\n        var b = a.box ? 0 : a.padding || 0;\n        var c = 0;\n\n        if (a && (!a.alignAttr || a.placed)) {\n          var d = a.alignAttr || {\n            x: a.attr(\"x\"),\n            y: a.attr(\"y\")\n          };\n          var f = a.parentGroup;\n          a.width || (c = a.getBBox(), a.width = c.width, a.height = c.height, c = u.fontMetrics(null, a.element).h);\n          return {\n            x: d.x + (f.translateX || 0) + b,\n            y: d.y + (f.translateY || 0) + b - c,\n            width: a.width - 2 * b,\n            height: a.height - 2 * b\n          };\n        }\n      };\n\n      for (p = 0; p < w; p++) if (l = d[p]) l.oldOpacity = l.opacity, l.newOpacity = 1, l.absoluteBox = c(l);\n\n      d.sort(function (a, b) {\n        return (b.labelrank || 0) - (a.labelrank || 0);\n      });\n\n      for (p = 0; p < w; p++) {\n        var a = (c = d[p]) && c.absoluteBox;\n\n        for (l = p + 1; l < w; ++l) {\n          var b = (q = d[l]) && q.absoluteBox;\n          !a || !b || c === q || 0 === c.newOpacity || 0 === q.newOpacity || b.x > a.x + a.width || b.x + b.width < a.x || b.y > a.y + a.height || b.y + b.height < a.y || ((c.labelrank < q.labelrank ? c : q).newOpacity = 0);\n        }\n      }\n\n      d.forEach(function (a) {\n        var b;\n\n        if (a) {\n          var c = a.newOpacity;\n          a.oldOpacity !== c && (a.alignAttr && a.placed ? (c ? a.show(!0) : b = function () {\n            a.hide(!0);\n            a.placed = !1;\n          }, a.alignAttr.opacity = c, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, b), y(k, \"afterHideOverlappingLabels\")) : a.attr({\n            opacity: c\n          }));\n          a.isOld = !0;\n        }\n      });\n    };\n  });\n  K(I, \"parts/Interaction.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.isArray,\n        H = k.isObject,\n        E = k.objectEach,\n        y = d.addEvent;\n    k = d.Chart;\n    var C = d.createElement,\n        t = d.css,\n        G = d.defaultOptions,\n        u = d.defaultPlotOptions,\n        l = d.extend,\n        p = d.fireEvent,\n        q = d.hasTouch,\n        c = d.Legend,\n        a = d.merge,\n        b = d.pick,\n        f = d.Point,\n        m = d.Series,\n        h = d.seriesTypes,\n        r = d.svg;\n    var x = d.TrackerMixin = {\n      drawTrackerPoint: function () {\n        var a = this,\n            b = a.chart,\n            c = b.pointer,\n            d = function (a) {\n          var b = c.getPointFromEvent(a);\n          void 0 !== b && (c.isDirectTouch = !0, b.onMouseOver(a));\n        },\n            f;\n\n        a.points.forEach(function (a) {\n          f = D(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n          a.graphic && (a.graphic.element.point = a);\n          f.forEach(function (b) {\n            b.div ? b.div.point = a : b.element.point = a;\n          });\n        });\n        a._hasTracking || (a.trackerGroups.forEach(function (e) {\n          if (a[e]) {\n            a[e].addClass(\"highcharts-tracker\").on(\"mouseover\", d).on(\"mouseout\", function (a) {\n              c.onTrackerMouseOut(a);\n            });\n            if (q) a[e].on(\"touchstart\", d);\n            !b.styledMode && a.options.cursor && a[e].css(t).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        p(this, \"afterDrawTracker\");\n      },\n      drawTrackerGraph: function () {\n        var a = this,\n            b = a.options,\n            c = b.trackByArea,\n            d = [].concat(c ? a.areaPath : a.graphPath),\n            f = d.length,\n            h = a.chart,\n            m = h.pointer,\n            l = h.renderer,\n            k = h.options.tooltip.snap,\n            x = a.tracker,\n            u,\n            t = function () {\n          if (h.hoverSeries !== a) a.onMouseOver();\n        },\n            w = \"rgba(192,192,192,\" + (r ? .0001 : .002) + \")\";\n\n        if (f && !c) for (u = f + 1; u--;) \"M\" === d[u] && d.splice(u + 1, 0, d[u + 1] - k, d[u + 2], \"L\"), (u && \"M\" === d[u] || u === f) && d.splice(u, 0, \"L\", d[u - 2] + k, d[u - 1]);\n        x ? x.attr({\n          d: d\n        }) : a.graph && (a.tracker = l.path(d).attr({\n          visibility: a.visible ? \"visible\" : \"hidden\",\n          zIndex: 2\n        }).addClass(c ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), h.styledMode || a.tracker.attr({\n          \"stroke-linejoin\": \"round\",\n          stroke: w,\n          fill: c ? w : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (c ? 0 : 2 * k)\n        }), [a.tracker, a.markerGroup].forEach(function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", t).on(\"mouseout\", function (a) {\n            m.onTrackerMouseOut(a);\n          });\n          b.cursor && !h.styledMode && a.css({\n            cursor: b.cursor\n          });\n          if (q) a.on(\"touchstart\", t);\n        }));\n        p(this, \"afterDrawTracker\");\n      }\n    };\n    h.column && (h.column.prototype.drawTracker = x.drawTrackerPoint);\n    h.pie && (h.pie.prototype.drawTracker = x.drawTrackerPoint);\n    h.scatter && (h.scatter.prototype.drawTracker = x.drawTrackerPoint);\n    l(c.prototype, {\n      setItemEvents: function (b, c, d) {\n        var e = this,\n            h = e.chart.renderer.boxWrapper,\n            n = b instanceof f,\n            m = \"highcharts-legend-\" + (n ? \"point\" : \"series\") + \"-active\",\n            l = e.chart.styledMode;\n        (d ? c : b.legendGroup).on(\"mouseover\", function () {\n          b.visible && e.allItems.forEach(function (a) {\n            b !== a && a.setState(\"inactive\", !n);\n          });\n          b.setState(\"hover\");\n          b.visible && h.addClass(m);\n          l || c.css(e.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          e.chart.styledMode || c.css(a(b.visible ? e.itemStyle : e.itemHiddenStyle));\n          e.allItems.forEach(function (a) {\n            b !== a && a.setState(\"\", !n);\n          });\n          h.removeClass(m);\n          b.setState();\n        }).on(\"click\", function (a) {\n          var c = function () {\n            b.setVisible && b.setVisible();\n            e.allItems.forEach(function (a) {\n              b !== a && a.setState(b.visible ? \"inactive\" : \"\", !n);\n            });\n          };\n\n          h.removeClass(m);\n          a = {\n            browserEvent: a\n          };\n          b.firePointEvent ? b.firePointEvent(\"legendItemClick\", a, c) : p(b, \"legendItemClick\", a, c);\n        });\n      },\n      createCheckboxForItem: function (a) {\n        a.checkbox = C(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        y(a.checkbox, \"click\", function (b) {\n          p(a.series || a, \"checkboxClick\", {\n            checked: b.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    });\n    l(k.prototype, {\n      showResetZoom: function () {\n        function a() {\n          b.zoomOut();\n        }\n\n        var b = this,\n            c = G.lang,\n            d = b.options.chart.resetZoomButton,\n            f = d.theme,\n            h = f.states,\n            m = \"chart\" === d.relativeTo || \"spaceBox\" === d.relativeTo ? null : \"plotBox\";\n        p(this, \"beforeShowResetZoom\", null, function () {\n          b.resetZoomButton = b.renderer.button(c.resetZoom, null, null, a, f, h && h.hover).attr({\n            align: d.position.align,\n            title: c.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(d.position, !1, m);\n        });\n        p(this, \"afterShowResetZoom\");\n      },\n      zoomOut: function () {\n        p(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      },\n      zoom: function (a) {\n        var c = this,\n            d,\n            g = c.pointer,\n            f = !1,\n            h = c.inverted ? g.mouseDownX : g.mouseDownY;\n        !a || a.resetSelection ? (c.axes.forEach(function (a) {\n          d = a.zoom();\n        }), g.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {\n          var b = a.axis,\n              e = c.inverted ? b.left : b.top,\n              n = c.inverted ? e + b.width : e + b.height,\n              m = b.isXAxis,\n              l = !1;\n          if (!m && h >= e && h <= n || m || !w(h)) l = !0;\n          g[m ? \"zoomX\" : \"zoomY\"] && l && (d = b.zoom(a.min, a.max), b.displayBtn && (f = !0));\n        });\n        var m = c.resetZoomButton;\n        f && !m ? c.showResetZoom() : !f && H(m) && (c.resetZoomButton = m.destroy());\n        d && c.redraw(b(c.options.chart.animation, a && a.animation, 100 > c.pointCount));\n      },\n      pan: function (a, b) {\n        var c = this,\n            d = c.hoverPoints,\n            f;\n        p(this, \"pan\", {\n          originalEvent: a\n        }, function () {\n          d && d.forEach(function (a) {\n            a.setState();\n          });\n          (\"xy\" === b ? [1, 0] : [1]).forEach(function (b) {\n            b = c[b ? \"xAxis\" : \"yAxis\"][0];\n            var d = b.horiz,\n                e = a[d ? \"chartX\" : \"chartY\"];\n            d = d ? \"mouseDownX\" : \"mouseDownY\";\n            var g = c[d],\n                h = (b.pointRange || 0) / 2,\n                n = b.reversed && !c.inverted || !b.reversed && c.inverted ? -1 : 1,\n                m = b.getExtremes(),\n                l = b.toValue(g - e, !0) + h * n;\n            n = b.toValue(g + b.len - e, !0) - h * n;\n            var k = n < l;\n            g = k ? n : l;\n            l = k ? l : n;\n            n = Math.min(m.dataMin, h ? m.min : b.toValue(b.toPixels(m.min) - b.minPixelPadding));\n            h = Math.max(m.dataMax, h ? m.max : b.toValue(b.toPixels(m.max) + b.minPixelPadding));\n            k = n - g;\n            0 < k && (l += k, g = n);\n            k = l - h;\n            0 < k && (l = h, g -= k);\n            b.series.length && g !== m.min && l !== m.max && (b.setExtremes(g, l, !1, !1, {\n              trigger: \"pan\"\n            }), f = !0);\n            c[d] = e;\n          });\n          f && c.redraw(!1);\n          t(c.container, {\n            cursor: \"move\"\n          });\n        });\n      }\n    });\n    l(f.prototype, {\n      select: function (a, c) {\n        var d = this,\n            g = d.series,\n            f = g.chart;\n        this.selectedStaging = a = b(a, !d.selected);\n        d.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: c\n        }, function () {\n          d.selected = d.options.selected = a;\n          g.options.data[g.data.indexOf(d)] = d.options;\n          d.setState(a && \"select\");\n          c || f.getSelectedPoints().forEach(function (a) {\n            var b = a.series;\n            a.selected && a !== d && (a.selected = a.options.selected = !1, b.options.data[b.data.indexOf(a)] = a.options, a.setState(f.hoverPoints && b.options.inactiveOtherPoints ? \"inactive\" : \"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n        delete this.selectedStaging;\n      },\n      onMouseOver: function (a) {\n        var b = this.series.chart,\n            c = b.pointer;\n        a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted);\n        c.runPointActions(a, this);\n      },\n      onMouseOut: function () {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      },\n      importEvents: function () {\n        if (!this.hasImportedEvents) {\n          var b = this,\n              c = a(b.series.options.point, b.options).events;\n          b.events = c;\n          E(c, function (a, c) {\n            d.isFunction(a) && y(b, c, a);\n          });\n          this.hasImportedEvents = !0;\n        }\n      },\n      setState: function (a, c) {\n        var d = this.series,\n            g = this.state,\n            f = d.options.states[a || \"normal\"] || {},\n            h = u[d.type].marker && d.options.marker,\n            n = h && !1 === h.enabled,\n            m = h && h.states && h.states[a || \"normal\"] || {},\n            k = !1 === m.enabled,\n            r = d.stateMarkerGraphic,\n            q = this.marker || {},\n            v = d.chart,\n            x = d.halo,\n            t,\n            w = h && d.markerAttribs;\n        a = a || \"\";\n\n        if (!(a === this.state && !c || this.selected && \"select\" !== a || !1 === f.enabled || a && (k || n && !1 === m.enabled) || a && q.states && q.states[a] && !1 === q.states[a].enabled)) {\n          this.state = a;\n          w && (t = d.markerAttribs(this, a));\n\n          if (this.graphic) {\n            g && this.graphic.removeClass(\"highcharts-point-\" + g);\n            a && this.graphic.addClass(\"highcharts-point-\" + a);\n\n            if (!v.styledMode) {\n              var y = d.pointAttribs(this, a);\n              var C = b(v.options.chart.animation, f.animation);\n              d.options.inactiveOtherPoints && ((this.dataLabels || []).forEach(function (a) {\n                a && a.animate({\n                  opacity: y.opacity\n                }, C);\n              }), this.connector && this.connector.animate({\n                opacity: y.opacity\n              }, C));\n              this.graphic.animate(y, C);\n            }\n\n            t && this.graphic.animate(t, b(v.options.chart.animation, m.animation, h.animation));\n            r && r.hide();\n          } else {\n            if (a && m) {\n              g = q.symbol || d.symbol;\n              r && r.currentSymbol !== g && (r = r.destroy());\n              if (t) if (r) r[c ? \"animate\" : \"attr\"]({\n                x: t.x,\n                y: t.y\n              });else g && (d.stateMarkerGraphic = r = v.renderer.symbol(g, t.x, t.y, t.width, t.height).add(d.markerGroup), r.currentSymbol = g);\n              !v.styledMode && r && r.attr(d.pointAttribs(this, a));\n            }\n\n            r && (r[a && this.isInside ? \"show\" : \"hide\"](), r.element.point = this);\n          }\n\n          a = f.halo;\n          f = (r = this.graphic || r) && r.visibility || \"inherit\";\n          a && a.size && r && \"hidden\" !== f ? (x || (d.halo = x = v.renderer.path().add(r.parentGroup)), x.show()[c ? \"animate\" : \"attr\"]({\n            d: this.haloPath(a.size)\n          }), x.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + b(this.colorIndex, d.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: f,\n            zIndex: -1\n          }), x.point = this, v.styledMode || x.attr(l({\n            fill: this.color || d.color,\n            \"fill-opacity\": a.opacity\n          }, a.attributes))) : x && x.point && x.point.haloPath && x.animate({\n            d: x.point.haloPath(0)\n          }, null, x.hide);\n          p(this, \"afterSetState\");\n        }\n      },\n      haloPath: function (a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      }\n    });\n    l(m.prototype, {\n      onMouseOver: function () {\n        var a = this.chart,\n            b = a.hoverSeries;\n        if (b && b !== this) b.onMouseOut();\n        this.options.events.mouseOver && p(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      },\n      onMouseOut: function () {\n        var a = this.options,\n            b = this.chart,\n            c = b.tooltip,\n            d = b.hoverPoint;\n        b.hoverSeries = null;\n        if (d) d.onMouseOut();\n        this && a.events.mouseOut && p(this, \"mouseOut\");\n        !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();\n        b.series.forEach(function (a) {\n          a.setState(\"\", !0);\n        });\n      },\n      setState: function (a, c) {\n        var d = this,\n            g = d.options,\n            f = d.graph,\n            h = g.inactiveOtherPoints,\n            n = g.states,\n            m = g.lineWidth,\n            l = g.opacity,\n            k = b(n[a || \"normal\"] && n[a || \"normal\"].animation, d.chart.options.chart.animation);\n        g = 0;\n        a = a || \"\";\n\n        if (d.state !== a && ([d.group, d.markerGroup, d.dataLabelsGroup].forEach(function (b) {\n          b && (d.state && b.removeClass(\"highcharts-series-\" + d.state), a && b.addClass(\"highcharts-series-\" + a));\n        }), d.state = a, !d.chart.styledMode)) {\n          if (n[a] && !1 === n[a].enabled) return;\n          a && (m = n[a].lineWidth || m + (n[a].lineWidthPlus || 0), l = b(n[a].opacity, l));\n          if (f && !f.dashstyle) for (n = {\n            \"stroke-width\": m\n          }, f.animate(n, k); d[\"zone-graph-\" + g];) d[\"zone-graph-\" + g].attr(n), g += 1;\n          h || [d.group, d.markerGroup, d.dataLabelsGroup, d.labelBySeries].forEach(function (a) {\n            a && a.animate({\n              opacity: l\n            }, k);\n          });\n        }\n\n        c && h && d.points && d.setAllPointsToState(a);\n      },\n      setAllPointsToState: function (a) {\n        this.points.forEach(function (b) {\n          b.setState && b.setState(a);\n        });\n      },\n      setVisible: function (a, b) {\n        var c = this,\n            d = c.chart,\n            f = c.legendItem,\n            h = d.options.chart.ignoreHiddenSeries,\n            n = c.visible;\n        var m = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !n : a) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (a) {\n          if (c[a]) c[a][m]();\n        });\n        if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();\n        f && d.legend.colorizeItem(c, a);\n        c.isDirty = !0;\n        c.options.stacking && d.series.forEach(function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        c.linkedSeries.forEach(function (b) {\n          b.setVisible(a, !1);\n        });\n        h && (d.isDirtyBox = !0);\n        p(c, m);\n        !1 !== b && d.redraw();\n      },\n      show: function () {\n        this.setVisible(!0);\n      },\n      hide: function () {\n        this.setVisible(!1);\n      },\n      select: function (a) {\n        this.selected = a = this.options.selected = void 0 === a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        p(this, a ? \"select\" : \"unselect\");\n      },\n      drawTracker: x.drawTrackerGraph\n    });\n  });\n  K(I, \"parts/Responsive.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.isArray,\n        D = k.isObject,\n        H = k.objectEach,\n        E = k.splat;\n    k = d.Chart;\n    var y = d.pick;\n\n    k.prototype.setResponsive = function (k, t) {\n      var w = this.options.responsive,\n          u = [],\n          l = this.currentResponsive;\n      !t && w && w.rules && w.rules.forEach(function (l) {\n        void 0 === l._id && (l._id = d.uniqueKey());\n        this.matchResponsiveRule(l, u);\n      }, this);\n      t = d.merge.apply(0, u.map(function (l) {\n        return d.find(w.rules, function (d) {\n          return d._id === l;\n        }).chartOptions;\n      }));\n      t.isResponsiveOptions = !0;\n      u = u.toString() || void 0;\n      u !== (l && l.ruleIds) && (l && this.update(l.undoOptions, k, !0), u ? (l = this.currentOptions(t), l.isResponsiveOptions = !0, this.currentResponsive = {\n        ruleIds: u,\n        mergedOptions: t,\n        undoOptions: l\n      }, this.update(t, k, !0)) : this.currentResponsive = void 0);\n    };\n\n    k.prototype.matchResponsiveRule = function (d, k) {\n      var t = d.condition;\n      (t.callback || function () {\n        return this.chartWidth <= y(t.maxWidth, Number.MAX_VALUE) && this.chartHeight <= y(t.maxHeight, Number.MAX_VALUE) && this.chartWidth >= y(t.minWidth, 0) && this.chartHeight >= y(t.minHeight, 0);\n      }).call(this) && k.push(d._id);\n    };\n\n    k.prototype.currentOptions = function (d) {\n      function k(d, p, q, c) {\n        var a;\n        H(d, function (b, d) {\n          if (!c && -1 < y.collectionsWithUpdate.indexOf(d)) for (b = E(b), q[d] = [], a = 0; a < b.length; a++) p[d][a] && (q[d][a] = {}, k(b[a], p[d][a], q[d][a], c + 1));else D(b) ? (q[d] = w(b) ? [] : {}, k(b, p[d] || {}, q[d], c + 1)) : q[d] = void 0 === p[d] ? null : p[d];\n        });\n      }\n\n      var y = this,\n          u = {};\n      k(d, this.options, u, 0);\n      return u;\n    };\n  });\n  K(I, \"masters/highcharts.src.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = d.extend;\n    w(d, {\n      attr: k.attr,\n      defined: k.defined,\n      erase: k.erase,\n      isArray: k.isArray,\n      isClass: k.isClass,\n      isDOMElement: k.isDOMElement,\n      isNumber: k.isNumber,\n      isObject: k.isObject,\n      isString: k.isString,\n      objectEach: k.objectEach,\n      pInt: k.pInt,\n      splat: k.splat\n    });\n    return d;\n  });\n  K(I, \"parts/Scrollbar.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    function w(a, b, c) {\n      this.init(a, b, c);\n    }\n\n    var D = k.defined,\n        H = d.addEvent;\n    k = d.Axis;\n    var E = d.correctFloat,\n        y = d.defaultOptions,\n        C = d.destroyObjectProperties,\n        t = d.fireEvent,\n        G = d.hasTouch,\n        u = d.merge,\n        l = d.pick,\n        p = d.removeEvent,\n        q,\n        c = {\n      height: d.isTouchDevice ? 20 : 14,\n      barBorderRadius: 0,\n      buttonBorderRadius: 0,\n      liveRedraw: void 0,\n      margin: 10,\n      minWidth: 6,\n      step: .2,\n      zIndex: 3,\n      barBackgroundColor: \"#cccccc\",\n      barBorderWidth: 1,\n      barBorderColor: \"#cccccc\",\n      buttonArrowColor: \"#333333\",\n      buttonBackgroundColor: \"#e6e6e6\",\n      buttonBorderColor: \"#cccccc\",\n      buttonBorderWidth: 1,\n      rifleColor: \"#333333\",\n      trackBackgroundColor: \"#f2f2f2\",\n      trackBorderColor: \"#f2f2f2\",\n      trackBorderWidth: 1\n    };\n    y.scrollbar = u(!0, c, y.scrollbar);\n\n    d.swapXY = q = function (a, b) {\n      var c = a.length;\n      if (b) for (b = 0; b < c; b += 3) {\n        var d = a[b + 1];\n        a[b + 1] = a[b + 2];\n        a[b + 2] = d;\n      }\n      return a;\n    };\n\n    w.prototype = {\n      init: function (a, b, d) {\n        this.scrollbarButtons = [];\n        this.renderer = a;\n        this.userOptions = b;\n        this.options = u(c, b);\n        this.chart = d;\n        this.size = l(this.options.size, this.options.height);\n        b.enabled && (this.render(), this.initEvents(), this.addEvents());\n      },\n      render: function () {\n        var a = this.renderer,\n            b = this.options,\n            c = this.size,\n            d = this.chart.styledMode,\n            h;\n        this.group = h = a.g(\"scrollbar\").attr({\n          zIndex: b.zIndex,\n          translateY: -99999\n        }).add();\n        this.track = a.rect().addClass(\"highcharts-scrollbar-track\").attr({\n          x: 0,\n          r: b.trackBorderRadius || 0,\n          height: c,\n          width: c\n        }).add(h);\n        d || this.track.attr({\n          fill: b.trackBackgroundColor,\n          stroke: b.trackBorderColor,\n          \"stroke-width\": b.trackBorderWidth\n        });\n        this.trackBorderWidth = this.track.strokeWidth();\n        this.track.attr({\n          y: -this.trackBorderWidth % 2 / 2\n        });\n        this.scrollbarGroup = a.g().add(h);\n        this.scrollbar = a.rect().addClass(\"highcharts-scrollbar-thumb\").attr({\n          height: c,\n          width: c,\n          r: b.barBorderRadius || 0\n        }).add(this.scrollbarGroup);\n        this.scrollbarRifles = a.path(q([\"M\", -3, c / 4, \"L\", -3, 2 * c / 3, \"M\", 0, c / 4, \"L\", 0, 2 * c / 3, \"M\", 3, c / 4, \"L\", 3, 2 * c / 3], b.vertical)).addClass(\"highcharts-scrollbar-rifles\").add(this.scrollbarGroup);\n        d || (this.scrollbar.attr({\n          fill: b.barBackgroundColor,\n          stroke: b.barBorderColor,\n          \"stroke-width\": b.barBorderWidth\n        }), this.scrollbarRifles.attr({\n          stroke: b.rifleColor,\n          \"stroke-width\": 1\n        }));\n        this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();\n        this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);\n        this.drawScrollbarButton(0);\n        this.drawScrollbarButton(1);\n      },\n      position: function (a, b, c, d) {\n        var f = this.options.vertical,\n            m = 0,\n            l = this.rendered ? \"animate\" : \"attr\";\n        this.x = a;\n        this.y = b + this.trackBorderWidth;\n        this.width = c;\n        this.xOffset = this.height = d;\n        this.yOffset = m;\n        f ? (this.width = this.yOffset = c = m = this.size, this.xOffset = b = 0, this.barWidth = d - 2 * c, this.x = a += this.options.margin) : (this.height = this.xOffset = d = b = this.size, this.barWidth = c - 2 * d, this.y += this.options.margin);\n        this.group[l]({\n          translateX: a,\n          translateY: this.y\n        });\n        this.track[l]({\n          width: c,\n          height: d\n        });\n        this.scrollbarButtons[1][l]({\n          translateX: f ? 0 : c - b,\n          translateY: f ? d - m : 0\n        });\n      },\n      drawScrollbarButton: function (a) {\n        var b = this.renderer,\n            c = this.scrollbarButtons,\n            d = this.options,\n            h = this.size;\n        var l = b.g().add(this.group);\n        c.push(l);\n        l = b.rect().addClass(\"highcharts-scrollbar-button\").add(l);\n        this.chart.styledMode || l.attr({\n          stroke: d.buttonBorderColor,\n          \"stroke-width\": d.buttonBorderWidth,\n          fill: d.buttonBackgroundColor\n        });\n        l.attr(l.crisp({\n          x: -.5,\n          y: -.5,\n          width: h + 1,\n          height: h + 1,\n          r: d.buttonBorderRadius\n        }, l.strokeWidth()));\n        l = b.path(q([\"M\", h / 2 + (a ? -1 : 1), h / 2 - 3, \"L\", h / 2 + (a ? -1 : 1), h / 2 + 3, \"L\", h / 2 + (a ? 2 : -2), h / 2], d.vertical)).addClass(\"highcharts-scrollbar-arrow\").add(c[a]);\n        this.chart.styledMode || l.attr({\n          fill: d.buttonArrowColor\n        });\n      },\n      setRange: function (a, b) {\n        var c = this.options,\n            d = c.vertical,\n            h = c.minWidth,\n            l = this.barWidth,\n            k,\n            p = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? \"attr\" : \"animate\";\n\n        if (D(l)) {\n          a = Math.max(a, 0);\n          var n = Math.ceil(l * a);\n          this.calculatedWidth = k = E(l * Math.min(b, 1) - n);\n          k < h && (n = (l - h + k) * a, k = h);\n          h = Math.floor(n + this.xOffset + this.yOffset);\n          l = k / 2 - .5;\n          this.from = a;\n          this.to = b;\n          d ? (this.scrollbarGroup[p]({\n            translateY: h\n          }), this.scrollbar[p]({\n            height: k\n          }), this.scrollbarRifles[p]({\n            translateY: l\n          }), this.scrollbarTop = h, this.scrollbarLeft = 0) : (this.scrollbarGroup[p]({\n            translateX: h\n          }), this.scrollbar[p]({\n            width: k\n          }), this.scrollbarRifles[p]({\n            translateX: l\n          }), this.scrollbarLeft = h, this.scrollbarTop = 0);\n          12 >= k ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0);\n          !1 === c.showFull && (0 >= a && 1 <= b ? this.group.hide() : this.group.show());\n          this.rendered = !0;\n        }\n      },\n      initEvents: function () {\n        var a = this;\n\n        a.mouseMoveHandler = function (b) {\n          var c = a.chart.pointer.normalize(b),\n              d = a.options.vertical ? \"chartY\" : \"chartX\",\n              h = a.initPositions;\n          !a.grabbedCenter || b.touches && 0 === b.touches[0][d] || (c = a.cursorToScrollbarPosition(c)[d], d = a[d], d = c - d, a.hasDragged = !0, a.updatePosition(h[0] + d, h[1] + d), a.hasDragged && t(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMType: b.type,\n            DOMEvent: b\n          }));\n        };\n\n        a.mouseUpHandler = function (b) {\n          a.hasDragged && t(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMType: b.type,\n            DOMEvent: b\n          });\n          a.grabbedCenter = a.hasDragged = a.chartX = a.chartY = null;\n        };\n\n        a.mouseDownHandler = function (b) {\n          b = a.chart.pointer.normalize(b);\n          b = a.cursorToScrollbarPosition(b);\n          a.chartX = b.chartX;\n          a.chartY = b.chartY;\n          a.initPositions = [a.from, a.to];\n          a.grabbedCenter = !0;\n        };\n\n        a.buttonToMinClick = function (b) {\n          var c = E(a.to - a.from) * a.options.step;\n          a.updatePosition(E(a.from - c), E(a.to - c));\n          t(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMEvent: b\n          });\n        };\n\n        a.buttonToMaxClick = function (b) {\n          var c = (a.to - a.from) * a.options.step;\n          a.updatePosition(a.from + c, a.to + c);\n          t(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMEvent: b\n          });\n        };\n\n        a.trackClick = function (b) {\n          var c = a.chart.pointer.normalize(b),\n              d = a.to - a.from,\n              h = a.y + a.scrollbarTop,\n              l = a.x + a.scrollbarLeft;\n          a.options.vertical && c.chartY > h || !a.options.vertical && c.chartX > l ? a.updatePosition(a.from + d, a.to + d) : a.updatePosition(a.from - d, a.to - d);\n          t(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMEvent: b\n          });\n        };\n      },\n      cursorToScrollbarPosition: function (a) {\n        var b = this.options;\n        b = b.minWidth > this.calculatedWidth ? b.minWidth : 0;\n        return {\n          chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - b),\n          chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - b)\n        };\n      },\n      updatePosition: function (a, b) {\n        1 < b && (a = E(1 - E(b - a)), b = 1);\n        0 > a && (b = E(b - a), a = 0);\n        this.from = a;\n        this.to = b;\n      },\n      update: function (a) {\n        this.destroy();\n        this.init(this.chart.renderer, u(!0, this.options, a), this.chart);\n      },\n      addEvents: function () {\n        var a = this.options.inverted ? [1, 0] : [0, 1],\n            b = this.scrollbarButtons,\n            c = this.scrollbarGroup.element,\n            d = this.mouseDownHandler,\n            h = this.mouseMoveHandler,\n            l = this.mouseUpHandler;\n        a = [[b[a[0]].element, \"click\", this.buttonToMinClick], [b[a[1]].element, \"click\", this.buttonToMaxClick], [this.track.element, \"click\", this.trackClick], [c, \"mousedown\", d], [c.ownerDocument, \"mousemove\", h], [c.ownerDocument, \"mouseup\", l]];\n        G && a.push([c, \"touchstart\", d], [c.ownerDocument, \"touchmove\", h], [c.ownerDocument, \"touchend\", l]);\n        a.forEach(function (a) {\n          H.apply(null, a);\n        });\n        this._events = a;\n      },\n      removeEvents: function () {\n        this._events.forEach(function (a) {\n          p.apply(null, a);\n        });\n\n        this._events.length = 0;\n      },\n      destroy: function () {\n        var a = this.chart.scroller;\n        this.removeEvents();\n        [\"track\", \"scrollbarRifles\", \"scrollbar\", \"scrollbarGroup\", \"group\"].forEach(function (a) {\n          this[a] && this[a].destroy && (this[a] = this[a].destroy());\n        }, this);\n        a && this === a.scrollbar && (a.scrollbar = null, C(a.scrollbarButtons));\n      }\n    };\n    d.Scrollbar || (H(k, \"afterInit\", function () {\n      var a = this;\n      a.options && a.options.scrollbar && a.options.scrollbar.enabled && (a.options.scrollbar.vertical = !a.horiz, a.options.startOnTick = a.options.endOnTick = !1, a.scrollbar = new w(a.chart.renderer, a.options.scrollbar, a.chart), H(a.scrollbar, \"changed\", function (b) {\n        var c = Math.min(l(a.options.min, a.min), a.min, a.dataMin),\n            m = Math.max(l(a.options.max, a.max), a.max, a.dataMax) - c;\n\n        if (a.horiz && !a.reversed || !a.horiz && a.reversed) {\n          var h = c + m * this.to;\n          c += m * this.from;\n        } else h = c + m * (1 - this.from), c += m * (1 - this.to);\n\n        l(this.options.liveRedraw, d.svg && !d.isTouchDevice && !this.chart.isBoosting) || \"mouseup\" === b.DOMType || !D(b.DOMType) ? a.setExtremes(c, h, !0, \"mousemove\" !== b.DOMType, b) : this.setRange(this.from, this.to);\n      }));\n    }), H(k, \"afterRender\", function () {\n      var a = Math.min(l(this.options.min, this.min), this.min, l(this.dataMin, this.min)),\n          b = Math.max(l(this.options.max, this.max), this.max, l(this.dataMax, this.max)),\n          c = this.scrollbar,\n          d = this.axisTitleMargin + (this.titleOffset || 0),\n          h = this.chart.scrollbarsOffsets,\n          k = this.options.margin || 0;\n      c && (this.horiz ? (this.opposite || (h[1] += d), c.position(this.left, this.top + this.height + 2 + h[1] - (this.opposite ? k : 0), this.width, this.height), this.opposite || (h[1] += k), d = 1) : (this.opposite && (h[0] += d), c.position(this.left + this.width + 2 + h[0] - (this.opposite ? 0 : k), this.top, this.width, this.height), this.opposite && (h[0] += k), d = 0), h[d] += c.size + c.options.margin, isNaN(a) || isNaN(b) || !D(this.min) || !D(this.max) || this.min === this.max ? c.setRange(0, 1) : (h = (this.min - a) / (b - a), a = (this.max - a) / (b - a), this.horiz && !this.reversed || !this.horiz && this.reversed ? c.setRange(h, a) : c.setRange(1 - a, 1 - h)));\n    }), H(k, \"afterGetOffset\", function () {\n      var a = this.horiz ? 2 : 1,\n          b = this.scrollbar;\n      b && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[a] += b.size + b.options.margin);\n    }), d.Scrollbar = w);\n  });\n  K(I, \"parts/Navigator.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    function w(a) {\n      this.init(a);\n    }\n\n    var D = k.defined,\n        H = k.erase,\n        E = k.isArray,\n        y = k.isNumber,\n        C = k.splat,\n        t = d.addEvent,\n        G = d.Axis;\n    k = d.Chart;\n\n    var u = d.color,\n        l = d.defaultOptions,\n        p = d.destroyObjectProperties,\n        q = d.extend,\n        c = d.hasTouch,\n        a = d.isTouchDevice,\n        b = d.merge,\n        f = d.pick,\n        m = d.removeEvent,\n        h = d.Scrollbar,\n        r = d.Series,\n        x = function (a) {\n      for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];\n\n      b = [].filter.call(b, y);\n      if (b.length) return Math[a].apply(0, b);\n    };\n\n    var v = void 0 === d.seriesTypes.areaspline ? \"line\" : \"areaspline\";\n    q(l, {\n      navigator: {\n        height: 40,\n        margin: 25,\n        maskInside: !0,\n        handles: {\n          width: 7,\n          height: 15,\n          symbols: [\"navigator-handle\", \"navigator-handle\"],\n          enabled: !0,\n          lineWidth: 1,\n          backgroundColor: \"#f2f2f2\",\n          borderColor: \"#999999\"\n        },\n        maskFill: u(\"#6685c2\").setOpacity(.3).get(),\n        outlineColor: \"#cccccc\",\n        outlineWidth: 1,\n        series: {\n          type: v,\n          fillOpacity: .05,\n          lineWidth: 1,\n          compare: null,\n          dataGrouping: {\n            approximation: \"average\",\n            enabled: !0,\n            groupPixelWidth: 2,\n            smoothed: !0,\n            units: [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2, 3, 4]], [\"week\", [1, 2, 3]], [\"month\", [1, 3, 6]], [\"year\", null]]\n          },\n          dataLabels: {\n            enabled: !1,\n            zIndex: 2\n          },\n          id: \"highcharts-navigator-series\",\n          className: \"highcharts-navigator-series\",\n          lineColor: null,\n          marker: {\n            enabled: !1\n          },\n          pointRange: 0,\n          threshold: null\n        },\n        xAxis: {\n          overscroll: 0,\n          className: \"highcharts-navigator-xaxis\",\n          tickLength: 0,\n          lineWidth: 0,\n          gridLineColor: \"#e6e6e6\",\n          gridLineWidth: 1,\n          tickPixelInterval: 200,\n          labels: {\n            align: \"left\",\n            style: {\n              color: \"#999999\"\n            },\n            x: 3,\n            y: -4\n          },\n          crosshair: !1\n        },\n        yAxis: {\n          className: \"highcharts-navigator-yaxis\",\n          gridLineWidth: 0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: .1,\n          maxPadding: .1,\n          labels: {\n            enabled: !1\n          },\n          crosshair: !1,\n          title: {\n            text: null\n          },\n          tickLength: 0,\n          tickWidth: 0\n        }\n      }\n    });\n\n    d.Renderer.prototype.symbols[\"navigator-handle\"] = function (a, b, c, d, f) {\n      a = f.width / 2;\n      b = Math.round(a / 3) + .5;\n      f = f.height;\n      return [\"M\", -a - 1, .5, \"L\", a, .5, \"L\", a, f + .5, \"L\", -a - 1, f + .5, \"L\", -a - 1, .5, \"M\", -b, 4, \"L\", -b, f - 3, \"M\", b - 1, 4, \"L\", b - 1, f - 3];\n    };\n\n    G.prototype.toFixedRange = function (a, b, c, d) {\n      var e = this.chart && this.chart.fixedRange;\n      a = f(c, this.translate(a, !0, !this.horiz));\n      b = f(d, this.translate(b, !0, !this.horiz));\n      c = e && (b - a) / e;\n      .7 < c && 1.3 > c && (d ? a = b - e : b = a + e);\n      y(a) && y(b) || (a = b = void 0);\n      return {\n        min: a,\n        max: b\n      };\n    };\n\n    w.prototype = {\n      drawHandle: function (a, b, c, d) {\n        var e = this.navigatorOptions.handles.height;\n        this.handles[b][d](c ? {\n          translateX: Math.round(this.left + this.height / 2),\n          translateY: Math.round(this.top + parseInt(a, 10) + .5 - e)\n        } : {\n          translateX: Math.round(this.left + parseInt(a, 10)),\n          translateY: Math.round(this.top + this.height / 2 - e / 2 - 1)\n        });\n      },\n      drawOutline: function (a, b, c, d) {\n        var e = this.navigatorOptions.maskInside,\n            g = this.outline.strokeWidth(),\n            f = g / 2;\n        g = g % 2 / 2;\n        var h = this.outlineHeight,\n            n = this.scrollbarHeight,\n            l = this.size,\n            m = this.left - n,\n            k = this.top;\n        c ? (m -= f, c = k + b + g, b = k + a + g, a = [\"M\", m + h, k - n - g, \"L\", m + h, c, \"L\", m, c, \"L\", m, b, \"L\", m + h, b, \"L\", m + h, k + l + n].concat(e ? [\"M\", m + h, c - f, \"L\", m + h, b + f] : [])) : (a += m + n - g, b += m + n - g, k += f, a = [\"M\", m, k, \"L\", a, k, \"L\", a, k + h, \"L\", b, k + h, \"L\", b, k, \"L\", m + l + 2 * n, k].concat(e ? [\"M\", a - f, k, \"L\", b + f, k] : []));\n        this.outline[d]({\n          d: a\n        });\n      },\n      drawMasks: function (a, b, c, d) {\n        var e = this.left,\n            g = this.top,\n            f = this.height;\n\n        if (c) {\n          var h = [e, e, e];\n          var n = [g, g + a, g + b];\n          var l = [f, f, f];\n          var m = [a, b - a, this.size - b];\n        } else h = [e, e + a, e + b], n = [g, g, g], l = [a, b - a, this.size - b], m = [f, f, f];\n\n        this.shades.forEach(function (a, b) {\n          a[d]({\n            x: h[b],\n            y: n[b],\n            width: l[b],\n            height: m[b]\n          });\n        });\n      },\n      renderElements: function () {\n        var a = this,\n            b = a.navigatorOptions,\n            c = b.maskInside,\n            d = a.chart,\n            f = d.renderer,\n            h,\n            l = {\n          cursor: d.inverted ? \"ns-resize\" : \"ew-resize\"\n        };\n        a.navigatorGroup = h = f.g(\"navigator\").attr({\n          zIndex: 8,\n          visibility: \"hidden\"\n        }).add();\n        [!c, c, !c].forEach(function (c, e) {\n          a.shades[e] = f.rect().addClass(\"highcharts-navigator-mask\" + (1 === e ? \"-inside\" : \"-outside\")).add(h);\n          d.styledMode || a.shades[e].attr({\n            fill: c ? b.maskFill : \"rgba(0,0,0,0)\"\n          }).css(1 === e && l);\n        });\n        a.outline = f.path().addClass(\"highcharts-navigator-outline\").add(h);\n        d.styledMode || a.outline.attr({\n          \"stroke-width\": b.outlineWidth,\n          stroke: b.outlineColor\n        });\n        b.handles.enabled && [0, 1].forEach(function (c) {\n          b.handles.inverted = d.inverted;\n          a.handles[c] = f.symbol(b.handles.symbols[c], -b.handles.width / 2 - 1, 0, b.handles.width, b.handles.height, b.handles);\n          a.handles[c].attr({\n            zIndex: 7 - c\n          }).addClass(\"highcharts-navigator-handle highcharts-navigator-handle-\" + [\"left\", \"right\"][c]).add(h);\n\n          if (!d.styledMode) {\n            var e = b.handles;\n            a.handles[c].attr({\n              fill: e.backgroundColor,\n              stroke: e.borderColor,\n              \"stroke-width\": e.lineWidth\n            }).css(l);\n          }\n        });\n      },\n      update: function (a) {\n        (this.series || []).forEach(function (a) {\n          a.baseSeries && delete a.baseSeries.navigatorSeries;\n        });\n        this.destroy();\n        b(!0, this.chart.options.navigator, this.options, a);\n        this.init(this.chart);\n      },\n      render: function (a, b, c, h) {\n        var e = this.chart,\n            g = this.scrollbarHeight,\n            n,\n            l = this.xAxis;\n        var m = l.fake ? e.xAxis[0] : l;\n        var k = this.navigatorEnabled,\n            p,\n            r = this.rendered;\n        var q = e.inverted;\n        var v = e.xAxis[0].minRange,\n            u = e.xAxis[0].options.maxRange;\n\n        if (!this.hasDragged || D(c)) {\n          if (!y(a) || !y(b)) if (r) c = 0, h = f(l.width, m.width);else return;\n          this.left = f(l.left, e.plotLeft + g + (q ? e.plotWidth : 0));\n          this.size = p = n = f(l.len, (q ? e.plotHeight : e.plotWidth) - 2 * g);\n          e = q ? g : n + 2 * g;\n          c = f(c, l.toPixels(a, !0));\n          h = f(h, l.toPixels(b, !0));\n          y(c) && Infinity !== Math.abs(c) || (c = 0, h = e);\n          a = l.toValue(c, !0);\n          b = l.toValue(h, !0);\n          var x = Math.abs(d.correctFloat(b - a));\n          x < v ? this.grabbedLeft ? c = l.toPixels(b - v, !0) : this.grabbedRight && (h = l.toPixels(a + v, !0)) : D(u) && x > u && (this.grabbedLeft ? c = l.toPixels(b - u, !0) : this.grabbedRight && (h = l.toPixels(a + u, !0)));\n          this.zoomedMax = Math.min(Math.max(c, h, 0), p);\n          this.zoomedMin = Math.min(Math.max(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(c, h), 0), p);\n          this.range = this.zoomedMax - this.zoomedMin;\n          p = Math.round(this.zoomedMax);\n          c = Math.round(this.zoomedMin);\n          k && (this.navigatorGroup.attr({\n            visibility: \"visible\"\n          }), r = r && !this.hasDragged ? \"animate\" : \"attr\", this.drawMasks(c, p, q, r), this.drawOutline(c, p, q, r), this.navigatorOptions.handles.enabled && (this.drawHandle(c, 0, q, r), this.drawHandle(p, 1, q, r)));\n          this.scrollbar && (q ? (q = this.top - g, m = this.left - g + (k || !m.opposite ? 0 : (m.titleOffset || 0) + m.axisTitleMargin), g = n + 2 * g) : (q = this.top + (k ? this.height : -g), m = this.left - g), this.scrollbar.position(m, q, e, g), this.scrollbar.setRange(this.zoomedMin / (n || 1), this.zoomedMax / (n || 1)));\n          this.rendered = !0;\n        }\n      },\n      addMouseEvents: function () {\n        var a = this,\n            b = a.chart,\n            d = b.container,\n            f = [],\n            h,\n            l;\n\n        a.mouseMoveHandler = h = function (b) {\n          a.onMouseMove(b);\n        };\n\n        a.mouseUpHandler = l = function (b) {\n          a.onMouseUp(b);\n        };\n\n        f = a.getPartsEvents(\"mousedown\");\n        f.push(t(d, \"mousemove\", h), t(d.ownerDocument, \"mouseup\", l));\n        c && (f.push(t(d, \"touchmove\", h), t(d.ownerDocument, \"touchend\", l)), f.concat(a.getPartsEvents(\"touchstart\")));\n        a.eventsToUnbind = f;\n        a.series && a.series[0] && f.push(t(a.series[0].xAxis, \"foundExtremes\", function () {\n          b.navigator.modifyNavigatorAxisExtremes();\n        }));\n      },\n      getPartsEvents: function (a) {\n        var b = this,\n            c = [];\n        [\"shades\", \"handles\"].forEach(function (d) {\n          b[d].forEach(function (e, g) {\n            c.push(t(e.element, a, function (a) {\n              b[d + \"Mousedown\"](a, g);\n            }));\n          });\n        });\n        return c;\n      },\n      shadesMousedown: function (a, b) {\n        a = this.chart.pointer.normalize(a);\n        var c = this.chart,\n            d = this.xAxis,\n            e = this.zoomedMin,\n            f = this.left,\n            h = this.size,\n            n = this.range,\n            l = a.chartX;\n        c.inverted && (l = a.chartY, f = this.top);\n        if (1 === b) this.grabbedCenter = l, this.fixedWidth = n, this.dragOffset = l - e;else {\n          a = l - f - n / 2;\n          if (0 === b) a = Math.max(0, a);else if (2 === b && a + n >= h) if (a = h - n, this.reversedExtremes) {\n            a -= n;\n            var m = this.getUnionExtremes().dataMin;\n          } else var k = this.getUnionExtremes().dataMax;\n          a !== e && (this.fixedWidth = n, b = d.toFixedRange(a, a + n, m, k), D(b.min) && c.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, null, {\n            trigger: \"navigator\"\n          }));\n        }\n      },\n      handlesMousedown: function (a, b) {\n        this.chart.pointer.normalize(a);\n        a = this.chart;\n        var c = a.xAxis[0],\n            d = this.reversedExtremes;\n        0 === b ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d ? c.min : c.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d ? c.max : c.min);\n        a.fixedRange = null;\n      },\n      onMouseMove: function (b) {\n        var c = this,\n            g = c.chart,\n            h = c.left,\n            n = c.navigatorSize,\n            l = c.range,\n            m = c.dragOffset,\n            k = g.inverted;\n        b.touches && 0 === b.touches[0].pageX || (b = g.pointer.normalize(b), g = b.chartX, k && (h = c.top, g = b.chartY), c.grabbedLeft ? (c.hasDragged = !0, c.render(0, 0, g - h, c.otherHandlePos)) : c.grabbedRight ? (c.hasDragged = !0, c.render(0, 0, c.otherHandlePos, g - h)) : c.grabbedCenter && (c.hasDragged = !0, g < m ? g = m : g > n + m - l && (g = n + m - l), c.render(0, 0, g - m, g - m + l)), c.hasDragged && c.scrollbar && f(c.scrollbar.options.liveRedraw, d.svg && !a && !this.chart.isBoosting) && (b.DOMType = b.type, setTimeout(function () {\n          c.onMouseUp(b);\n        }, 0)));\n      },\n      onMouseUp: function (a) {\n        var b = this.chart,\n            c = this.xAxis,\n            d = this.scrollbar,\n            f = a.DOMEvent || a;\n\n        if (this.hasDragged && (!d || !d.hasDragged) || \"scrollbar\" === a.trigger) {\n          d = this.getUnionExtremes();\n          if (this.zoomedMin === this.otherHandlePos) var h = this.fixedExtreme;else if (this.zoomedMax === this.otherHandlePos) var n = this.fixedExtreme;\n          this.zoomedMax === this.size && (n = this.reversedExtremes ? d.dataMin : d.dataMax);\n          0 === this.zoomedMin && (h = this.reversedExtremes ? d.dataMax : d.dataMin);\n          c = c.toFixedRange(this.zoomedMin, this.zoomedMax, h, n);\n          D(c.min) && b.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, this.hasDragged ? !1 : null, {\n            trigger: \"navigator\",\n            triggerOp: \"navigator-drag\",\n            DOMEvent: f\n          });\n        }\n\n        \"mousemove\" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);\n      },\n      removeEvents: function () {\n        this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind = void 0);\n        this.removeBaseSeriesEvents();\n      },\n      removeBaseSeriesEvents: function () {\n        var a = this.baseSeries || [];\n        this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {\n          m(a, \"updatedData\", this.updatedDataHandler);\n        }, this), a[0].xAxis && m(a[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n      },\n      init: function (a) {\n        var c = a.options,\n            d = c.navigator,\n            l = d.enabled,\n            n = c.scrollbar,\n            m = n.enabled;\n        c = l ? d.height : 0;\n        var k = m ? n.height : 0;\n        this.handles = [];\n        this.shades = [];\n        this.chart = a;\n        this.setBaseSeries();\n        this.height = c;\n        this.scrollbarHeight = k;\n        this.scrollbarEnabled = m;\n        this.navigatorEnabled = l;\n        this.navigatorOptions = d;\n        this.scrollbarOptions = n;\n        this.outlineHeight = c + k;\n        this.opposite = f(d.opposite, !l && a.inverted);\n        var p = this;\n        l = p.baseSeries;\n        n = a.xAxis.length;\n        m = a.yAxis.length;\n        var r = l && l[0] && l[0].xAxis || a.xAxis[0] || {\n          options: {}\n        };\n        a.isDirtyBox = !0;\n        p.navigatorEnabled ? (p.xAxis = new G(a, b({\n          breaks: r.options.breaks,\n          ordinal: r.options.ordinal\n        }, d.xAxis, {\n          id: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          isX: !0,\n          type: \"datetime\",\n          index: n,\n          isInternal: !0,\n          offset: 0,\n          keepOrdinalPadding: !0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: 0,\n          maxPadding: 0,\n          zoomEnabled: !1\n        }, a.inverted ? {\n          offsets: [k, 0, -k, 0],\n          width: c\n        } : {\n          offsets: [0, -k, 0, k],\n          height: c\n        })), p.yAxis = new G(a, b(d.yAxis, {\n          id: \"navigator-y-axis\",\n          alignTicks: !1,\n          offset: 0,\n          index: m,\n          isInternal: !0,\n          zoomEnabled: !1\n        }, a.inverted ? {\n          width: c\n        } : {\n          height: c\n        })), l || d.series.data ? p.updateNavigatorSeries(!1) : 0 === a.series.length && (p.unbindRedraw = t(a, \"beforeRedraw\", function () {\n          0 < a.series.length && !p.series && (p.setBaseSeries(), p.unbindRedraw());\n        })), p.reversedExtremes = a.inverted && !p.xAxis.reversed || !a.inverted && p.xAxis.reversed, p.renderElements(), p.addMouseEvents()) : p.xAxis = {\n          translate: function (b, c) {\n            var d = a.xAxis[0],\n                e = d.getExtremes(),\n                g = d.len - 2 * k,\n                f = x(\"min\", d.options.min, e.dataMin);\n            d = x(\"max\", d.options.max, e.dataMax) - f;\n            return c ? b * d / g + f : g * (b - f) / d;\n          },\n          toPixels: function (a) {\n            return this.translate(a);\n          },\n          toValue: function (a) {\n            return this.translate(a, !0);\n          },\n          toFixedRange: G.prototype.toFixedRange,\n          fake: !0\n        };\n        a.options.scrollbar.enabled && (a.scrollbar = p.scrollbar = new h(a.renderer, b(a.options.scrollbar, {\n          margin: p.navigatorEnabled ? 0 : 10,\n          vertical: a.inverted\n        }), a), t(p.scrollbar, \"changed\", function (b) {\n          var c = p.size,\n              d = c * this.to;\n          c *= this.from;\n          p.hasDragged = p.scrollbar.hasDragged;\n          p.render(0, 0, c, d);\n          (a.options.scrollbar.liveRedraw || \"mousemove\" !== b.DOMType && \"touchmove\" !== b.DOMType) && setTimeout(function () {\n            p.onMouseUp(b);\n          });\n        }));\n        p.addBaseSeriesEvents();\n        p.addChartEvents();\n      },\n      getUnionExtremes: function (a) {\n        var b = this.chart.xAxis[0],\n            c = this.xAxis,\n            d = c.options,\n            h = b.options,\n            l;\n        a && null === b.dataMin || (l = {\n          dataMin: f(d && d.min, x(\"min\", h.min, b.dataMin, c.dataMin, c.min)),\n          dataMax: f(d && d.max, x(\"max\", h.max, b.dataMax, c.dataMax, c.max))\n        });\n        return l;\n      },\n      setBaseSeries: function (a, b) {\n        var c = this.chart,\n            e = this.baseSeries = [];\n        a = a || c.options && c.options.navigator.baseSeries || (c.series.length ? d.find(c.series, function (a) {\n          return !a.options.isInternal;\n        }).index : 0);\n        (c.series || []).forEach(function (b, c) {\n          b.options.isInternal || !b.options.showInNavigator && (c !== a && b.options.id !== a || !1 === b.options.showInNavigator) || e.push(b);\n        });\n        this.xAxis && !this.xAxis.fake && this.updateNavigatorSeries(!0, b);\n      },\n      updateNavigatorSeries: function (a, c) {\n        var d = this,\n            e = d.chart,\n            f = d.baseSeries,\n            h,\n            n,\n            k = d.navigatorOptions.series,\n            p,\n            r = {\n          enableMouseTracking: !1,\n          index: null,\n          linkedTo: null,\n          group: \"nav\",\n          padXAxis: !1,\n          xAxis: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          showInLegend: !1,\n          stacking: !1,\n          isInternal: !0,\n          states: {\n            inactive: {\n              opacity: 1\n            }\n          }\n        },\n            v = d.series = (d.series || []).filter(function (a) {\n          var b = a.baseSeries;\n          return 0 > f.indexOf(b) ? (b && (m(b, \"updatedData\", d.updatedDataHandler), delete b.navigatorSeries), a.chart && a.destroy(), !1) : !0;\n        });\n        f && f.length && f.forEach(function (a) {\n          var g = a.navigatorSeries,\n              m = q({\n            color: a.color,\n            visible: a.visible\n          }, E(k) ? l.navigator.series : k);\n          g && !1 === d.navigatorOptions.adaptToUpdatedData || (r.name = \"Navigator \" + f.length, h = a.options || {}, p = h.navigatorOptions || {}, n = b(h, r, m, p), m = p.data || m.data, d.hasNavigatorData = d.hasNavigatorData || !!m, n.data = m || h.data && h.data.slice(0), g && g.options ? g.update(n, c) : (a.navigatorSeries = e.initSeries(n), a.navigatorSeries.baseSeries = a, v.push(a.navigatorSeries)));\n        });\n        if (k.data && (!f || !f.length) || E(k)) d.hasNavigatorData = !1, k = C(k), k.forEach(function (a, c) {\n          r.name = \"Navigator \" + (v.length + 1);\n          n = b(l.navigator.series, {\n            color: e.series[c] && !e.series[c].options.isInternal && e.series[c].color || e.options.colors[c] || e.options.colors[0]\n          }, r, a);\n          n.data = a.data;\n          n.data && (d.hasNavigatorData = !0, v.push(e.initSeries(n)));\n        });\n        a && this.addBaseSeriesEvents();\n      },\n      addBaseSeriesEvents: function () {\n        var a = this,\n            b = a.baseSeries || [];\n        b[0] && b[0].xAxis && t(b[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes);\n        b.forEach(function (b) {\n          t(b, \"show\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);\n          });\n          t(b, \"hide\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);\n          });\n          !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && t(b, \"updatedData\", this.updatedDataHandler);\n          t(b, \"remove\", function () {\n            this.navigatorSeries && (H(a.series, this.navigatorSeries), D(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);\n          });\n        }, this);\n      },\n      getBaseSeriesMin: function (a) {\n        return this.baseSeries.reduce(function (a, b) {\n          return Math.min(a, b.xData ? b.xData[0] : a);\n        }, a);\n      },\n      modifyNavigatorAxisExtremes: function () {\n        var a = this.xAxis,\n            b;\n        a.getExtremes && (!(b = this.getUnionExtremes(!0)) || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax));\n      },\n      modifyBaseAxisExtremes: function () {\n        var a = this.chart.navigator,\n            b = this.getExtremes(),\n            c = b.dataMin,\n            d = b.dataMax;\n        b = b.max - b.min;\n        var h = a.stickToMin,\n            l = a.stickToMax,\n            m = f(this.options.overscroll, 0),\n            k = a.series && a.series[0],\n            p = !!this.setExtremes;\n\n        if (!this.eventArgs || \"rangeSelectorButton\" !== this.eventArgs.trigger) {\n          if (h) {\n            var r = c;\n            var q = r + b;\n          }\n\n          l && (q = d + m, h || (r = Math.max(q - b, a.getBaseSeriesMin(k && k.xData ? k.xData[0] : -Number.MAX_VALUE))));\n          p && (h || l) && y(r) && (this.min = this.userMin = r, this.max = this.userMax = q);\n        }\n\n        a.stickToMin = a.stickToMax = null;\n      },\n      updatedDataHandler: function () {\n        var a = this.chart.navigator,\n            b = this.navigatorSeries,\n            c = a.getBaseSeriesMin(this.xData[0]);\n        a.stickToMax = a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size);\n        a.stickToMin = y(this.xAxis.min) && this.xAxis.min <= c && (!this.chart.fixedRange || !a.stickToMax);\n        b && !a.hasNavigatorData && (b.options.pointStart = this.xData[0], b.setData(this.options.data, !1, null, !1));\n      },\n      addChartEvents: function () {\n        this.eventsToUnbind || (this.eventsToUnbind = []);\n        this.eventsToUnbind.push(t(this.chart, \"redraw\", function () {\n          var a = this.navigator,\n              b = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || a.scrollbar && this.xAxis[0]);\n          b && a.render(b.min, b.max);\n        }), t(this.chart, \"getMargins\", function () {\n          var a = this.navigator,\n              b = a.opposite ? \"plotTop\" : \"marginBottom\";\n          this.inverted && (b = a.opposite ? \"marginRight\" : \"plotLeft\");\n          this[b] = (this[b] || 0) + (a.navigatorEnabled || !this.inverted ? a.outlineHeight : 0) + a.navigatorOptions.margin;\n        }));\n      },\n      destroy: function () {\n        this.removeEvents();\n        this.xAxis && (H(this.chart.xAxis, this.xAxis), H(this.chart.axes, this.xAxis));\n        this.yAxis && (H(this.chart.yAxis, this.yAxis), H(this.chart.axes, this.yAxis));\n        (this.series || []).forEach(function (a) {\n          a.destroy && a.destroy();\n        });\n        \"series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered\".split(\" \").forEach(function (a) {\n          this[a] && this[a].destroy && this[a].destroy();\n          this[a] = null;\n        }, this);\n        [this.handles].forEach(function (a) {\n          p(a);\n        }, this);\n      }\n    };\n    d.Navigator || (d.Navigator = w, t(G, \"zoom\", function (b) {\n      var c = this.chart.options,\n          d = c.chart.zoomType,\n          f = c.chart.pinchType,\n          h = c.navigator;\n      c = c.rangeSelector;\n      this.isXAxis && (h && h.enabled || c && c.enabled) && (\"y\" === d ? b.zoomed = !1 : (!a && \"xy\" === d || a && \"xy\" === f) && this.options.range && (d = this.previousZoom, D(b.newMin) ? this.previousZoom = [this.min, this.max] : d && (b.newMin = d[0], b.newMax = d[1], delete this.previousZoom)));\n      void 0 !== b.zoomed && b.preventDefault();\n    }), t(k, \"beforeShowResetZoom\", function () {\n      var b = this.options,\n          c = b.navigator,\n          d = b.rangeSelector;\n      if ((c && c.enabled || d && d.enabled) && (!a && \"x\" === b.chart.zoomType || a && \"x\" === b.chart.pinchType)) return !1;\n    }), t(k, \"beforeRender\", function () {\n      var a = this.options;\n      if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new w(this);\n    }), t(k, \"afterSetChartSize\", function () {\n      var a = this.legend,\n          b = this.navigator;\n\n      if (b) {\n        var c = a && a.options;\n        var d = b.xAxis;\n        var h = b.yAxis;\n        var l = b.scrollbarHeight;\n        this.inverted ? (b.left = b.opposite ? this.chartWidth - l - b.height : this.spacing[3] + l, b.top = this.plotTop + l) : (b.left = this.plotLeft + l, b.top = b.navigatorOptions.top || this.chartHeight - b.height - l - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (c && \"bottom\" === c.verticalAlign && c.enabled && !c.floating ? a.legendHeight + f(c.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));\n        d && h && (this.inverted ? d.options.left = h.options.left = b.left : d.options.top = h.options.top = b.top, d.setAxisSize(), h.setAxisSize());\n      }\n    }), t(k, \"update\", function (a) {\n      var c = a.options.navigator || {},\n          d = a.options.scrollbar || {};\n      this.navigator || this.scroller || !c.enabled && !d.enabled || (b(!0, this.options.navigator, c), b(!0, this.options.scrollbar, d), delete a.options.navigator, delete a.options.scrollbar);\n    }), t(k, \"afterUpdate\", function (a) {\n      this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new w(this), f(a.redraw, !0) && this.redraw(a.animation));\n    }), t(k, \"afterAddSeries\", function () {\n      this.navigator && this.navigator.setBaseSeries(null, !1);\n    }), t(r, \"afterUpdate\", function () {\n      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);\n    }), k.prototype.callbacks.push(function (a) {\n      var b = a.navigator;\n      b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));\n    }));\n  });\n  K(I, \"parts/OrdinalAxis.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined;\n    k = d.addEvent;\n    var D = d.Axis,\n        H = d.Chart,\n        E = d.css,\n        y = d.extend,\n        C = d.noop,\n        t = d.pick,\n        G = d.timeUnits;\n    k(d.Series, \"updatedData\", function () {\n      var d = this.xAxis;\n      d && d.options.ordinal && delete d.ordinalIndex;\n    });\n\n    D.prototype.getTimeTicks = function (d, l, k, q, c, a, b) {\n      var f = 0,\n          m,\n          h,\n          p = {},\n          u = [],\n          v = -Number.MAX_VALUE,\n          n = this.options.tickPixelInterval,\n          e = this.chart.time,\n          g = [];\n      if (!this.options.ordinal && !this.options.breaks || !c || 3 > c.length || void 0 === l) return e.getTimeTicks.apply(e, arguments);\n      var t = c.length;\n\n      for (m = 0; m < t; m++) {\n        var A = m && c[m - 1] > k;\n        c[m] < l && (f = m);\n\n        if (m === t - 1 || c[m + 1] - c[m] > 5 * a || A) {\n          if (c[m] > v) {\n            for (h = e.getTimeTicks(d, c[f], c[m], q); h.length && h[0] <= v;) h.shift();\n\n            h.length && (v = h[h.length - 1]);\n            g.push(u.length);\n            u = u.concat(h);\n          }\n\n          f = m + 1;\n        }\n\n        if (A) break;\n      }\n\n      h = h.info;\n\n      if (b && h.unitRange <= G.hour) {\n        m = u.length - 1;\n\n        for (f = 1; f < m; f++) if (e.dateFormat(\"%d\", u[f]) !== e.dateFormat(\"%d\", u[f - 1])) {\n          p[u[f]] = \"day\";\n          var z = !0;\n        }\n\n        z && (p[u[0]] = \"day\");\n        h.higherRanks = p;\n      }\n\n      h.segmentStarts = g;\n      u.info = h;\n\n      if (b && w(n)) {\n        f = g = u.length;\n        z = [];\n        var B;\n\n        for (e = []; f--;) m = this.translate(u[f]), B && (e[f] = B - m), z[f] = B = m;\n\n        e.sort();\n        e = e[Math.floor(e.length / 2)];\n        e < .6 * n && (e = null);\n        f = u[g - 1] > k ? g - 1 : g;\n\n        for (B = void 0; f--;) m = z[f], g = Math.abs(B - m), B && g < .8 * n && (null === e || g < .8 * e) ? (p[u[f]] && !p[u[f + 1]] ? (g = f + 1, B = m) : g = f, u.splice(g, 1)) : B = m;\n      }\n\n      return u;\n    };\n\n    y(D.prototype, {\n      beforeSetTickPositions: function () {\n        var d = [],\n            l,\n            k = !1,\n            q = this.getExtremes(),\n            c = q.min,\n            a = q.max,\n            b,\n            f = this.isXAxis && !!this.options.breaks;\n        q = this.options.ordinal;\n        var m = Number.MAX_VALUE,\n            h = this.chart.options.chart.ignoreHiddenSeries,\n            r;\n\n        if (q || f) {\n          this.series.forEach(function (a, b) {\n            l = [];\n\n            if (!(h && !1 === a.visible || !1 === a.takeOrdinalPosition && !f) && (d = d.concat(a.processedXData), x = d.length, d.sort(function (a, b) {\n              return a - b;\n            }), m = Math.min(m, t(a.closestPointRange, m)), x)) {\n              for (b = 0; b < x - 1;) d[b] !== d[b + 1] && l.push(d[b + 1]), b++;\n\n              l[0] !== d[0] && l.unshift(d[0]);\n              d = l;\n            }\n\n            a.isSeriesBoosting && (r = !0);\n          });\n          r && (d.length = 0);\n          var x = d.length;\n\n          if (2 < x) {\n            var v = d[1] - d[0];\n\n            for (b = x - 1; b-- && !k;) d[b + 1] - d[b] !== v && (k = !0);\n\n            !this.options.keepOrdinalPadding && (d[0] - c > v || a - d[d.length - 1] > v) && (k = !0);\n          } else this.options.overscroll && (2 === x ? m = d[1] - d[0] : 1 === x ? (m = this.options.overscroll, d = [d[0], d[0] + m]) : m = this.overscrollPointsRange);\n\n          k ? (this.options.overscroll && (this.overscrollPointsRange = m, d = d.concat(this.getOverscrollPositions())), this.ordinalPositions = d, v = this.ordinal2lin(Math.max(c, d[0]), !0), b = Math.max(this.ordinal2lin(Math.min(a, d[d.length - 1]), !0), 1), this.ordinalSlope = a = (a - c) / (b - v), this.ordinalOffset = c - v * a) : (this.overscrollPointsRange = t(this.closestPointRange, this.overscrollPointsRange), this.ordinalPositions = this.ordinalSlope = this.ordinalOffset = void 0);\n        }\n\n        this.isOrdinal = q && k;\n        this.groupIntervalFactor = null;\n      },\n      val2lin: function (d, l) {\n        var k = this.ordinalPositions;\n\n        if (k) {\n          var q = k.length,\n              c;\n\n          for (c = q; c--;) if (k[c] === d) {\n            var a = c;\n            break;\n          }\n\n          for (c = q - 1; c--;) if (d > k[c] || 0 === c) {\n            d = (d - k[c]) / (k[c + 1] - k[c]);\n            a = c + d;\n            break;\n          }\n\n          l = l ? a : this.ordinalSlope * (a || 0) + this.ordinalOffset;\n        } else l = d;\n\n        return l;\n      },\n      lin2val: function (d, l) {\n        var k = this.ordinalPositions;\n\n        if (k) {\n          var q = this.ordinalSlope,\n              c = this.ordinalOffset,\n              a = k.length - 1;\n          if (l) {\n            if (0 > d) d = k[0];else if (d > a) d = k[a];else {\n              a = Math.floor(d);\n              var b = d - a;\n            }\n          } else for (; a--;) if (l = q * a + c, d >= l) {\n            q = q * (a + 1) + c;\n            b = (d - l) / (q - l);\n            break;\n          }\n          return void 0 !== b && void 0 !== k[a] ? k[a] + (b ? b * (k[a + 1] - k[a]) : 0) : d;\n        }\n\n        return d;\n      },\n      getExtendedPositions: function () {\n        var d = this,\n            l = d.chart,\n            k = d.series[0].currentDataGrouping,\n            q = d.ordinalIndex,\n            c = k ? k.count + k.unitName : \"raw\",\n            a = d.options.overscroll,\n            b = d.getExtremes(),\n            f;\n        q || (q = d.ordinalIndex = {});\n\n        if (!q[c]) {\n          var m = {\n            series: [],\n            chart: l,\n            getExtremes: function () {\n              return {\n                min: b.dataMin,\n                max: b.dataMax + a\n              };\n            },\n            options: {\n              ordinal: !0\n            },\n            val2lin: D.prototype.val2lin,\n            ordinal2lin: D.prototype.ordinal2lin\n          };\n          d.series.forEach(function (a) {\n            f = {\n              xAxis: m,\n              xData: a.xData.slice(),\n              chart: l,\n              destroyGroupedData: C\n            };\n            f.xData = f.xData.concat(d.getOverscrollPositions());\n            f.options = {\n              dataGrouping: k ? {\n                enabled: !0,\n                forced: !0,\n                approximation: \"open\",\n                units: [[k.unitName, [k.count]]]\n              } : {\n                enabled: !1\n              }\n            };\n            a.processData.apply(f);\n            m.series.push(f);\n          });\n          d.beforeSetTickPositions.apply(m);\n          q[c] = m.ordinalPositions;\n        }\n\n        return q[c];\n      },\n      getOverscrollPositions: function () {\n        var d = this.options.overscroll,\n            l = this.overscrollPointsRange,\n            k = [],\n            q = this.dataMax;\n        if (w(l)) for (k.push(q); q <= this.dataMax + d;) q += l, k.push(q);\n        return k;\n      },\n      getGroupIntervalFactor: function (d, l, k) {\n        k = k.processedXData;\n        var p = k.length,\n            c = [];\n        var a = this.groupIntervalFactor;\n\n        if (!a) {\n          for (a = 0; a < p - 1; a++) c[a] = k[a + 1] - k[a];\n\n          c.sort(function (a, c) {\n            return a - c;\n          });\n          c = c[Math.floor(p / 2)];\n          d = Math.max(d, k[0]);\n          l = Math.min(l, k[p - 1]);\n          this.groupIntervalFactor = a = p * c / (l - d);\n        }\n\n        return a;\n      },\n      postProcessTickInterval: function (d) {\n        var l = this.ordinalSlope;\n        return l ? this.options.breaks ? this.closestPointRange || d : d / (l / this.closestPointRange) : d;\n      }\n    });\n    D.prototype.ordinal2lin = D.prototype.val2lin;\n    k(H, \"pan\", function (d) {\n      var l = this.xAxis[0],\n          k = l.options.overscroll,\n          q = d.originalEvent.chartX,\n          c = !1;\n\n      if (l.options.ordinal && l.series.length) {\n        var a = this.mouseDownX,\n            b = l.getExtremes(),\n            f = b.dataMax,\n            m = b.min,\n            h = b.max,\n            r = this.hoverPoints,\n            x = l.closestPointRange || l.overscrollPointsRange;\n        a = (a - q) / (l.translationSlope * (l.ordinalSlope || x));\n        var v = {\n          ordinalPositions: l.getExtendedPositions()\n        };\n        x = l.lin2val;\n        var n = l.val2lin;\n        if (!v.ordinalPositions) c = !0;else if (1 < Math.abs(a)) {\n          r && r.forEach(function (a) {\n            a.setState();\n          });\n\n          if (0 > a) {\n            r = v;\n            var e = l.ordinalPositions ? l : v;\n          } else r = l.ordinalPositions ? l : v, e = v;\n\n          v = e.ordinalPositions;\n          f > v[v.length - 1] && v.push(f);\n          this.fixedRange = h - m;\n          a = l.toFixedRange(null, null, x.apply(r, [n.apply(r, [m, !0]) + a, !0]), x.apply(e, [n.apply(e, [h, !0]) + a, !0]));\n          a.min >= Math.min(b.dataMin, m) && a.max <= Math.max(f, h) + k && l.setExtremes(a.min, a.max, !0, !1, {\n            trigger: \"pan\"\n          });\n          this.mouseDownX = q;\n          E(this.container, {\n            cursor: \"move\"\n          });\n        }\n      } else c = !0;\n\n      c ? k && (l.max = l.dataMax + k) : d.preventDefault();\n    });\n    k(D, \"foundExtremes\", function () {\n      this.isXAxis && w(this.options.overscroll) && this.max === this.dataMax && (!this.chart.mouseIsDown || this.isInternal) && (!this.eventArgs || this.eventArgs && \"navigator\" !== this.eventArgs.trigger) && (this.max += this.options.overscroll, !this.isInternal && w(this.userMin) && (this.min += this.options.overscroll));\n    });\n    k(D, \"afterSetScale\", function () {\n      this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);\n    });\n  });\n  K(I, \"modules/broken-axis.src.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.isArray;\n    k = d.addEvent;\n\n    var D = d.pick,\n        H = d.extend,\n        E = d.find,\n        y = d.fireEvent,\n        C = d.Axis,\n        t = d.Series,\n        G = function (d, l) {\n      return E(l, function (l) {\n        return l.from < d && d < l.to;\n      });\n    };\n\n    H(C.prototype, {\n      isInBreak: function (d, l) {\n        var k = d.repeat || Infinity,\n            q = d.from,\n            c = d.to - d.from;\n        l = l >= q ? (l - q) % k : k - (q - l) % k;\n        return d.inclusive ? l <= c : l < c && 0 !== l;\n      },\n      isInAnyBreak: function (d, l) {\n        var k = this.options.breaks,\n            q = k && k.length,\n            c;\n\n        if (q) {\n          for (; q--;) if (this.isInBreak(k[q], d)) {\n            var a = !0;\n            c || (c = D(k[q].showPoints, !this.isXAxis));\n          }\n\n          var b = a && l ? a && !c : a;\n        }\n\n        return b;\n      }\n    });\n    k(C, \"afterInit\", function () {\n      \"function\" === typeof this.setBreaks && this.setBreaks(this.options.breaks, !1);\n    });\n    k(C, \"afterSetTickPositions\", function () {\n      if (this.isBroken) {\n        var d = this.tickPositions,\n            l = this.tickPositions.info,\n            k = [],\n            q;\n\n        for (q = 0; q < d.length; q++) this.isInAnyBreak(d[q]) || k.push(d[q]);\n\n        this.tickPositions = k;\n        this.tickPositions.info = l;\n      }\n    });\n    k(C, \"afterSetOptions\", function () {\n      this.isBroken && (this.options.ordinal = !1);\n    });\n\n    C.prototype.setBreaks = function (d, l) {\n      function k(a) {\n        var b = a,\n            d;\n\n        for (d = 0; d < c.breakArray.length; d++) {\n          var h = c.breakArray[d];\n          if (h.to <= a) b -= h.len;else if (h.from >= a) break;else if (c.isInBreak(h, a)) {\n            b -= a - h.from;\n            break;\n          }\n        }\n\n        return b;\n      }\n\n      function q(a) {\n        var b;\n\n        for (b = 0; b < c.breakArray.length; b++) {\n          var d = c.breakArray[b];\n          if (d.from >= a) break;else d.to < a ? a += d.len : c.isInBreak(d, a) && (a += d.len);\n        }\n\n        return a;\n      }\n\n      var c = this,\n          a = w(d) && !!d.length;\n      c.isDirty = c.isBroken !== a;\n      c.isBroken = a;\n      c.options.breaks = c.userOptions.breaks = d;\n      c.forceRedraw = !0;\n      a || c.val2lin !== k || (delete c.val2lin, delete c.lin2val);\n      a && (c.userOptions.ordinal = !1, c.val2lin = k, c.lin2val = q, c.setExtremes = function (a, c, d, h, l) {\n        if (this.isBroken) {\n          for (var b, f = this.options.breaks; b = G(a, f);) a = b.to;\n\n          for (; b = G(c, f);) c = b.from;\n\n          c < a && (c = a);\n        }\n\n        C.prototype.setExtremes.call(this, a, c, d, h, l);\n      }, c.setAxisTranslation = function (a) {\n        C.prototype.setAxisTranslation.call(this, a);\n        this.unitLength = null;\n\n        if (this.isBroken) {\n          a = c.options.breaks;\n          var b = [],\n              d = [],\n              h = 0,\n              l,\n              k = c.userMin || c.min,\n              p = c.userMax || c.max,\n              n = D(c.pointRangePadding, 0),\n              e;\n          a.forEach(function (a) {\n            l = a.repeat || Infinity;\n            c.isInBreak(a, k) && (k += a.to % l - k % l);\n            c.isInBreak(a, p) && (p -= p % l - a.from % l);\n          });\n          a.forEach(function (a) {\n            q = a.from;\n\n            for (l = a.repeat || Infinity; q - l > k;) q -= l;\n\n            for (; q < k;) q += l;\n\n            for (e = q; e < p; e += l) b.push({\n              value: e,\n              move: \"in\"\n            }), b.push({\n              value: e + (a.to - a.from),\n              move: \"out\",\n              size: a.breakSize\n            });\n          });\n          b.sort(function (a, b) {\n            return a.value === b.value ? (\"in\" === a.move ? 0 : 1) - (\"in\" === b.move ? 0 : 1) : a.value - b.value;\n          });\n          var g = 0;\n          var q = k;\n          b.forEach(function (a) {\n            g += \"in\" === a.move ? 1 : -1;\n            1 === g && \"in\" === a.move && (q = a.value);\n            0 === g && (d.push({\n              from: q,\n              to: a.value,\n              len: a.value - q - (a.size || 0)\n            }), h += a.value - q - (a.size || 0));\n          });\n          c.breakArray = d;\n          c.unitLength = p - k - h + n;\n          y(c, \"afterBreaks\");\n          c.staticScale ? c.transA = c.staticScale : c.unitLength && (c.transA *= (p - c.min + n) / c.unitLength);\n          n && (c.minPixelPadding = c.transA * c.minPointOffset);\n          c.min = k;\n          c.max = p;\n        }\n      });\n      D(l, !0) && this.chart.redraw();\n    };\n\n    k(t, \"afterGeneratePoints\", function () {\n      var d = this.xAxis,\n          l = this.yAxis,\n          k = this.points,\n          q = k.length,\n          c = this.options.connectNulls;\n      if (d && l && (d.options.breaks || l.options.breaks)) for (; q--;) {\n        var a = k[q];\n        var b = null === a.y && !1 === c;\n        b || !d.isInAnyBreak(a.x, !0) && !l.isInAnyBreak(a.y, !0) || (k.splice(q, 1), this.data[q] && this.data[q].destroyElements());\n      }\n    });\n    k(t, \"afterRender\", function () {\n      this.drawBreaks(this.xAxis, [\"x\"]);\n      this.drawBreaks(this.yAxis, D(this.pointArrayMap, [\"y\"]));\n    });\n\n    d.Series.prototype.drawBreaks = function (d, l) {\n      var k = this,\n          q = k.points,\n          c,\n          a,\n          b,\n          f;\n      d && l.forEach(function (l) {\n        c = d.breakArray || [];\n        a = d.isXAxis ? d.min : D(k.options.threshold, d.min);\n        q.forEach(function (h) {\n          f = D(h[\"stack\" + l.toUpperCase()], h[l]);\n          c.forEach(function (c) {\n            b = !1;\n            if (a < c.from && f > c.to || a > c.from && f < c.from) b = \"pointBreak\";else if (a < c.from && f > c.from && f < c.to || a > c.from && f > c.to && f < c.from) b = \"pointInBreak\";\n            b && y(d, b, {\n              point: h,\n              brk: c\n            });\n          });\n        });\n      });\n    };\n\n    d.Series.prototype.gappedPath = function () {\n      var k = this.currentDataGrouping,\n          l = k && k.gapSize;\n      k = this.options.gapSize;\n      var p = this.points.slice(),\n          q = p.length - 1,\n          c = this.yAxis;\n      if (k && 0 < q) for (\"value\" !== this.options.gapUnit && (k *= this.basePointRange), l && l > k && l >= this.basePointRange && (k = l); q--;) p[q + 1].x - p[q].x > k && (l = (p[q].x + p[q + 1].x) / 2, p.splice(q + 1, 0, {\n        isNull: !0,\n        x: l\n      }), this.options.stacking && (l = c.stacks[this.stackKey][l] = new d.StackItem(c, c.options.stackLabels, !1, l, this.stack), l.total = 0));\n      return this.getGraphPath(p);\n    };\n  });\n  K(I, \"masters/modules/broken-axis.src.js\", [], function () {});\n  K(I, \"parts/DataGrouping.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.isNumber;\n    k = d.addEvent;\n\n    var H = d.arrayMax,\n        E = d.arrayMin,\n        y = d.Axis,\n        C = d.correctFloat,\n        t = d.defaultPlotOptions,\n        G = d.extend,\n        u = d.format,\n        l = d.merge,\n        p = d.pick,\n        q = d.Point,\n        c = d.Series,\n        a = d.Tooltip,\n        b = d.approximations = {\n      sum: function (a) {\n        var b = a.length;\n        if (!b && a.hasNulls) var c = null;else if (b) for (c = 0; b--;) c += a[b];\n        return c;\n      },\n      average: function (a) {\n        var c = a.length;\n        a = b.sum(a);\n        D(a) && c && (a = C(a / c));\n        return a;\n      },\n      averages: function () {\n        var a = [];\n        [].forEach.call(arguments, function (c) {\n          a.push(b.average(c));\n        });\n        return void 0 === a[0] ? void 0 : a;\n      },\n      open: function (a) {\n        return a.length ? a[0] : a.hasNulls ? null : void 0;\n      },\n      high: function (a) {\n        return a.length ? H(a) : a.hasNulls ? null : void 0;\n      },\n      low: function (a) {\n        return a.length ? E(a) : a.hasNulls ? null : void 0;\n      },\n      close: function (a) {\n        return a.length ? a[a.length - 1] : a.hasNulls ? null : void 0;\n      },\n      ohlc: function (a, c, d, e) {\n        a = b.open(a);\n        c = b.high(c);\n        d = b.low(d);\n        e = b.close(e);\n        if (D(a) || D(c) || D(d) || D(e)) return [a, c, d, e];\n      },\n      range: function (a, c) {\n        a = b.low(a);\n        c = b.high(c);\n        if (D(a) || D(c)) return [a, c];\n        if (null === a && null === c) return null;\n      }\n    },\n        f = function (a, c, d, e) {\n      var g = this,\n          h = g.data,\n          f = g.options && g.options.data,\n          k = [],\n          m = [],\n          n = [],\n          p = a.length,\n          r = !!c,\n          q = [],\n          v = g.pointArrayMap,\n          A = v && v.length,\n          x = [\"x\"].concat(v || [\"y\"]),\n          t = 0,\n          z = 0,\n          u;\n      e = \"function\" === typeof e ? e : b[e] ? b[e] : b[g.getDGApproximation && g.getDGApproximation() || \"average\"];\n      A ? v.forEach(function () {\n        q.push([]);\n      }) : q.push([]);\n      var F = A || 1;\n\n      for (u = 0; u <= p && !(a[u] >= d[0]); u++);\n\n      for (u; u <= p; u++) {\n        for (; void 0 !== d[t + 1] && a[u] >= d[t + 1] || u === p;) {\n          var y = d[t];\n          g.dataGroupInfo = {\n            start: g.cropStart + z,\n            length: q[0].length\n          };\n          var C = e.apply(g, q);\n          g.pointClass && !w(g.dataGroupInfo.options) && (g.dataGroupInfo.options = l(g.pointClass.prototype.optionsToObject.call({\n            series: g\n          }, g.options.data[g.cropStart + z])), x.forEach(function (a) {\n            delete g.dataGroupInfo.options[a];\n          }));\n          void 0 !== C && (k.push(y), m.push(C), n.push(g.dataGroupInfo));\n          z = u;\n\n          for (y = 0; y < F; y++) q[y].length = 0, q[y].hasNulls = !1;\n\n          t += 1;\n          if (u === p) break;\n        }\n\n        if (u === p) break;\n        if (v) for (y = g.cropStart + u, C = h && h[y] || g.pointClass.prototype.applyOptions.apply({\n          series: g\n        }, [f[y]]), y = 0; y < A; y++) {\n          var E = C[v[y]];\n          D(E) ? q[y].push(E) : null === E && (q[y].hasNulls = !0);\n        } else y = r ? c[u] : null, D(y) ? q[0].push(y) : null === y && (q[0].hasNulls = !0);\n      }\n\n      return {\n        groupedXData: k,\n        groupedYData: m,\n        groupMap: n\n      };\n    },\n        m = {\n      approximations: b,\n      groupData: f\n    },\n        h = c.prototype,\n        r = h.processData,\n        x = h.generatePoints,\n        v = {\n      groupPixelWidth: 2,\n      dateTimeLabelFormats: {\n        millisecond: [\"%A, %b %e, %H:%M:%S.%L\", \"%A, %b %e, %H:%M:%S.%L\", \"-%H:%M:%S.%L\"],\n        second: [\"%A, %b %e, %H:%M:%S\", \"%A, %b %e, %H:%M:%S\", \"-%H:%M:%S\"],\n        minute: [\"%A, %b %e, %H:%M\", \"%A, %b %e, %H:%M\", \"-%H:%M\"],\n        hour: [\"%A, %b %e, %H:%M\", \"%A, %b %e, %H:%M\", \"-%H:%M\"],\n        day: [\"%A, %b %e, %Y\", \"%A, %b %e\", \"-%A, %b %e, %Y\"],\n        week: [\"Week from %A, %b %e, %Y\", \"%A, %b %e\", \"-%A, %b %e, %Y\"],\n        month: [\"%B %Y\", \"%B\", \"-%B %Y\"],\n        year: [\"%Y\", \"%Y\", \"-%Y\"]\n      }\n    },\n        n = {\n      line: {},\n      spline: {},\n      area: {},\n      areaspline: {},\n      column: {\n        groupPixelWidth: 10\n      },\n      columnrange: {\n        groupPixelWidth: 10\n      },\n      candlestick: {\n        groupPixelWidth: 10\n      },\n      ohlc: {\n        groupPixelWidth: 5\n      }\n    },\n        e = d.defaultDataGroupingUnits = [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1]], [\"week\", [1]], [\"month\", [1, 3, 6]], [\"year\", null]];\n\n    h.getDGApproximation = function () {\n      return d.seriesTypes.arearange && this instanceof d.seriesTypes.arearange ? \"range\" : d.seriesTypes.ohlc && this instanceof d.seriesTypes.ohlc ? \"ohlc\" : d.seriesTypes.column && this instanceof d.seriesTypes.column ? \"sum\" : \"average\";\n    };\n\n    h.groupData = f;\n\n    h.processData = function () {\n      var a = this.chart,\n          b = this.options.dataGrouping,\n          c = !1 !== this.allowDG && b && p(b.enabled, a.options.isStock),\n          d = this.visible || !a.options.chart.ignoreHiddenSeries,\n          f,\n          l = this.currentDataGrouping,\n          k = !1;\n      this.forceCrop = c;\n      this.groupPixelWidth = null;\n      this.hasProcessed = !0;\n      c && !this.requireSorting && (this.requireSorting = k = !0);\n      c = !1 === r.apply(this, arguments) || !c;\n      k && (this.requireSorting = !1);\n\n      if (!c) {\n        this.destroyGroupedData();\n        c = b.groupAll ? this.xData : this.processedXData;\n        var m = b.groupAll ? this.yData : this.processedYData,\n            n = a.plotSizeX;\n        a = this.xAxis;\n        var q = a.options.ordinal,\n            v = this.groupPixelWidth = a.getGroupPixelWidth && a.getGroupPixelWidth();\n\n        if (v) {\n          this.isDirty = f = !0;\n          this.points = null;\n          k = a.getExtremes();\n          var x = k.min;\n          k = k.max;\n          q = q && a.getGroupIntervalFactor(x, k, this) || 1;\n          v = v * (k - x) / n * q;\n          n = a.getTimeTicks(a.normalizeTimeTickInterval(v, b.units || e), Math.min(x, c[0]), Math.max(k, c[c.length - 1]), a.options.startOfWeek, c, this.closestPointRange);\n          m = h.groupData.apply(this, [c, m, n, b.approximation]);\n          c = m.groupedXData;\n          q = m.groupedYData;\n          var t = 0;\n\n          if (b.smoothed && c.length) {\n            var u = c.length - 1;\n\n            for (c[u] = Math.min(c[u], k); u-- && 0 < u;) c[u] += v / 2;\n\n            c[0] = Math.max(c[0], x);\n          }\n\n          for (u = 1; u < n.length; u++) n.info.segmentStarts && -1 !== n.info.segmentStarts.indexOf(u) || (t = Math.max(n[u] - n[u - 1], t));\n\n          x = n.info;\n          x.gapSize = t;\n          this.closestPointRange = n.info.totalRange;\n          this.groupMap = m.groupMap;\n\n          if (w(c[0]) && c[0] < a.min && d) {\n            if (!w(a.options.min) && a.min <= a.dataMin || a.min === a.dataMin) a.min = c[0];\n            a.dataMin = c[0];\n          }\n\n          b.groupAll && (b = this.cropData(c, q, a.min, a.max, 1), c = b.xData, q = b.yData);\n          this.processedXData = c;\n          this.processedYData = q;\n        } else this.groupMap = null;\n\n        this.hasGroupedData = f;\n        this.currentDataGrouping = x;\n        this.preventGraphAnimation = (l && l.totalRange) !== (x && x.totalRange);\n      }\n    };\n\n    h.destroyGroupedData = function () {\n      var a = this.groupedData;\n      (a || []).forEach(function (b, c) {\n        b && (a[c] = b.destroy ? b.destroy() : null);\n      });\n      this.groupedData = null;\n    };\n\n    h.generatePoints = function () {\n      x.apply(this);\n      this.destroyGroupedData();\n      this.groupedData = this.hasGroupedData ? this.points : null;\n    };\n\n    k(q, \"update\", function () {\n      if (this.dataGroup) return d.error(24, !1, this.series.chart), !1;\n    });\n    k(a, \"headerFormatter\", function (a) {\n      var b = this.chart.time,\n          c = a.labelConfig,\n          d = c.series,\n          e = d.tooltipOptions,\n          g = d.options.dataGrouping,\n          h = e.xDateFormat,\n          f = d.xAxis,\n          l = e[(a.isFooter ? \"footer\" : \"header\") + \"Format\"];\n\n      if (f && \"datetime\" === f.options.type && g && D(c.key)) {\n        var k = d.currentDataGrouping;\n        g = g.dateTimeLabelFormats || v.dateTimeLabelFormats;\n        if (k) {\n          if (e = g[k.unitName], 1 === k.count) h = e[0];else {\n            h = e[1];\n            var m = e[2];\n          }\n        } else !h && g && (h = this.getXDateFormat(c, e, f));\n        h = b.dateFormat(h, c.key);\n        m && (h += b.dateFormat(m, c.key + k.totalRange - 1));\n        d.chart.styledMode && (l = this.styledModeFormat(l));\n        a.text = u(l, {\n          point: G(c.point, {\n            key: h\n          }),\n          series: d\n        }, b);\n        a.preventDefault();\n      }\n    });\n    k(c, \"destroy\", h.destroyGroupedData);\n    k(c, \"afterSetOptions\", function (a) {\n      a = a.options;\n      var b = this.type,\n          c = this.chart.options.plotOptions,\n          d = t[b].dataGrouping,\n          e = this.useCommonDataGrouping && v;\n      if (n[b] || e) d || (d = l(v, n[b])), a.dataGrouping = l(e, d, c.series && c.series.dataGrouping, c[b].dataGrouping, this.userOptions.dataGrouping);\n    });\n    k(y, \"afterSetScale\", function () {\n      this.series.forEach(function (a) {\n        a.hasProcessed = !1;\n      });\n    });\n\n    y.prototype.getGroupPixelWidth = function () {\n      var a = this.series,\n          b = a.length,\n          c,\n          d = 0,\n          e = !1,\n          h;\n\n      for (c = b; c--;) (h = a[c].options.dataGrouping) && (d = Math.max(d, p(h.groupPixelWidth, v.groupPixelWidth)));\n\n      for (c = b; c--;) (h = a[c].options.dataGrouping) && a[c].hasProcessed && (b = (a[c].processedXData || a[c].data).length, a[c].groupPixelWidth || b > this.chart.plotSizeX / d || b && h.forced) && (e = !0);\n\n      return e ? d : 0;\n    };\n\n    y.prototype.setDataGrouping = function (a, b) {\n      var c;\n      b = p(b, !0);\n      a || (a = {\n        forced: !1,\n        units: null\n      });\n      if (this instanceof y) for (c = this.series.length; c--;) this.series[c].update({\n        dataGrouping: a\n      }, !1);else this.chart.options.series.forEach(function (b) {\n        b.dataGrouping = a;\n      }, !1);\n      this.ordinalSlope = null;\n      b && this.chart.redraw();\n    };\n\n    d.dataGrouping = m;\n    \"\";\n    return m;\n  });\n  K(I, \"parts/OHLCSeries.js\", [I[\"parts/Globals.js\"]], function (d) {\n    var k = d.Point,\n        w = d.seriesType,\n        D = d.seriesTypes;\n    w(\"ohlc\", \"column\", {\n      lineWidth: 1,\n      tooltip: {\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>'\n      },\n      threshold: null,\n      states: {\n        hover: {\n          lineWidth: 3\n        }\n      },\n      stickyTracking: !0\n    }, {\n      directTouch: !1,\n      pointArrayMap: [\"open\", \"high\", \"low\", \"close\"],\n      toYData: function (d) {\n        return [d.open, d.high, d.low, d.close];\n      },\n      pointValKey: \"close\",\n      pointAttrToOptions: {\n        stroke: \"color\",\n        \"stroke-width\": \"lineWidth\"\n      },\n      init: function () {\n        D.column.prototype.init.apply(this, arguments);\n        this.options.stacking = !1;\n      },\n      pointAttribs: function (d, k) {\n        k = D.column.prototype.pointAttribs.call(this, d, k);\n        var y = this.options;\n        delete k.fill;\n        !d.options.color && y.upColor && d.open < d.close && (k.stroke = y.upColor);\n        return k;\n      },\n      translate: function () {\n        var d = this,\n            k = d.yAxis,\n            y = !!d.modifyValue,\n            w = [\"plotOpen\", \"plotHigh\", \"plotLow\", \"plotClose\", \"yBottom\"];\n        D.column.prototype.translate.apply(d);\n        d.points.forEach(function (t) {\n          [t.open, t.high, t.low, t.close, t.low].forEach(function (C, u) {\n            null !== C && (y && (C = d.modifyValue(C)), t[w[u]] = k.toPixels(C, !0));\n          });\n          t.tooltipPos[1] = t.plotHigh + k.pos - d.chart.plotTop;\n        });\n      },\n      drawPoints: function () {\n        var d = this,\n            k = d.chart;\n        d.points.forEach(function (y) {\n          var w = y.graphic,\n              t = !w;\n\n          if (void 0 !== y.plotY) {\n            w || (y.graphic = w = k.renderer.path().add(d.group));\n            k.styledMode || w.attr(d.pointAttribs(y, y.selected && \"select\"));\n            var E = w.strokeWidth() % 2 / 2;\n            var u = Math.round(y.plotX) - E;\n            var l = Math.round(y.shapeArgs.width / 2);\n            var p = [\"M\", u, Math.round(y.yBottom), \"L\", u, Math.round(y.plotHigh)];\n\n            if (null !== y.open) {\n              var q = Math.round(y.plotOpen) + E;\n              p.push(\"M\", u, q, \"L\", u - l, q);\n            }\n\n            null !== y.close && (q = Math.round(y.plotClose) + E, p.push(\"M\", u, q, \"L\", u + l, q));\n            w[t ? \"attr\" : \"animate\"]({\n              d: p\n            }).addClass(y.getClassName(), !0);\n          }\n        });\n      },\n      animate: null\n    }, {\n      getClassName: function () {\n        return k.prototype.getClassName.call(this) + (this.open < this.close ? \" highcharts-point-up\" : \" highcharts-point-down\");\n      }\n    });\n    \"\";\n  });\n  K(I, \"parts/CandlestickSeries.js\", [I[\"parts/Globals.js\"]], function (d) {\n    var k = d.defaultPlotOptions,\n        w = d.merge,\n        D = d.seriesType,\n        H = d.seriesTypes;\n    D(\"candlestick\", \"ohlc\", w(k.column, {\n      states: {\n        hover: {\n          lineWidth: 2\n        }\n      },\n      tooltip: k.ohlc.tooltip,\n      threshold: null,\n      lineColor: \"#000000\",\n      lineWidth: 1,\n      upColor: \"#ffffff\",\n      stickyTracking: !0\n    }), {\n      pointAttribs: function (d, k) {\n        var w = H.column.prototype.pointAttribs.call(this, d, k),\n            t = this.options,\n            y = d.open < d.close,\n            u = t.lineColor || this.color;\n        w[\"stroke-width\"] = t.lineWidth;\n        w.fill = d.options.color || (y ? t.upColor || this.color : this.color);\n        w.stroke = d.options.lineColor || (y ? t.upLineColor || u : u);\n        k && (d = t.states[k], w.fill = d.color || w.fill, w.stroke = d.lineColor || w.stroke, w[\"stroke-width\"] = d.lineWidth || w[\"stroke-width\"]);\n        return w;\n      },\n      drawPoints: function () {\n        var d = this,\n            k = d.chart,\n            w = d.yAxis.reversed;\n        d.points.forEach(function (t) {\n          var y = t.graphic,\n              u = !y;\n\n          if (void 0 !== t.plotY) {\n            y || (t.graphic = y = k.renderer.path().add(d.group));\n            d.chart.styledMode || y.attr(d.pointAttribs(t, t.selected && \"select\")).shadow(d.options.shadow);\n            var l = y.strokeWidth() % 2 / 2;\n            var p = Math.round(t.plotX) - l;\n            var q = t.plotOpen;\n            var c = t.plotClose;\n            var a = Math.min(q, c);\n            q = Math.max(q, c);\n            var b = Math.round(t.shapeArgs.width / 2);\n            c = w ? q !== t.yBottom : Math.round(a) !== Math.round(t.plotHigh);\n            var f = w ? Math.round(a) !== Math.round(t.plotHigh) : q !== t.yBottom;\n            a = Math.round(a) + l;\n            q = Math.round(q) + l;\n            l = [];\n            l.push(\"M\", p - b, q, \"L\", p - b, a, \"L\", p + b, a, \"L\", p + b, q, \"Z\", \"M\", p, a, \"L\", p, c ? Math.round(w ? t.yBottom : t.plotHigh) : a, \"M\", p, q, \"L\", p, f ? Math.round(w ? t.plotHigh : t.yBottom) : q);\n            y[u ? \"attr\" : \"animate\"]({\n              d: l\n            }).addClass(t.getClassName(), !0);\n          }\n        });\n      }\n    });\n    \"\";\n  });\n  K(I, \"mixins/on-series.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = d.seriesTypes,\n        H = d.stableSort;\n    return {\n      getPlotBox: function () {\n        return d.Series.prototype.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this);\n      },\n      translate: function () {\n        D.column.prototype.translate.apply(this);\n        var d = this,\n            k = d.options,\n            C = d.chart,\n            t = d.points,\n            G = t.length - 1,\n            u,\n            l = k.onSeries;\n        l = l && C.get(l);\n        k = k.onKey || \"y\";\n        var p = l && l.options.step,\n            q = l && l.points,\n            c = q && q.length,\n            a = C.inverted,\n            b = d.xAxis,\n            f = d.yAxis,\n            m = 0,\n            h;\n\n        if (l && l.visible && c) {\n          m = (l.pointXOffset || 0) + (l.barW || 0) / 2;\n          C = l.currentDataGrouping;\n          var r = q[c - 1].x + (C ? C.totalRange : 0);\n          H(t, function (a, b) {\n            return a.x - b.x;\n          });\n\n          for (k = \"plot\" + k[0].toUpperCase() + k.substr(1); c-- && t[G];) {\n            var x = q[c];\n            C = t[G];\n            C.y = x.y;\n\n            if (x.x <= C.x && void 0 !== x[k]) {\n              if (C.x <= r && (C.plotY = x[k], x.x < C.x && !p && (h = q[c + 1]) && void 0 !== h[k])) {\n                var v = (C.x - x.x) / (h.x - x.x);\n                C.plotY += v * (h[k] - x[k]);\n                C.y += v * (h.y - x.y);\n              }\n\n              G--;\n              c++;\n              if (0 > G) break;\n            }\n          }\n        }\n\n        t.forEach(function (c, e) {\n          c.plotX += m;\n          if (void 0 === c.plotY || a) 0 <= c.plotX && c.plotX <= b.len ? a ? (c.plotY = b.translate(c.x, 0, 1, 0, 1), c.plotX = w(c.y) ? f.translate(c.y, 0, 0, 0, 1) : 0) : c.plotY = (b.opposite ? 0 : d.yAxis.len) + b.offset : c.shapeArgs = {};\n\n          if ((u = t[e - 1]) && u.plotX === c.plotX) {\n            void 0 === u.stackIndex && (u.stackIndex = 0);\n            var g = u.stackIndex + 1;\n          }\n\n          c.stackIndex = g;\n        });\n        this.onSeries = l;\n      }\n    };\n  });\n  K(I, \"parts/FlagsSeries.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"], I[\"mixins/on-series.js\"]], function (d, k, w) {\n    function D(a) {\n      c[a + \"pin\"] = function (b, d, k, h, l) {\n        var f = l && l.anchorX;\n        l = l && l.anchorY;\n        \"circle\" === a && h > k && (b -= Math.round((h - k) / 2), k = h);\n        var m = c[a](b, d, k, h);\n        f && l && (m.push(\"M\", \"circle\" === a ? b + k / 2 : m[1] + m[4] / 2, d > l ? d : d + h, \"L\", f, l), m = m.concat(c.circle(f - 1, l - 1, 2, 2)));\n        return m;\n      };\n    }\n\n    var H = k.defined,\n        E = k.isNumber,\n        y = k.objectEach,\n        C = d.addEvent,\n        t = d.merge;\n    k = d.noop;\n    var G = d.Renderer,\n        u = d.Series,\n        l = d.seriesType,\n        p = d.TrackerMixin,\n        q = d.VMLRenderer,\n        c = d.SVGRenderer.prototype.symbols;\n    l(\"flags\", \"column\", {\n      pointRange: 0,\n      allowOverlapX: !1,\n      shape: \"flag\",\n      stackDistance: 12,\n      textAlign: \"center\",\n      tooltip: {\n        pointFormat: \"{point.text}<br/>\"\n      },\n      threshold: null,\n      y: -30,\n      fillColor: \"#ffffff\",\n      lineWidth: 1,\n      states: {\n        hover: {\n          lineColor: \"#000000\",\n          fillColor: \"#ccd6eb\"\n        }\n      },\n      style: {\n        fontSize: \"11px\",\n        fontWeight: \"bold\"\n      }\n    }, {\n      sorted: !1,\n      noSharedTooltip: !0,\n      allowDG: !1,\n      takeOrdinalPosition: !1,\n      trackerGroups: [\"markerGroup\"],\n      forceCrop: !0,\n      init: u.prototype.init,\n      pointAttribs: function (a, b) {\n        var c = this.options,\n            d = a && a.color || this.color,\n            h = c.lineColor,\n            k = a && a.lineWidth;\n        a = a && a.fillColor || c.fillColor;\n        b && (a = c.states[b].fillColor, h = c.states[b].lineColor, k = c.states[b].lineWidth);\n        return {\n          fill: a || d,\n          stroke: h || d,\n          \"stroke-width\": k || c.lineWidth || 0\n        };\n      },\n      translate: w.translate,\n      getPlotBox: w.getPlotBox,\n      drawPoints: function () {\n        var a = this.points,\n            b = this.chart,\n            c = b.renderer,\n            k = b.inverted,\n            h = this.options,\n            l = h.y,\n            p,\n            q = this.yAxis,\n            n = {},\n            e = [];\n\n        for (p = a.length; p--;) {\n          var g = a[p];\n          var u = (k ? g.plotY : g.plotX) > this.xAxis.len;\n          var A = g.plotX;\n          var z = g.stackIndex;\n          var w = g.options.shape || h.shape;\n          var C = g.plotY;\n          void 0 !== C && (C = g.plotY + l - (void 0 !== z && z * h.stackDistance));\n          g.anchorX = z ? void 0 : g.plotX;\n          var D = z ? void 0 : g.plotY;\n          var E = \"flag\" !== w;\n          z = g.graphic;\n          void 0 !== C && 0 <= A && !u ? (z || (z = g.graphic = c.label(\"\", null, null, w, null, null, h.useHTML), b.styledMode || z.attr(this.pointAttribs(g)).css(t(h.style, g.style)), z.attr({\n            align: E ? \"center\" : \"left\",\n            width: h.width,\n            height: h.height,\n            \"text-align\": h.textAlign\n          }).addClass(\"highcharts-point\").add(this.markerGroup), g.graphic.div && (g.graphic.div.point = g), b.styledMode || z.shadow(h.shadow), z.isNew = !0), 0 < A && (A -= z.strokeWidth() % 2), w = {\n            y: C,\n            anchorY: D\n          }, h.allowOverlapX && (w.x = A, w.anchorX = g.anchorX), z.attr({\n            text: g.options.title || h.title || \"A\"\n          })[z.isNew ? \"attr\" : \"animate\"](w), h.allowOverlapX || (n[g.plotX] ? n[g.plotX].size = Math.max(n[g.plotX].size, z.width) : n[g.plotX] = {\n            align: E ? .5 : 0,\n            size: z.width,\n            target: A,\n            anchorX: A\n          }), g.tooltipPos = [A, C + q.pos - b.plotTop]) : z && (g.graphic = z.destroy());\n        }\n\n        h.allowOverlapX || (y(n, function (a) {\n          a.plotX = a.anchorX;\n          e.push(a);\n        }), d.distribute(e, k ? q.len : this.xAxis.len, 100), a.forEach(function (a) {\n          var b = a.graphic && n[a.plotX];\n          b && (a.graphic[a.graphic.isNew ? \"attr\" : \"animate\"]({\n            x: b.pos + b.align * b.size,\n            anchorX: a.anchorX\n          }), H(b.pos) ? a.graphic.isNew = !1 : (a.graphic.attr({\n            x: -9999,\n            anchorX: -9999\n          }), a.graphic.isNew = !0));\n        }));\n        h.useHTML && d.wrap(this.markerGroup, \"on\", function (a) {\n          return d.SVGElement.prototype.on.apply(a.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));\n        });\n      },\n      drawTracker: function () {\n        var a = this.points;\n        p.drawTrackerPoint.apply(this);\n        a.forEach(function (b) {\n          var c = b.graphic;\n          c && C(c.element, \"mouseover\", function () {\n            0 < b.stackIndex && !b.raised && (b._y = c.y, c.attr({\n              y: b._y - 8\n            }), b.raised = !0);\n            a.forEach(function (a) {\n              a !== b && a.raised && a.graphic && (a.graphic.attr({\n                y: a._y\n              }), a.raised = !1);\n            });\n          });\n        });\n      },\n      animate: function (a) {\n        a ? this.setClip() : this.animate = null;\n      },\n      setClip: function () {\n        u.prototype.setClip.apply(this, arguments);\n        !1 !== this.options.clip && this.sharedClipKey && this.markerGroup.clip(this.chart[this.sharedClipKey]);\n      },\n      buildKDTree: k,\n      invertGroups: k\n    }, {\n      isValid: function () {\n        return E(this.y) || void 0 === this.y;\n      }\n    });\n\n    c.flag = function (a, b, d, k, h) {\n      var f = h && h.anchorX || a;\n      h = h && h.anchorY || b;\n      return c.circle(f - 1, h - 1, 2, 2).concat([\"M\", f, h, \"L\", a, b + k, a, b, a + d, b, a + d, b + k, a, b + k, \"Z\"]);\n    };\n\n    D(\"circle\");\n    D(\"square\");\n    G === q && [\"circlepin\", \"flag\", \"squarepin\"].forEach(function (a) {\n      q.prototype.symbols[a] = c[a];\n    });\n    \"\";\n  });\n  K(I, \"parts/RangeSelector.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    function w(a) {\n      this.init(a);\n    }\n\n    var D = k.defined,\n        H = k.isNumber,\n        E = k.objectEach,\n        y = k.pInt,\n        C = k.splat,\n        t = d.addEvent,\n        G = d.Axis;\n    k = d.Chart;\n    var u = d.css,\n        l = d.createElement,\n        p = d.defaultOptions,\n        q = d.destroyObjectProperties,\n        c = d.discardElement,\n        a = d.extend,\n        b = d.fireEvent,\n        f = d.merge,\n        m = d.pick;\n    a(p, {\n      rangeSelector: {\n        verticalAlign: \"top\",\n        buttonTheme: {\n          width: 28,\n          height: 18,\n          padding: 2,\n          zIndex: 7\n        },\n        floating: !1,\n        x: 0,\n        y: 0,\n        height: void 0,\n        inputPosition: {\n          align: \"right\",\n          x: 0,\n          y: 0\n        },\n        buttonPosition: {\n          align: \"left\",\n          x: 0,\n          y: 0\n        },\n        labelStyle: {\n          color: \"#666666\"\n        }\n      }\n    });\n    p.lang = f(p.lang, {\n      rangeSelectorZoom: \"Zoom\",\n      rangeSelectorFrom: \"From\",\n      rangeSelectorTo: \"To\"\n    });\n    w.prototype = {\n      clickButton: function (a, b) {\n        var c = this.chart,\n            d = this.buttonOptions[a],\n            h = c.xAxis[0],\n            e = c.scroller && c.scroller.getUnionExtremes() || h || {},\n            g = e.dataMin,\n            f = e.dataMax,\n            k = h && Math.round(Math.min(h.max, m(f, h.max))),\n            l = d.type;\n        e = d._range;\n        var p,\n            q = d.dataGrouping;\n\n        if (null !== g && null !== f) {\n          c.fixedRange = e;\n          q && (this.forcedDataGrouping = !0, G.prototype.setDataGrouping.call(h || {\n            chart: this.chart\n          }, q, !1), this.frozenStates = d.preserveDataGrouping);\n          if (\"month\" === l || \"year\" === l) {\n            if (h) {\n              l = {\n                range: d,\n                max: k,\n                chart: c,\n                dataMin: g,\n                dataMax: f\n              };\n              var r = h.minFromRange.call(l);\n              H(l.newMax) && (k = l.newMax);\n            } else e = d;\n          } else if (e) r = Math.max(k - e, g), k = Math.min(r + e, f);else if (\"ytd\" === l) {\n            if (h) void 0 === f && (g = Number.MAX_VALUE, f = Number.MIN_VALUE, c.series.forEach(function (a) {\n              a = a.xData;\n              g = Math.min(a[0], g);\n              f = Math.max(a[a.length - 1], f);\n            }), b = !1), k = this.getYTDExtremes(f, g, c.time.useUTC), r = p = k.min, k = k.max;else {\n              this.deferredYTDClick = a;\n              return;\n            }\n          } else \"all\" === l && h && (r = g, k = f);\n          r += d._offsetMin;\n          k += d._offsetMax;\n          this.setSelected(a);\n          if (h) h.setExtremes(r, k, m(b, 1), null, {\n            trigger: \"rangeSelectorButton\",\n            rangeSelectorButton: d\n          });else {\n            var u = C(c.options.xAxis)[0];\n            var w = u.range;\n            u.range = e;\n            var y = u.min;\n            u.min = p;\n            t(c, \"load\", function () {\n              u.range = w;\n              u.min = y;\n            });\n          }\n        }\n      },\n      setSelected: function (a) {\n        this.selected = this.options.selected = a;\n      },\n      defaultButtons: [{\n        type: \"month\",\n        count: 1,\n        text: \"1m\"\n      }, {\n        type: \"month\",\n        count: 3,\n        text: \"3m\"\n      }, {\n        type: \"month\",\n        count: 6,\n        text: \"6m\"\n      }, {\n        type: \"ytd\",\n        text: \"YTD\"\n      }, {\n        type: \"year\",\n        count: 1,\n        text: \"1y\"\n      }, {\n        type: \"all\",\n        text: \"All\"\n      }],\n      init: function (a) {\n        var c = this,\n            d = a.options.rangeSelector,\n            h = d.buttons || [].concat(c.defaultButtons),\n            f = d.selected,\n            e = function () {\n          var a = c.minInput,\n              d = c.maxInput;\n          a && a.blur && b(a, \"blur\");\n          d && d.blur && b(d, \"blur\");\n        };\n\n        c.chart = a;\n        c.options = d;\n        c.buttons = [];\n        c.buttonOptions = h;\n        this.unMouseDown = t(a.container, \"mousedown\", e);\n        this.unResize = t(a, \"resize\", e);\n        h.forEach(c.computeButtonRange);\n        void 0 !== f && h[f] && this.clickButton(f, !1);\n        t(a, \"load\", function () {\n          a.xAxis && a.xAxis[0] && t(a.xAxis[0], \"setExtremes\", function (b) {\n            this.max - this.min !== a.fixedRange && \"rangeSelectorButton\" !== b.trigger && \"updatedData\" !== b.trigger && c.forcedDataGrouping && !c.frozenStates && this.setDataGrouping(!1, !1);\n          });\n        });\n      },\n      updateButtonStates: function () {\n        var a = this,\n            b = this.chart,\n            c = b.xAxis[0],\n            d = Math.round(c.max - c.min),\n            f = !c.hasVisibleSeries,\n            e = b.scroller && b.scroller.getUnionExtremes() || c,\n            g = e.dataMin,\n            k = e.dataMax;\n        b = a.getYTDExtremes(k, g, b.time.useUTC);\n        var l = b.min,\n            m = b.max,\n            p = a.selected,\n            q = H(p),\n            t = a.options.allButtonsEnabled,\n            u = a.buttons;\n        a.buttonOptions.forEach(function (b, e) {\n          var h = b._range,\n              n = b.type,\n              r = b.count || 1,\n              v = u[e],\n              x = 0,\n              A = b._offsetMax - b._offsetMin;\n          b = e === p;\n          var z = h > k - g,\n              w = h < c.minRange,\n              y = !1,\n              B = !1;\n          h = h === d;\n          (\"month\" === n || \"year\" === n) && d + 36E5 >= 864E5 * {\n            month: 28,\n            year: 365\n          }[n] * r - A && d - 36E5 <= 864E5 * {\n            month: 31,\n            year: 366\n          }[n] * r + A ? h = !0 : \"ytd\" === n ? (h = m - l + A === d, y = !b) : \"all\" === n && (h = c.max - c.min >= k - g, B = !b && q && h);\n          n = !t && (z || w || B || f);\n          r = b && h || h && !q && !y || b && a.frozenStates;\n          n ? x = 3 : r && (q = !0, x = 2);\n          v.state !== x && (v.setState(x), 0 === x && p === e && a.setSelected(null));\n        });\n      },\n      computeButtonRange: function (a) {\n        var b = a.type,\n            c = a.count || 1,\n            d = {\n          millisecond: 1,\n          second: 1E3,\n          minute: 6E4,\n          hour: 36E5,\n          day: 864E5,\n          week: 6048E5\n        };\n        if (d[b]) a._range = d[b] * c;else if (\"month\" === b || \"year\" === b) a._range = 864E5 * {\n          month: 30,\n          year: 365\n        }[b] * c;\n        a._offsetMin = m(a.offsetMin, 0);\n        a._offsetMax = m(a.offsetMax, 0);\n        a._range += a._offsetMax - a._offsetMin;\n      },\n      setInputValue: function (a, b) {\n        var c = this.chart.options.rangeSelector,\n            d = this.chart.time,\n            h = this[a + \"Input\"];\n        D(b) && (h.previousValue = h.HCTime, h.HCTime = b);\n        h.value = d.dateFormat(c.inputEditDateFormat || \"%Y-%m-%d\", h.HCTime);\n        this[a + \"DateBox\"].attr({\n          text: d.dateFormat(c.inputDateFormat || \"%b %e, %Y\", h.HCTime)\n        });\n      },\n      showInput: function (a) {\n        var b = this.inputGroup,\n            c = this[a + \"DateBox\"];\n        u(this[a + \"Input\"], {\n          left: b.translateX + c.x + \"px\",\n          top: b.translateY + \"px\",\n          width: c.width - 2 + \"px\",\n          height: c.height - 2 + \"px\",\n          border: \"2px solid silver\"\n        });\n      },\n      hideInput: function (a) {\n        u(this[a + \"Input\"], {\n          border: 0,\n          width: \"1px\",\n          height: \"1px\"\n        });\n        this.setInputValue(a);\n      },\n      drawInput: function (b) {\n        function c() {\n          var a = z.value,\n              b = (g.inputDateParser || Date.parse)(a),\n              c = k.xAxis[0],\n              d = k.scroller && k.scroller.xAxis ? k.scroller.xAxis : c,\n              e = d.dataMin;\n          d = d.dataMax;\n          b !== z.previousValue && (z.previousValue = b, H(b) || (b = a.split(\"-\"), b = Date.UTC(y(b[0]), y(b[1]) - 1, y(b[2]))), H(b) && (k.time.useUTC || (b += 6E4 * new Date().getTimezoneOffset()), t ? b > h.maxInput.HCTime ? b = void 0 : b < e && (b = e) : b < h.minInput.HCTime ? b = void 0 : b > d && (b = d), void 0 !== b && c.setExtremes(t ? b : c.min, t ? c.max : b, void 0, void 0, {\n            trigger: \"rangeSelectorInput\"\n          })));\n        }\n\n        var h = this,\n            k = h.chart,\n            m = k.renderer.style || {},\n            e = k.renderer,\n            g = k.options.rangeSelector,\n            q = h.div,\n            t = \"min\" === b,\n            z,\n            w,\n            C = this.inputGroup;\n        this[b + \"Label\"] = w = e.label(p.lang[t ? \"rangeSelectorFrom\" : \"rangeSelectorTo\"], this.inputGroup.offset).addClass(\"highcharts-range-label\").attr({\n          padding: 2\n        }).add(C);\n        C.offset += w.width + 5;\n        this[b + \"DateBox\"] = e = e.label(\"\", C.offset).addClass(\"highcharts-range-input\").attr({\n          padding: 2,\n          width: g.inputBoxWidth || 90,\n          height: g.inputBoxHeight || 17,\n          \"text-align\": \"center\"\n        }).on(\"click\", function () {\n          h.showInput(b);\n          h[b + \"Input\"].focus();\n        });\n        k.styledMode || e.attr({\n          stroke: g.inputBoxBorderColor || \"#cccccc\",\n          \"stroke-width\": 1\n        });\n        e.add(C);\n        C.offset += e.width + (t ? 10 : 0);\n        this[b + \"Input\"] = z = l(\"input\", {\n          name: b,\n          className: \"highcharts-range-selector\",\n          type: \"text\"\n        }, {\n          top: k.plotTop + \"px\"\n        }, q);\n        k.styledMode || (w.css(f(m, g.labelStyle)), e.css(f({\n          color: \"#333333\"\n        }, m, g.inputStyle)), u(z, a({\n          position: \"absolute\",\n          border: 0,\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          textAlign: \"center\",\n          fontSize: m.fontSize,\n          fontFamily: m.fontFamily,\n          top: \"-9999em\"\n        }, g.inputStyle)));\n\n        z.onfocus = function () {\n          h.showInput(b);\n        };\n\n        z.onblur = function () {\n          z === d.doc.activeElement && c();\n          h.hideInput(b);\n          z.blur();\n        };\n\n        z.onchange = c;\n\n        z.onkeypress = function (a) {\n          13 === a.keyCode && c();\n        };\n      },\n      getPosition: function () {\n        var a = this.chart,\n            b = a.options.rangeSelector;\n        a = \"top\" === b.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;\n        return {\n          buttonTop: a + b.buttonPosition.y,\n          inputTop: a + b.inputPosition.y - 10\n        };\n      },\n      getYTDExtremes: function (a, b, c) {\n        var d = this.chart.time,\n            f = new d.Date(a),\n            e = d.get(\"FullYear\", f);\n        c = c ? d.Date.UTC(e, 0, 1) : +new d.Date(e, 0, 1);\n        b = Math.max(b || 0, c);\n        f = f.getTime();\n        return {\n          max: Math.min(a || f, f),\n          min: b\n        };\n      },\n      render: function (a, b) {\n        var c = this,\n            d = c.chart,\n            f = d.renderer,\n            e = d.container,\n            g = d.options,\n            h = g.exporting && !1 !== g.exporting.enabled && g.navigation && g.navigation.buttonOptions,\n            k = p.lang,\n            q = c.div,\n            r = g.rangeSelector,\n            t = m(g.chart.style && g.chart.style.zIndex, 0) + 1;\n        g = r.floating;\n        var u = c.buttons;\n        q = c.inputGroup;\n        var w = r.buttonTheme,\n            y = r.buttonPosition,\n            C = r.inputPosition,\n            D = r.inputEnabled,\n            E = w && w.states,\n            G = d.plotLeft,\n            H = c.buttonGroup;\n        var I = c.rendered;\n        var K = c.options.verticalAlign,\n            X = d.legend,\n            Q = X && X.options,\n            S = y.y,\n            ba = C.y,\n            Y = I || !1,\n            Z = Y ? \"animate\" : \"attr\",\n            U = 0,\n            V = 0,\n            aa;\n\n        if (!1 !== r.enabled) {\n          I || (c.group = I = f.g(\"range-selector-group\").attr({\n            zIndex: 7\n          }).add(), c.buttonGroup = H = f.g(\"range-selector-buttons\").add(I), c.zoomText = f.text(k.rangeSelectorZoom, 0, 15).add(H), d.styledMode || (c.zoomText.css(r.labelStyle), w[\"stroke-width\"] = m(w[\"stroke-width\"], 0)), c.buttonOptions.forEach(function (a, b) {\n            u[b] = f.button(a.text, 0, 0, function (d) {\n              var e = a.events && a.events.click,\n                  g;\n              e && (g = e.call(a, d));\n              !1 !== g && c.clickButton(b);\n              c.isActive = !0;\n            }, w, E && E.hover, E && E.select, E && E.disabled).attr({\n              \"text-align\": \"center\"\n            }).add(H);\n          }), !1 !== D && (c.div = q = l(\"div\", null, {\n            position: \"relative\",\n            height: 0,\n            zIndex: t\n          }), e.parentNode.insertBefore(q, e), c.inputGroup = q = f.g(\"input-group\").add(I), q.offset = 0, c.drawInput(\"min\"), c.drawInput(\"max\")));\n          c.zoomText[Z]({\n            x: m(G + y.x, G)\n          });\n          var ea = m(G + y.x, G) + c.zoomText.getBBox().width + 5;\n          c.buttonOptions.forEach(function (a, b) {\n            u[b][Z]({\n              x: ea\n            });\n            ea += u[b].width + m(r.buttonSpacing, 5);\n          });\n          G = d.plotLeft - d.spacing[3];\n          c.updateButtonStates();\n          h && this.titleCollision(d) && \"top\" === K && \"right\" === y.align && y.y + H.getBBox().height - 12 < (h.y || 0) + h.height && (U = -40);\n          \"left\" === y.align ? aa = y.x - d.spacing[3] : \"right\" === y.align && (aa = y.x + U - d.spacing[1]);\n          H.align({\n            y: y.y,\n            width: H.getBBox().width,\n            align: y.align,\n            x: aa\n          }, !0, d.spacingBox);\n          c.group.placed = Y;\n          c.buttonGroup.placed = Y;\n          !1 !== D && (U = h && this.titleCollision(d) && \"top\" === K && \"right\" === C.align && C.y - q.getBBox().height - 12 < (h.y || 0) + h.height + d.spacing[0] ? -40 : 0, \"left\" === C.align ? aa = G : \"right\" === C.align && (aa = -Math.max(d.axisOffset[1], -U)), q.align({\n            y: C.y,\n            width: q.getBBox().width,\n            align: C.align,\n            x: C.x + aa - 2\n          }, !0, d.spacingBox), e = q.alignAttr.translateX + q.alignOptions.x - U + q.getBBox().x + 2, h = q.alignOptions.width, k = H.alignAttr.translateX + H.getBBox().x, aa = H.getBBox().width + 20, (C.align === y.align || k + aa > e && e + h > k && S < ba + q.getBBox().height) && q.attr({\n            translateX: q.alignAttr.translateX + (d.axisOffset[1] >= -U ? 0 : -U),\n            translateY: q.alignAttr.translateY + H.getBBox().height + 10\n          }), c.setInputValue(\"min\", a), c.setInputValue(\"max\", b), c.inputGroup.placed = Y);\n          c.group.align({\n            verticalAlign: K\n          }, !0, d.spacingBox);\n          a = c.group.getBBox().height + 20;\n          b = c.group.alignAttr.translateY;\n          \"bottom\" === K && (X = Q && \"bottom\" === Q.verticalAlign && Q.enabled && !Q.floating ? X.legendHeight + m(Q.margin, 10) : 0, a = a + X - 20, V = b - a - (g ? 0 : r.y) - (d.titleOffset ? d.titleOffset[2] : 0) - 10);\n          if (\"top\" === K) g && (V = 0), d.titleOffset && d.titleOffset[0] && (V = d.titleOffset[0]), V += d.margin[0] - d.spacing[0] || 0;else if (\"middle\" === K) if (ba === S) V = 0 > ba ? b + void 0 : b;else if (ba || S) V = 0 > ba || 0 > S ? V - Math.min(ba, S) : b - a + NaN;\n          c.group.translate(r.x, r.y + Math.floor(V));\n          !1 !== D && (c.minInput.style.marginTop = c.group.translateY + \"px\", c.maxInput.style.marginTop = c.group.translateY + \"px\");\n          c.rendered = !0;\n        }\n      },\n      getHeight: function () {\n        var a = this.options,\n            b = this.group,\n            c = a.y,\n            d = a.buttonPosition.y,\n            f = a.inputPosition.y;\n        if (a.height) return a.height;\n        a = b ? b.getBBox(!0).height + 13 + c : 0;\n        b = Math.min(f, d);\n        if (0 > f && 0 > d || 0 < f && 0 < d) a += Math.abs(b);\n        return a;\n      },\n      titleCollision: function (a) {\n        return !(a.options.title.text || a.options.subtitle.text);\n      },\n      update: function (a) {\n        var b = this.chart;\n        f(!0, b.options.rangeSelector, a);\n        this.destroy();\n        this.init(b);\n        b.rangeSelector.render();\n      },\n      destroy: function () {\n        var a = this,\n            b = a.minInput,\n            d = a.maxInput;\n        a.unMouseDown();\n        a.unResize();\n        q(a.buttons);\n        b && (b.onfocus = b.onblur = b.onchange = null);\n        d && (d.onfocus = d.onblur = d.onchange = null);\n        E(a, function (b, d) {\n          b && \"chart\" !== d && (b.destroy ? b.destroy() : b.nodeType && c(this[d]));\n          b !== w.prototype[d] && (a[d] = null);\n        }, this);\n      }\n    };\n\n    G.prototype.minFromRange = function () {\n      var a = this.range,\n          b = {\n        month: \"Month\",\n        year: \"FullYear\"\n      }[a.type],\n          c = this.max,\n          d = this.chart.time,\n          f = function (a, c) {\n        var e = new d.Date(a),\n            g = d.get(b, e);\n        d.set(b, e, g + c);\n        g === d.get(b, e) && d.set(\"Date\", e, 0);\n        return e.getTime() - a;\n      };\n\n      if (H(a)) {\n        var e = c - a;\n        var g = a;\n      } else e = c + f(c, -a.count), this.chart && (this.chart.fixedRange = c - e);\n\n      var k = m(this.dataMin, Number.MIN_VALUE);\n      H(e) || (e = k);\n      e <= k && (e = k, void 0 === g && (g = f(e, a.count)), this.newMax = Math.min(e + g, this.dataMax));\n      H(c) || (e = void 0);\n      return e;\n    };\n\n    d.RangeSelector || (t(k, \"afterGetContainer\", function () {\n      this.options.rangeSelector.enabled && (this.rangeSelector = new w(this));\n    }), t(k, \"beforeRender\", function () {\n      var a = this.axes,\n          b = this.rangeSelector;\n      b && (H(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {\n        a.updateNames();\n        a.setScale();\n      }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || (\"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0)));\n    }), t(k, \"update\", function (a) {\n      var b = a.options.rangeSelector;\n      a = this.rangeSelector;\n      var c = this.extraBottomMargin,\n          d = this.extraTopMargin;\n      b && b.enabled && !D(a) && (this.options.rangeSelector.enabled = !0, this.rangeSelector = new w(this));\n      this.extraTopMargin = this.extraBottomMargin = !1;\n      a && (a.render(), b = b && b.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || (\"bottom\" === b ? this.extraBottomMargin = !0 : \"middle\" !== b && (this.extraTopMargin = !0)), this.extraBottomMargin !== c || this.extraTopMargin !== d) && (this.isDirtyBox = !0);\n    }), t(k, \"render\", function () {\n      var a = this.rangeSelector;\n      a && !a.options.floating && (a.render(), a = a.options.verticalAlign, \"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0));\n    }), t(k, \"getMargins\", function () {\n      var a = this.rangeSelector;\n      a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));\n    }), k.prototype.callbacks.push(function (a) {\n      function b() {\n        c = a.xAxis[0].getExtremes();\n        H(c.min) && d.render(c.min, c.max);\n      }\n\n      var c,\n          d = a.rangeSelector;\n\n      if (d) {\n        var f = t(a.xAxis[0], \"afterSetExtremes\", function (a) {\n          d.render(a.min, a.max);\n        });\n        var e = t(a, \"redraw\", b);\n        b();\n      }\n\n      t(a, \"destroy\", function () {\n        d && (e(), f());\n      });\n    }), d.RangeSelector = w);\n  });\n  K(I, \"parts/StockChart.js\", [I[\"parts/Globals.js\"], I[\"parts/Utilities.js\"]], function (d, k) {\n    var w = k.defined,\n        D = k.isNumber,\n        H = k.isString,\n        E = k.splat;\n    k = d.addEvent;\n    var y = d.arrayMax,\n        C = d.arrayMin,\n        t = d.Axis,\n        G = d.Chart,\n        u = d.extend,\n        l = d.format,\n        p = d.merge,\n        q = d.pick,\n        c = d.Point,\n        a = d.Renderer,\n        b = d.Series,\n        f = d.SVGRenderer,\n        m = d.VMLRenderer,\n        h = b.prototype,\n        r = h.init,\n        x = h.processData,\n        v = c.prototype.tooltipFormatter;\n\n    d.StockChart = d.stockChart = function (a, b, c) {\n      var e = H(a) || a.nodeName,\n          g = arguments[e ? 1 : 0],\n          f = g,\n          h = g.series,\n          k = d.getOptions(),\n          l,\n          m = q(g.navigator && g.navigator.enabled, k.navigator.enabled, !0),\n          n = m ? {\n        startOnTick: !1,\n        endOnTick: !1\n      } : null;\n      g.xAxis = E(g.xAxis || {}).map(function (a, b) {\n        return p({\n          minPadding: 0,\n          maxPadding: 0,\n          overscroll: 0,\n          ordinal: !0,\n          title: {\n            text: null\n          },\n          labels: {\n            overflow: \"justify\"\n          },\n          showLastLabel: !0\n        }, k.xAxis, k.xAxis && k.xAxis[b], a, {\n          type: \"datetime\",\n          categories: null\n        }, n);\n      });\n      g.yAxis = E(g.yAxis || {}).map(function (a, b) {\n        l = q(a.opposite, !0);\n        return p({\n          labels: {\n            y: -2\n          },\n          opposite: l,\n          showLastLabel: !(!a.categories && \"category\" !== a.type),\n          title: {\n            text: null\n          }\n        }, k.yAxis, k.yAxis && k.yAxis[b], a);\n      });\n      g.series = null;\n      g = p({\n        chart: {\n          panning: !0,\n          pinchType: \"x\"\n        },\n        navigator: {\n          enabled: m\n        },\n        scrollbar: {\n          enabled: q(k.scrollbar.enabled, !0)\n        },\n        rangeSelector: {\n          enabled: q(k.rangeSelector.enabled, !0)\n        },\n        title: {\n          text: null\n        },\n        tooltip: {\n          split: q(k.tooltip.split, !0),\n          crosshairs: !0\n        },\n        legend: {\n          enabled: !1\n        }\n      }, g, {\n        isStock: !0\n      });\n      g.series = f.series = h;\n      return e ? new G(a, g, c) : new G(g, b);\n    };\n\n    k(b, \"setOptions\", function (a) {\n      function b(a) {\n        return d.seriesTypes[a] && c instanceof d.seriesTypes[a];\n      }\n\n      var c = this,\n          f;\n      this.chart.options.isStock && (b(\"column\") || b(\"columnrange\") ? f = {\n        borderWidth: 0,\n        shadow: !1\n      } : !b(\"line\") || b(\"scatter\") || b(\"sma\") || (f = {\n        marker: {\n          enabled: !1,\n          radius: 2\n        }\n      }), f && (a.plotOptions[this.type] = p(a.plotOptions[this.type], f)));\n    });\n    k(t, \"autoLabelAlign\", function (a) {\n      var b = this.chart,\n          c = this.options;\n      b = b._labelPanes = b._labelPanes || {};\n      var d = this.options.labels;\n      this.chart.options.isStock && \"yAxis\" === this.coll && (c = c.top + \",\" + c.height, !b[c] && d.enabled && (15 === d.x && (d.x = 0), void 0 === d.align && (d.align = \"right\"), b[c] = this, a.align = \"right\", a.preventDefault()));\n    });\n    k(t, \"destroy\", function () {\n      var a = this.chart,\n          b = this.options && this.options.top + \",\" + this.options.height;\n      b && a._labelPanes && a._labelPanes[b] === this && delete a._labelPanes[b];\n    });\n    k(t, \"getPlotLinePath\", function (a) {\n      function b(a) {\n        var b = \"xAxis\" === a ? \"yAxis\" : \"xAxis\";\n        a = c.options[b];\n        return D(a) ? [h[b][a]] : H(a) ? [h.get(a)] : f.map(function (a) {\n          return a[b];\n        });\n      }\n\n      var c = this,\n          f = this.isLinked && !this.series ? this.linkedParent.series : this.series,\n          h = c.chart,\n          k = h.renderer,\n          l = c.left,\n          m = c.top,\n          n,\n          p,\n          r,\n          t,\n          u = [],\n          v = [],\n          x = a.translatedValue,\n          y = a.value,\n          C = a.force;\n\n      if (h.options.isStock && !1 !== a.acrossPanes && \"xAxis\" === c.coll || \"yAxis\" === c.coll) {\n        a.preventDefault();\n        v = b(c.coll);\n        var E = c.isXAxis ? h.yAxis : h.xAxis;\n        E.forEach(function (a) {\n          if (w(a.options.id) ? -1 === a.options.id.indexOf(\"navigator\") : 1) {\n            var b = a.isXAxis ? \"yAxis\" : \"xAxis\";\n            b = w(a.options[b]) ? h[b][a.options[b]] : h[b][0];\n            c === b && v.push(a);\n          }\n        });\n        var G = v.length ? [] : [c.isXAxis ? h.yAxis[0] : h.xAxis[0]];\n        v.forEach(function (a) {\n          -1 !== G.indexOf(a) || d.find(G, function (b) {\n            return b.pos === a.pos && b.len === a.len;\n          }) || G.push(a);\n        });\n        var I = q(x, c.translate(y, null, null, a.old));\n        D(I) && (c.horiz ? G.forEach(function (a) {\n          var b;\n          p = a.pos;\n          t = p + a.len;\n          n = r = Math.round(I + c.transB);\n          \"pass\" !== C && (n < l || n > l + c.width) && (C ? n = r = Math.min(Math.max(l, n), l + c.width) : b = !0);\n          b || u.push(\"M\", n, p, \"L\", r, t);\n        }) : G.forEach(function (a) {\n          var b;\n          n = a.pos;\n          r = n + a.len;\n          p = t = Math.round(m + c.height - I);\n          \"pass\" !== C && (p < m || p > m + c.height) && (C ? p = t = Math.min(Math.max(m, p), c.top + c.height) : b = !0);\n          b || u.push(\"M\", n, p, \"L\", r, t);\n        }));\n        a.path = 0 < u.length ? k.crispPolyLine(u, a.lineWidth || 1) : null;\n      }\n    });\n\n    f.prototype.crispPolyLine = function (a, b) {\n      var c;\n\n      for (c = 0; c < a.length; c += 6) a[c + 1] === a[c + 4] && (a[c + 1] = a[c + 4] = Math.round(a[c + 1]) - b % 2 / 2), a[c + 2] === a[c + 5] && (a[c + 2] = a[c + 5] = Math.round(a[c + 2]) + b % 2 / 2);\n\n      return a;\n    };\n\n    a === m && (m.prototype.crispPolyLine = f.prototype.crispPolyLine);\n    k(t, \"afterHideCrosshair\", function () {\n      this.crossLabel && (this.crossLabel = this.crossLabel.hide());\n    });\n    k(t, \"afterDrawCrosshair\", function (a) {\n      var b, c;\n\n      if (w(this.crosshair.label) && this.crosshair.label.enabled && this.cross) {\n        var d = this.chart,\n            f = this.options.crosshair.label,\n            h = this.horiz,\n            k = this.opposite,\n            m = this.left,\n            n = this.top,\n            p = this.crossLabel,\n            r = f.format,\n            t = \"\",\n            v = \"inside\" === this.options.tickPosition,\n            x = !1 !== this.crosshair.snap,\n            y = 0,\n            C = a.e || this.cross && this.cross.e,\n            D = a.point;\n        var E = this.lin2log;\n\n        if (this.isLog) {\n          a = E(this.min);\n          var G = E(this.max);\n        } else a = this.min, G = this.max;\n\n        E = h ? \"center\" : k ? \"right\" === this.labelAlign ? \"right\" : \"left\" : \"left\" === this.labelAlign ? \"left\" : \"center\";\n        p || (p = this.crossLabel = d.renderer.label(null, null, null, f.shape || \"callout\").addClass(\"highcharts-crosshair-label\" + (this.series[0] && \" highcharts-color-\" + this.series[0].colorIndex)).attr({\n          align: f.align || E,\n          padding: q(f.padding, 8),\n          r: q(f.borderRadius, 3),\n          zIndex: 2\n        }).add(this.labelGroup), d.styledMode || p.attr({\n          fill: f.backgroundColor || this.series[0] && this.series[0].color || \"#666666\",\n          stroke: f.borderColor || \"\",\n          \"stroke-width\": f.borderWidth || 0\n        }).css(u({\n          color: \"#ffffff\",\n          fontWeight: \"normal\",\n          fontSize: \"11px\",\n          textAlign: \"center\"\n        }, f.style)));\n        h ? (E = x ? D.plotX + m : C.chartX, n += k ? 0 : this.height) : (E = k ? this.width + m : 0, n = x ? D.plotY + n : C.chartY);\n        r || f.formatter || (this.isDatetimeAxis && (t = \"%b %d, %Y\"), r = \"{value\" + (t ? \":\" + t : \"\") + \"}\");\n        t = x ? D[this.isXAxis ? \"x\" : \"y\"] : this.toValue(h ? C.chartX : C.chartY);\n        p.attr({\n          text: r ? l(r, {\n            value: t\n          }, d.time) : f.formatter.call(this, t),\n          x: E,\n          y: n,\n          visibility: t < a || t > G ? \"hidden\" : \"visible\"\n        });\n        f = p.getBBox();\n\n        if (h) {\n          if (v && !k || !v && k) n = p.y - f.height;\n        } else n = p.y - f.height / 2;\n\n        h ? (b = m - f.x, c = m + this.width - f.x) : (b = \"left\" === this.labelAlign ? m : 0, c = \"right\" === this.labelAlign ? m + this.width : d.chartWidth);\n        p.translateX < b && (y = b - p.translateX);\n        p.translateX + f.width >= c && (y = -(p.translateX + f.width - c));\n        p.attr({\n          x: E + y,\n          y: n,\n          anchorX: h ? E : this.opposite ? 0 : d.chartWidth,\n          anchorY: h ? this.opposite ? d.chartHeight : 0 : n + f.height / 2\n        });\n      }\n    });\n\n    h.init = function () {\n      r.apply(this, arguments);\n      this.setCompare(this.options.compare);\n    };\n\n    h.setCompare = function (a) {\n      this.modifyValue = \"value\" === a || \"percent\" === a ? function (b, c) {\n        var d = this.compareValue;\n        if (void 0 !== b && void 0 !== d) return b = \"value\" === a ? b - d : b / d * 100 - (100 === this.options.compareBase ? 0 : 100), c && (c.change = b), b;\n      } : null;\n      this.userOptions.compare = a;\n      this.chart.hasRendered && (this.isDirty = !0);\n    };\n\n    h.processData = function (a) {\n      var b,\n          c = -1,\n          d = !0 === this.options.compareStart ? 0 : 1;\n      x.apply(this, arguments);\n\n      if (this.xAxis && this.processedYData) {\n        var f = this.processedXData;\n        var h = this.processedYData;\n        var k = h.length;\n        this.pointArrayMap && (c = this.pointArrayMap.indexOf(this.options.pointValKey || this.pointValKey || \"y\"));\n\n        for (b = 0; b < k - d; b++) {\n          var l = h[b] && -1 < c ? h[b][c] : h[b];\n\n          if (D(l) && f[b + d] >= this.xAxis.min && 0 !== l) {\n            this.compareValue = l;\n            break;\n          }\n        }\n      }\n    };\n\n    k(b, \"afterGetExtremes\", function () {\n      if (this.modifyValue) {\n        var a = [this.modifyValue(this.dataMin), this.modifyValue(this.dataMax)];\n        this.dataMin = C(a);\n        this.dataMax = y(a);\n      }\n    });\n\n    t.prototype.setCompare = function (a, b) {\n      this.isXAxis || (this.series.forEach(function (b) {\n        b.setCompare(a);\n      }), q(b, !0) && this.chart.redraw());\n    };\n\n    c.prototype.tooltipFormatter = function (a) {\n      a = a.replace(\"{point.change}\", (0 < this.change ? \"+\" : \"\") + d.numberFormat(this.change, q(this.series.tooltipOptions.changeDecimals, 2)));\n      return v.apply(this, [a]);\n    };\n\n    k(b, \"render\", function () {\n      var a = this.chart;\n\n      if (!(a.is3d && a.is3d() || a.polar) && this.xAxis && !this.xAxis.isRadial) {\n        var b = this.yAxis.len;\n\n        if (this.xAxis.axisLine) {\n          var c = a.plotTop + a.plotHeight - this.yAxis.pos - this.yAxis.len,\n              d = Math.floor(this.xAxis.axisLine.strokeWidth() / 2);\n          0 <= c && (b -= Math.max(d - c, 0));\n        }\n\n        !this.clipBox && this.animate ? (this.clipBox = p(a.clipBox), this.clipBox.width = this.xAxis.len, this.clipBox.height = b) : a[this.sharedClipKey] && (a[this.sharedClipKey].animate({\n          width: this.xAxis.len,\n          height: b\n        }), a[this.sharedClipKey + \"m\"] && a[this.sharedClipKey + \"m\"].animate({\n          width: this.xAxis.len\n        }));\n      }\n    });\n    k(G, \"update\", function (a) {\n      a = a.options;\n      \"scrollbar\" in a && this.navigator && (p(!0, this.options.scrollbar, a.scrollbar), this.navigator.update({}, !1), delete a.scrollbar);\n    });\n  });\n  K(I, \"masters/modules/stock.src.js\", [], function () {});\n  K(I, \"masters/highstock.src.js\", [I[\"masters/highcharts.src.js\"]], function (d) {\n    d.product = \"Highstock\";\n    return d;\n  });\n  I[\"masters/highstock.src.js\"]._modules = I;\n  return I[\"masters/highstock.src.js\"];\n});","map":null,"metadata":{},"sourceType":"script"}